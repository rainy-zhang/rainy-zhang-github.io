<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Java并发">
<meta property="og:url" content="http://example.com/2022/12/08/Java%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Rainy Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-08T08:02:11.000Z">
<meta property="article:modified_time" content="2022-12-08T08:03:15.963Z">
<meta property="article:author" content="Rainy">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/12/08/Java%E5%B9%B6%E5%8F%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java并发 | Rainy Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rainy Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/08/Java%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rainy Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-12-08 16:02:11 / 修改时间：16:03:15" itemprop="dateCreated datePublished" datetime="2022-12-08T16:02:11+08:00">2022-12-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <div class="post-description"> </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="产生并发安全问题的原因"><a href="#产生并发安全问题的原因" class="headerlink" title="产生并发安全问题的原因"></a>产生并发安全问题的原因</h3><p>在计算机架构中，一直有一个核心矛盾，就是CPU、内存、I/O设备这三者的读写速度差异很大，为了平衡读写速度：</p>
<ol>
<li>给CPU增加了缓存，用来平衡CPU和内存的速度差异，<a href="#CPU%E7%BC%93%E5%AD%98%E5%AF%BC%E8%87%B4%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98">会导致数据可见性问题</a>。</li>
<li>又增加了进程和线程，来复用CPU缓存，用来平衡CPU和I/O设备的速度差异，<a href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98">线程切换会带来原子性问题</a>。</li>
<li>编译程序也会优化指令执行顺序，让程序更加合理的运用缓存，<a href="#%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98">会带来有序性问题</a>。</li>
</ol>
<p>⭐<b id='CPU缓存导致的可见性问题'>CPU缓存导致的可见性问题</b>：</p>
<p>在单核时代，所有线程都运行在同一个CPU上，所有线程操作的都是同一个CPU缓存，一个线程对缓存的读写，对另外一个线程是可见的，所以不会有可见性问题。</p>
<p>在多核时代，每个CPU都有自己的缓存，线程运行在不同的CPU上，这些线程操作的不是同一个CPU缓存，一个线程对变量的写操作对另一个线程就不具备可见性了。</p>
<blockquote>
<p>比如有两个线程对同一个共享变量做+1操作，每个线程循环100次，最终得到的值是100~200之间的随机数，而不是200。</p>
</blockquote>
<p><strong>Java中可以通过<a href="#volatile">volatile</a>关键字禁用CPU缓存，解决可见性问题</strong>。</p>
<blockquote>
<p>也就是说，对于volatile字段的写操作其它线程是可以看到的。</p>
<p>volatile关键字解决不了<code>i++</code>操作，因为还会有原子性问题。</p>
</blockquote>
<p>⭐<b id='线程切换导致的原子性问题'>线程切换导致的原子性问题</b>：</p>
<p>我们写代码时，一行表达式通常会被编译成多条指令，比如<code>i++</code>就需要3条指令才能完成：</p>
<ol>
<li>把<code>i</code>从内存加载到CPU寄存器。</li>
<li>在寄存器中执行+1操作。</li>
<li>最后把结果写回内存。</li>
</ol>
<p>假设有两个线程对共享变量<code>i</code>做<code>+1</code>操作：</p>
<ol>
<li>线程A把<code>i=0</code>加载到寄存器。</li>
<li>然后切换线程，线程B执行完<code>+1</code>操作并写回内存。</li>
<li>线程A会以寄存器中的值为准，<code>+1</code>后并写回内存，最终的结果就是1。</li>
</ol>
<blockquote>
<p>原子性是指：<strong>多个操作的执行过程，不被中断的特性被称为原子性</strong>。</p>
</blockquote>
<p><strong>在Java中可以通过<a href="#Synchronized">Synchronized</a>解决原子性问题</strong>。</p>
<p>⭐<b id='编译优化带来的有序性问题'>编译优化带来的有序性问题</b>：</p>
<p>有一个经典的案例就是，单例模式的<a href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6">双重检测机制</a>。之所以要做双重检测，是因为<code>new</code>关键字经过编译优化后，指令序列可能会发生变化。</p>
<blockquote>
<p>new关键字包含三个指令：</p>
<ol>
<li>分配一块内存</li>
<li>在内存上初始化对象</li>
<li>把内存地址赋值给变量</li>
</ol>
<p>优化之后的指令序列可能是：</p>
<ol>
<li>分配一块内存</li>
<li>把内存地址赋值给变量</li>
<li>在内存上初始化对象</li>
</ol>
<p>假设有两个线程同时获取这个单例对象：</p>
<ol>
<li>线程A发现对象为空，就开始加锁并创建对象，线程A执行<code>new</code>操作的时候，先把内存地址赋值给了成员变量，但是内存中的对象还没有初始化。</li>
<li>然后线程切换，线程B发现对象不为空，就直接返回当前未被初始化的对象，如果调用这个对象的方法，就会出现空指针异常。</li>
</ol>
</blockquote>
<p><strong>对于volatile字段，Java编译器会在该字段的读写操作前后插入内存屏障，来禁止指令重排序</strong>。</p>
<h3 id="⭐线程池"><a href="#⭐线程池" class="headerlink" title="⭐线程池"></a>⭐线程池</h3><p>线程池可以重复利用已创建的线程，降低线程创建和销毁造成的消耗。</p>
<p>当收到请求时，不需要等待线程创建就能立即执行。</p>
<p>线程池的逻辑是这样的：</p>
<ol>
<li>线程池内部会维护一个任务队列。</li>
<li>在收到一个任务后，首先会判断当前线程池中的任务数量是否小于核心线程的数量，如果小于的话，创建一个线程，开始执行任务。</li>
<li>如果任务数量大于或者等于核心线程数，就会把新的任务放到等待队列中。</li>
<li>如果等待队列满了，就会开始创建新的线程，如果创建的线程数量达到最大线程数的配置之后，就会触发拒绝策略（默认是抛异常）。</li>
<li>如果创建线程失败，也会开始执行拒绝策略。</li>
</ol>
<blockquote>
<p>实际上，优先把任务放到队列中，比较适合CPU密集型的任务，因为CPU密集型的任务执行时，CPU占用率会比较高，只需要创建和CPU核心数差不多的线程数量就好，线程多了反而会造成上下文切换，降低执行效率。</p>
<p>但是我们平时开发的Web项目，通常都属于IO密集型，所以Tomcat线程池就是当线程数超过核心线程数之后，会优先创建线程，直到超过最大线程数，才会把请求放到等待队列。</p>
<p>这样是更适合IO密集型场景的。</p>
</blockquote>
<h4 id="⭐核心参数"><a href="#⭐核心参数" class="headerlink" title="⭐核心参数"></a>⭐核心参数</h4><ul>
<li><p><strong>corePoolSize</strong>：核心线程数，线程池中最少的线程数量。</p>
</li>
<li><p><strong>maximumPoolSize</strong>：表示线程池最大线程数，如果线程池的核心线程都在运行中，并且等待队列也满了之后，就会开始创建额外的线程，额外线程的数量最多不会超过这个参数指定的数量。</p>
</li>
<li><p><strong>workQueue</strong>：等待队列，如果线程池收到的任务大于核心线程的数量，额外的任务就会放到这个等待队列中。</p>
</li>
<li><p><strong>keepAliveTime</strong>：如果一个线程在这个参数指定的时间内都没有收到新的任务，并且线程池中的线程数量大于核心线程数，这些多余的线程就会被回收掉。</p>
</li>
<li><p><strong>unit</strong>：keepAliveTime 参数的时间单位。</p>
</li>
<li><p><strong>threadFactory</strong>：ThreadFactory是一个接口，可以重写<code>newThread()</code>方法自定义创建线程的逻辑。</p>
</li>
<li><p><strong>handler</strong>：如果线程池中核心线程都在运行的时候，会把新的任务放到等待队列中，如果等待队列满了之后，就会开始创建新的线程，如果创建的线程数量达到最大线程数的配置之后，就会触发拒绝策略了。</p>
<blockquote>
<p><strong>线程池提供了4种拒绝策略</strong>：</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy：抛出异常来拒绝处理新任务，这是默认的拒绝策略。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：让提交任务的线程来执行这个任务。</li>
<li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：把最早进入等待队列的任务丢弃掉。</li>
<li>也可以通过实现<code>RejectedExecutionHandler</code>接口，重写<code>rejectedExecution</code>方法来自定义拒绝策略。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="⭐线程池大小如何定义"><a href="#⭐线程池大小如何定义" class="headerlink" title="⭐线程池大小如何定义"></a>⭐线程池大小如何定义</h4><p>线程池的大小，要看具体的应用场景。</p>
<p>CPU密集型：</p>
<blockquote>
<p>如果大部分功能都是纯CPU计算，那就是CPU密集型程序。比如对内存中的数据做大量运算。</p>
</blockquote>
<p>对于CPU密集型应用，一个4核的CPU，每个核心对应一个线程，理论上创建4个线程就可以了，创建再多的线程只会增加线程切换的成本。所以<strong>线程的数量 = CPU核心数</strong>就是合适的。</p>
<p>不过线程有些时候可能会因为一些原因进入阻塞状态，所以可以多设置一个线程，保证CPU的利用率。<strong>线程数量可以设置为CPU核心数+1</strong>。</p>
<p>I/O密集型：</p>
<blockquote>
<p>CPU计算和I/O操作交叉执行，但是因为I/O操作耗时比较长，所以这种场景一般称为I/O密集型计算。</p>
<p>（网络、磁盘、数据库都属于I/O操作）</p>
</blockquote>
<p>一个单核计算机，假设我们需要从表1中查询数据，计算完成后，再写入到表2中。假设有A、B、C三个线程：</p>
<ol>
<li>线程A查询数据（I/O操作），线程B和线程C阻塞；（I/O设备利用率100%，CPU利用率0%）</li>
<li>线程A获取到数据后，在内存中计算（CPU操作），线程B开始查询数据（I/O操作）。（I/O设备利用率100%，CPU利用率100%）</li>
<li>线程A计算完成后，继续执行最后的写表操作（I/O操作），线程B获取到数据后开始计算（CPU操作），线程C查询数据（I/O操作）。（I/O设备利用率100%，CPU利用率100%）</li>
<li><strong>线程数量可以设置为3</strong>.</li>
</ol>
<p>**对于多核CPU最佳线程数 = CPU核心数 * [1 + (I/O耗时 / CPU耗时)]**。</p>
<blockquote>
<p>对于4核8线程这种超线程技术，是指一个CPU物理核心包含两个逻辑核心，这两个逻辑核心也还是会存在竞争，所以这两个逻辑核心并不能完全并行运行。所以不管是4还是8都不一定是最合适的，还需要根据具体的测试结果进行调整。</p>
</blockquote>
<h4 id="⭐如何获取执行结果"><a href="#⭐如何获取执行结果" class="headerlink" title="⭐如何获取执行结果"></a>⭐如何获取执行结果</h4><p>ThreadPoolExecutor提供了3个submit()方法配合FutureTask工具类来支持获得线程池的返回值。</p>
<p>这三个submit()方法的返回值都是Future接口，Future接口提供了2个get()方法用来获取返回值（一个包含超时机制，一个没有超时机制）。</p>
<p>这两个get()方法都是阻塞的，如果任务没有执行完，会导致调用方被阻塞，直到任务完成或者超时才会被唤醒。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> ThreadPoolExecutor.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建结果引用</span></span><br><span class="line"> <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line"> result.setData(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 提交任务</span></span><br><span class="line"> Future&lt;Result&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(result), result);</span><br><span class="line"> <span class="comment">// 获取线程池返回值</span></span><br><span class="line"> <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> future.get();</span><br><span class="line"> res.getData();	<span class="comment">// lisi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Result result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(Result result)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.result = result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		result.setData(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>Java中的线程一共有5种状态，分别是：</p>
<ol>
<li><p><strong>初始化状态</strong>：指的是线程已经被创建了，但是还没有被分配CPU执行，是在编程语言层面被创建，在操作系统层面还没被创建。</p>
</li>
<li><p><strong>可运行状态</strong>：指的是线程在操作系统层面线程已经被创建出来了，可以分配给CPU执行。</p>
</li>
<li><p><strong>运行状态</strong>：当有空闲的CPU时，操作系统就会把CPU分配给可运行状态的线程，被分配的线程就会变成运行状态。</p>
</li>
<li><p><strong>阻塞状态</strong>：运行状态中的线程，如果调用了一个阻塞API，线程就会变为阻塞状态，并且让出CPU的使用权。</p>
</li>
<li><p><strong>终止状态</strong>：线程执行完run()方法，会自动进入终止状态。也可以手动调用<code>stop()</code> 或者 <code>interrupt() </code>方法终止一个线程。</p>
<blockquote>
<p><code>stop()</code> 和 <code>interrupt() </code>方法的区别：</p>
<ul>
<li><p><code>stop()</code>方法会立刻杀死线程，线程持有的锁也会不释放，那其它线程就再也没有机会获得这个锁了。</p>
<ul>
<li>类似的方法还有<code>suspend()</code>和<code>resume()</code>。</li>
</ul>
</li>
<li><p><code>interrupt()</code>只会通知线程，线程还可以继续执行后续的操作。</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="阻塞线程的方式"><a href="#阻塞线程的方式" class="headerlink" title="阻塞线程的方式"></a>阻塞线程的方式</h3><ul>
<li>**sleep()**：<ul>
<li>sleep方法可以指定一个以毫秒为单位的时间，线程在这个时间内会进入阻塞状态。</li>
<li><strong>不会释放锁</strong>，会让出CPU时间片，等待再次调度。</li>
</ul>
</li>
<li>**yield()**：<ul>
<li>yield方法会让出cpu时间片，但是线程还是会处于可执行的状态，当下次获得时间片之后还是会正常执行。</li>
<li><strong>不会释放锁</strong>。</li>
</ul>
</li>
<li>**wait()**：<ul>
<li>wait方法会使线程进入阻塞状态，wait方法可以指定一个以毫秒为单位的时间，时间到了之后会自动唤醒。如果不指定时间则需要通过notify()或者notifyAll()方法来唤醒，否则会一直阻塞。</li>
<li><strong>会释放锁</strong>，会让出CPU时间片，等待再次调度。</li>
</ul>
</li>
<li>**join()**：<ul>
<li>当线程A调用线程B的join方法，线程A就会进入阻塞状态，直到线程B运行结束，线程A才会进入可执行状态。</li>
<li>底层还是调用wait方法，<strong>会释放锁</strong></li>
</ul>
</li>
<li>**notify()和notifyAll()**：<ul>
<li>notify()会随机唤醒一个等待中的线程，notifyAll()会唤醒所有等待中的线程。但是notify()有可能导致一些线程无法直接被唤醒。</li>
<li>假设有A、B两个资源，线程1申请到了A、线程2申请到了B、线程3再次申请A会进入等待队列，线程4申请B会进入等待队列。这个时候等待队列中有3、4两个线程。线程1归还资源后，如果用notify()来通知等待队列中的线程，有可能被通知的线程是4，但是线程4申请的是资源B，所以还会继续等待。</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>产生死锁的4个条件</strong>：</p>
<ol>
<li>互斥：共享资源只能被一个线程占用。</li>
<li>占有且等待：线程A占有资源A，在等待资源B的时候，不释放资源A。</li>
<li>不可抢占：其它线程不能抢占线程A已经占有的资源。</li>
<li>循环等待：线程A等待线程B占有的资源，线程B等待线程A占有的资源。</li>
</ol>
<p><strong>预防死锁</strong>：</p>
<p>对资源进行加锁时，可以先对资源排序，然后按照顺序加锁。这样就不会出现线程1占用资源A，线程2占用资源B，双方都等待对方释放资源了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">	<span class="comment">// 转账</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">		<span class="type">Account</span> <span class="variable">left</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">		<span class="type">Account</span> <span class="variable">right</span> <span class="operator">=</span> target;</span><br><span class="line">        <span class="comment">// 根据id对账户进行排序</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.getId() &gt; target.getId()) &#123;</span><br><span class="line">			right = target;</span><br><span class="line">			left = <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">synchronized</span>(left) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(right) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; money) &#123;</span><br><span class="line">					<span class="built_in">this</span>.balance -= money;</span><br><span class="line">					target.balance += money;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>等待-通知优化循环等待</strong>：</p>
<p><strong>可以通过synchronized关键字配合wait()、notify()、notifyAll()这三个方法实现等待通知机制</strong>。</p>
<p>就是在synchronized代码块中，判断条件如果不满足，就调用wait()方法让当前线程进入等待状态。其他线程执行完毕之后，调用notifyAll()方法唤醒等待队列中的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> List&lt;Object&gt; als = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> 	<span class="comment">// 一次性申请所有资源</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Object from, Object to)</span>&#123;</span><br><span class="line"> 		<span class="comment">// 经典写法</span></span><br><span class="line"> 		<span class="keyword">while</span>(als.contains(from) || als.contains(to))&#123;</span><br><span class="line"> 			<span class="keyword">try</span> &#123;</span><br><span class="line"> 				wait();</span><br><span class="line"> 			&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"> 			</span><br><span class="line"> 			&#125;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	als.add(from);</span><br><span class="line">		als.add(to);</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="comment">// 归还资源</span></span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Object from, Object to)</span>&#123;</span><br><span class="line">		 als.remove(from);</span><br><span class="line">		 als.remove(to);</span><br><span class="line">		 notifyAll();</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Allocator</span> <span class="variable">allocator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Allocator</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        allocator.apply(o1, o2);</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        allocator.free(o1, o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="⭐锁定义"><a href="#⭐锁定义" class="headerlink" title="⭐锁定义"></a>⭐锁定义</h3><h4 id="⭐乐观锁-悲观锁"><a href="#⭐乐观锁-悲观锁" class="headerlink" title="⭐乐观锁 / 悲观锁"></a>⭐<b id='乐观锁'>乐观锁 </b>/ <b id='悲观锁'>悲观锁</b></h4><p><strong>乐观锁</strong>：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断数据是否发生变更。如果数据已经被其他线程更新，则报错或者重试。<strong>乐观锁适合读多写少操作</strong>。</p>
<blockquote>
<p>乐观锁在Java中是通过使用无锁编程来实现，通常采用的是<a href="#CAS">CAS</a>算法，Java原子类中的递增操作就通过<a href="#CAS">CAS</a>实现的。</p>
</blockquote>
<p><strong>悲观锁</strong>：悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p>
<p><strong>悲观锁适合写操作多的场景</strong>。</p>
<blockquote>
<p><a href="#synchronized">synchronized</a>关键字和Lock接口的实现类都是悲观锁。</p>
</blockquote>
<h4 id="⭐偏向锁"><a href="#⭐偏向锁" class="headerlink" title="⭐偏向锁"></a>⭐<b id='偏向锁'>偏向锁</b></h4><p>偏向锁认为，同一把锁只会被一个线程多次获得，不存在多线程竞争。</p>
<p>在JVM中，当一个线程获取偏向锁时，会在对象头中的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>中存储当前线程的ID，在加锁和解锁时，只需要判断<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>中是否保存着当前线程的ID就可以了。</p>
<h4 id="⭐轻量级锁"><a href="#⭐轻量级锁" class="headerlink" title="⭐轻量级锁"></a>⭐<b id='轻量级锁'>轻量级锁</b></h4><p>当<a href="#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>被多个线程访问时，就会升级为轻量级锁。</p>
<p>加锁时，JVM会在当前线程的栈帧分配一块空间，用来保存锁记录（Lock Record），然后把锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>拷贝到锁记录中。</p>
<p>然后通过<a href="#CAS">CAS</a>操作，把<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>替换为锁记录的内存地址：</p>
<ul>
<li>如果更新成功，就说明加锁成功。</li>
<li>如果更新失败，就说明有其它线程获取当前锁，Java虚拟机就会把这把锁升级为<a href="#synchronized-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">重量级锁</a>，并阻塞当前线程。</li>
</ul>
<p>解锁时，Java虚拟机会通过<a href="#CAS">CAS</a>操作，比较锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>是否是锁记录的地址。</p>
<ul>
<li>如果是，就把<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>替换为锁记录中的值，也就是锁对象原本的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>。这样就成功释放锁了。</li>
<li>如果不是，说明锁已经升级为<a href="#synchronized-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">重量级锁</a>了。</li>
</ul>
<h4 id="⭐重量级锁"><a href="#⭐重量级锁" class="headerlink" title="⭐重量级锁"></a>⭐<b id='重量级锁'>重量级锁</b></h4><p>重量级锁会阻塞所有加锁失败的线程，解锁时再唤醒这些线程。</p>
<h4 id="⭐自旋锁-适应性自旋锁"><a href="#⭐自旋锁-适应性自旋锁" class="headerlink" title="⭐自旋锁 / 适应性自旋锁"></a>⭐<b id='自旋锁'>自旋锁</b> / <b id='适应性自旋锁'>适应性自旋锁</b></h4><p><strong>自旋锁</strong>：因为阻塞或者唤醒一个Java线程，需要操作系统切换CPU状态来完成，如果代码中的逻辑比较简单，状态转换消耗的时间有可能比代码执行的时间还要长。</p>
<p>所以为了减少减少线程切换带来的消耗，可以让没有获取到锁的线程去执行一个无意义的循环。如果循环结束后锁已经被释放了，当前线程就可以避免切换线程的开销。</p>
<p>自旋锁也是有缺点的，自旋虽然可以避免切换线程的开销，但是会占用处理器时间。如果锁被占用的时间很短，自旋锁的效果就很好，否则自旋只会白白浪费处理器资源。所以自旋一定要有次数限制（默认是10次，可以通过<code>-XX:PreBlockSpin</code>修改）。</p>
<p><strong>适应性自旋锁</strong>：</p>
<p>JDK1.6引入了适应性自旋锁，适应性自旋表示自旋的次数不固定，而是根据以往能否通过自旋获取到锁来决定。</p>
<p>如果通过自旋获取到锁的概率非常高，Java虚拟机就会允许自旋更长的时间。</p>
<p>如果某个锁只有很少的次数能通过自旋获取到，Java虚拟机就会减少自旋时间或者跳过自旋，直接阻塞线程。</p>
<h4 id="⭐可重入锁-不可重入锁"><a href="#⭐可重入锁-不可重入锁" class="headerlink" title="⭐可重入锁 / 不可重入锁"></a>⭐<b id='可重入锁'>可重入锁</b> / <b id='不可重入锁'>不可重入锁</b></h4><p>如果一个类中有多个synchronized方法，这些方法之间相互调用，就会对同一把锁重复加锁。</p>
<p>如果是可重入锁，就可以正常加锁。</p>
<p>如果是不可重入锁，就会产生死锁。</p>
<blockquote>
<p>ReentrantLock 和 synchronized 都是可重入锁。</p>
</blockquote>
<h4 id="⭐公平锁-非公平锁"><a href="#⭐公平锁-非公平锁" class="headerlink" title="⭐公平锁 / 非公平锁"></a>⭐<b id='公平锁'>公平锁</b> / <b id='非公平锁'>非公平锁</b></h4><p><strong>公平锁</strong>：</p>
<p>公平锁是指多个线程直接在队列中排队，队列中第一个线程才能获得锁。</p>
<p>公平锁的优点是每个线程都能获取到锁，不会饿死。</p>
<p>缺点是效率比非公平锁低，队列中除了第一个线程都会阻塞，CPU唤醒线程的开销会很大。</p>
<blockquote>
<p>ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认是非公平锁。传入true就是公平锁。</p>
</blockquote>
<p><strong>非公平锁</strong>：</p>
<p>非公平锁是指多个线程加锁时，直接尝试获取锁，获取不到的才会进入等待队列。如果某一个线程尝试获取锁时，锁刚好可用，这个线程可以直接获取到锁。</p>
<p>非公平锁的优点是可以减少唤醒线程的开销，因为线程有几率不阻塞直接获取到锁。</p>
<p>缺点是等待队列中的线程可能会饿死，或者要等很久才能获取到锁。</p>
<blockquote>
<p><a href="#synchronized">synchronized</a>是非公平锁，ReentantLock默认也是非公平锁。</p>
</blockquote>
<h4 id="⭐独占锁-共享锁"><a href="#⭐独占锁-共享锁" class="headerlink" title="⭐独占锁 / 共享锁"></a>⭐<b id='独占锁'>独占锁</b> / <b id='共享锁'>共享锁</b></h4><p><strong>独占锁</strong>：独占锁只能被一个线程持有。</p>
<blockquote>
<p><a href="#synchronized">synchronized</a>和JUC中Lock接口的实现类都是互斥锁。</p>
</blockquote>
<p><strong>共享锁</strong>：共享锁可以被多个线程持有，共享锁与独占锁之间是互斥的。获得共享锁的线程只能读数据，不能修改数据。</p>
<blockquote>
<p><code>ReentrantReadWriteLock</code>类中有两把锁：<code>ReadLock</code>和<code>WriteLock</code>，可以分别加读锁和写锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K, V&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">	<span class="comment">// 读锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">	<span class="comment">// 写锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果缓存不存在，就加载数据到缓存中</span></span><br><span class="line">	<span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">		<span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 加读锁</span></span><br><span class="line">         readLock.lock();</span><br><span class="line">         value = cache.get(key);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         readLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 加写锁</span></span><br><span class="line">         writeLock.lock();</span><br><span class="line">         <span class="comment">// 查询数据库</span></span><br><span class="line">         value = fromDB(key);</span><br><span class="line">         cache.put(key, value);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         writeLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐CAS"><a href="#⭐CAS" class="headerlink" title="⭐CAS"></a>⭐<b id='CAS'>CAS</b></h3><p>CAS全称 Compare And Swap（比较并替换），是一种无锁算法。</p>
<blockquote>
<p>单核 CPU 和多核 CPU 下都能够保证的原子性。</p>
<p>在多核CPU环境下：</p>
<ol>
<li>通过总线锁，保证修改操作的互斥性</li>
<li>通过缓存一致性协议，保证CPU缓存中的值对其它核心可见</li>
<li>通过内存屏障，保证多线程下的有序性</li>
</ol>
</blockquote>
<p>CAS算法需要三个参数：</p>
<ul>
<li>需要修改的原值</li>
<li>要比较的期望值</li>
<li>要写入的新值</li>
</ul>
<p>当 “原值” 等于 “期望值” 时，通过原子操作用 “新值” 替换 “原值”，否则就重新执行CAS流程。</p>
<p>CAS虽然很高效，但是也有两个问题：</p>
<ul>
<li><p><strong>ABA问题</strong>：CAS会检查 “原值” 是否发生变化，如果原来是A，后来变成了B，然后又变成了A，那么CAS进行检查的时候会发现 “原值” 没有变化过，但实际上是有变化的。</p>
<p>解决思路就是给数据添加版本号，每次更新数据都把版本号加一。</p>
<blockquote>
<p>JDK1.5提供了<code>AtomicStampedReference</code>类来解决ABA问题，具体的逻辑封装在<code>compareAndSet()</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是原值，第二个参数是版本号</span></span><br><span class="line">AtomicStampedReference&lt;String&gt; asf = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;String&gt;(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是期望值，第二个参数是新值，第三个参数是期望版本号，第四个参数是新版本号</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> asf.compareAndSet(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>只能保证单个变量的原子操作</strong>，多个共享变量无法保证原子操作。</p>
<blockquote>
<p>JDK1.5提供了<code>AtomicReference</code>类来保证对象之间的原子性，可以把多个变量放在一个对象里面进行原子操作。</p>
</blockquote>
</li>
</ul>
<h3 id="⭐JUC常用原子类"><a href="#⭐JUC常用原子类" class="headerlink" title="⭐JUC常用原子类"></a>⭐JUC常用原子类</h3><p><strong>基本类型</strong>：</p>
<p>AtomicInteger、AtomicLong、AtomicBoolean。</p>
<p>主要方法：</p>
<ul>
<li><code>getAndIncrement()</code>：原子化的<code>i++</code>。</li>
<li><code>getAndDecrement()</code>：原子化的<code>i--</code>。</li>
<li><code>incrementAndGet()</code>：原子化的<code>++i</code>。</li>
<li><code>decrementAndGet()</code>：原子化的<code>--i</code>。</li>
<li><code>compareAndSet()</code>：CAS操作，返回是否成功。</li>
</ul>
<p><strong>引用类型</strong>：</p>
<p>AtomicReference、AtomicStampedReference、AtomicMarkableReference。可以实现引用类型对象属性的原子化更新。</p>
<p>主要方法：</p>
<ul>
<li><code>compareAndSet()</code>：CAS操作，返回是否成功。</li>
</ul>
<p><strong>数组</strong>：</p>
<p>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray。可以实现原子化更新数组中的每一个元素。</p>
<p>主要方法：</p>
<ul>
<li><code>compareAndSet()</code>：CAS操作，返回是否成功。</li>
</ul>
<p><strong>累加器</strong>：</p>
<p>DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder。只能用来执行累加操作，相比原子化的基本类型，计算速度更快，但是不支持<code>compareAndSet()</code>方法。</p>
<p>主要方法：</p>
<ul>
<li><code>increment()</code>：累加。</li>
<li><code>decrement()</code>：减少。</li>
</ul>
<h3 id="⭐AQS"><a href="#⭐AQS" class="headerlink" title="⭐AQS"></a>⭐AQS</h3><p>AbstractQueuedSynchronizer（AQS）：它是AQS体系的核心基类，实现了锁的基本结构，内部的数据结构是链表，它继承自AOS。</p>
<blockquote>
<p>AbstractOwnableSynchronizer（AOS）：用来记录锁当前的持有者。</p>
</blockquote>
<p>ReentrantLock是锁的具体实现，它继承自Lock抽象类，用内部类Sync继承AQS，所以ReentrantLock具体的锁实现都是委托Sync完成的。</p>
<blockquote>
<p>Sync有两个子类，分别是FairSync（公平锁）和NonfairSync（非公平锁）</p>
</blockquote>
<p><strong>获取锁</strong>：</p>
<p>调用<code>tryLock()</code>方法获取锁时，会委托给Sync来处理。</p>
<p>首先会判断当前的锁状态，state如果等于0，表示当前锁没有被占用，公平锁和非公平锁会有不同的处理逻辑：</p>
<ul>
<li>如果是公平锁：需要先判断等待队列中有没有其它线程在排队。<ul>
<li>如果有，就返回false并进入等待队列。</li>
<li>如果没有，就返回true，然后通过<a href="#CAS">CAS</a>操作更新state，如果更新成功，说明成功获取锁，就设置锁的拥有者为当前线程。否则就进入等待队列。</li>
</ul>
</li>
<li>如果是非公平锁：通过<a href="#CAS">CAS</a>操作更新state。<ul>
<li>如果更新成功，说明成功获取锁，就设置锁的拥有者为当前线程。</li>
<li>如果更新失败，就直接进入等待队列。</li>
</ul>
</li>
</ul>
<p>如果state不等于0，说明锁已经被占用，会判断当前线程是不是锁的持有者：</p>
<ul>
<li>如果是，就通过<a href="#CAS">CAS</a>更新state。</li>
<li>如果不是，就进入等待队列。</li>
</ul>
<p><strong>释放锁</strong>：</p>
<p>调用<code>unlock()</code>方法释放锁时，会委托给Sync来处理。</p>
<p>释放锁主要包含这样几个步骤：</p>
<ol>
<li>判断当前线程释放是锁的持有者，如果不是则抛异常。</li>
<li>判断state是否为0，如果为0，表示锁已释放，需要唤醒等待队列中的线程。</li>
</ol>
<h3 id="⭐ThreadLocal"><a href="#⭐ThreadLocal" class="headerlink" title="⭐ThreadLocal"></a>⭐<b id='ThreadLocal'>ThreadLocal</b></h3><p>比如MVC架构的Web应用，在Service层无法直接获取HttpServletRequest，需要通过Controller以参数的形式传递进来。可以用ThreadLocal解决这种过度传参的问题。</p>
<blockquote>
<p>可以在拦截器中把HttpServletRequest放到ThreadLocal中，Service层就可以直接获取了。需要注意的是要在拦截器中请求结束的回调方法中清除ThreadLocal，不然可能会导致<a href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄漏</a>。</p>
</blockquote>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>Thread内部维护了一个ThreadLocalMap对象，ThreadLocalMap是ThreadLocal中的内部类，</p>
<p>ThreadLocal只是一个代理类，内部并不保存任何数据。</p>
<p>ThreadLocalMap内部用一个Entry数组保存数据，Entry对ThreadLocal是弱引用。</p>
<ul>
<li><p>ThreadLocalMap保存数据的时候，会根据ThreadLocal对象的hash值定位数组的位置，所以也会有Hash冲突：</p>
<ul>
<li><p>在遇到Hash冲突时，如果是同一个ThreadLocal则替换Entry中的value，否则就直接寻找下一个空闲的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">		ThreadLocal&lt;?&gt; k = e.get();	<span class="comment">// 这里的get()方法是Reference类中的</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;	<span class="comment">// 如果是同一个ThreadLocal，就直接替换Value</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;	<span class="comment">// 如果目标位置为空，则插入数据，否则继续找下一个位置</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ThreadLocalMap获取数据的时候，也是根据ThreadLocal对象的hash值获取数组中对应的数据，获取到数据之后还需要判断是否是同一个ThreadLocal，如果不是就继续找下一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">	<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key) &#123;	<span class="comment">// 判断是否是同一个ThreadLocal</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// getEntryAfterMiss(): 会遍历ThreadLocalMap中所有Entry，直到找到ThreadLocal相同的元素</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>之所以要用Entry数组保存数据，是因为一个Thread可以创建多个ThreadLocal，这些ThreadLocal保存的数据只会放在同一个ThreadLocalMap中。</p>
</blockquote>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><b id='ThreadLocal内存泄漏'>内存泄漏</b></h4><p>线程池中的线程可能会一直存活下去，这就意味着Thread持有的ThreadLocalMap不会被回收，然后ThreadLocalMap中的Entry对ThreadLocal是<a href="#%E5%BC%B1%E5%BC%95%E7%94%A8">弱引用</a>，所以ThreadLocal是可以被回收掉的。但是Entry对Value是<a href="#%E5%BC%BA%E5%BC%95%E7%94%A8">强引用</a>的，所以Value无法被回收也无法被访问到，就会导致内存泄漏。</p>
<p>所以在写代码时，使用完ThreadLocal一定要在finally代码块中调用<code>remove()</code>方法。</p>
<h3 id="⭐ReentrantLock"><a href="#⭐ReentrantLock" class="headerlink" title="⭐ReentrantLock"></a>⭐<b id='ReentrantLock'>ReentrantLock</b></h3><p>ReentrantLock继承自Lock接口，它是可重入锁。</p>
<p>可以通过构造函数设置为公平锁，默认是非公平锁。</p>
<ul>
<li><code>lock()</code>：获取锁，如果锁被其它线程持有，则阻塞当前线程，直到获取到锁。</li>
<li><code>tryLock()</code>：尝试获取锁，如果获取到锁则返回true，否则返回false。不会阻塞当前线程。</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">	<span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			value++;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐ReentrantReadWriteLock"><a href="#⭐ReentrantReadWriteLock" class="headerlink" title="⭐ReentrantReadWriteLock"></a>⭐<b id='ReentrantReadWriteLock'>ReentrantReadWriteLock</b></h3><p>ReentrantReadWriteLock实现了ReadWriteLock接口，它是支持可重入的读写锁。</p>
<p>可以通过构造函数设置为公平锁，默认是非公平锁。</p>
<p>ReadWriteLock不支持锁升级：不释放读锁的前提下，无法再获取写锁。</p>
<p>ReadWriteLock支持锁降级：不释放写锁的前提下，可以再次获取读锁。</p>
<blockquote>
<p>常用写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K, V&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">	<span class="comment">// 读锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">	<span class="comment">// 写锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果缓存不存在，就加载数据到缓存中</span></span><br><span class="line">	<span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">		<span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 加读锁</span></span><br><span class="line">         readLock.lock();</span><br><span class="line">         value = cache.get(key);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         readLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 加写锁</span></span><br><span class="line">         writeLock.lock();</span><br><span class="line">         <span class="comment">// 查询数据库</span></span><br><span class="line">         value = fromDB(key);</span><br><span class="line">         cache.put(key, value);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         writeLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐StampedLock"><a href="#⭐StampedLock" class="headerlink" title="⭐StampedLock"></a>⭐<b id='StampedLock'>StampedLock</b></h3><p>StampedLock是JDK1.8提供的，它的性能比ReadWriteLock（读写锁）更好。但是StampedLock不支持重入。</p>
<p>StampedLock支持三种锁模式：<strong>写锁</strong>、<strong>悲观读锁</strong>、<strong>乐观读</strong>。</p>
<ul>
<li>它允许多个线程同时获取悲观读锁，只允许一个线程获取写锁，写锁和悲观读锁是互斥的。</li>
<li>当多个线程同时进行乐观读时，是允许一个线程获取写锁的，并不是所有的写操作都会阻塞。</li>
</ul>
<p>StampedLock之所以比ReadWriteLock性能好，就是因为StampedLock支持乐观读，乐观读不会加锁的，所以性能上会好很多。</p>
<p>StampedLock进行写锁、读锁、乐观读的时候，都会返回一个long类型的stamp，解锁时需要传入stamp。</p>
<p>需要注意的是，StampedLock是是支持锁升级和降级的，可以通过tryConvertToReadLock()和tryConvertToWriteLock()方法，但是这两个会返回新的stamp，在解锁时一定要使用这个新的stamp。</p>
<blockquote>
<p>读模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="comment">// 乐观读</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 判断乐观读期间是否发生写操作，如果有则返回则返回false</span></span><br><span class="line"><span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">	<span class="comment">// 如果发生了写操作，则升级为悲观读锁</span></span><br><span class="line">	stamp = sl.readLock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 开始读操作....</span></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// 释放悲观读锁</span></span><br><span class="line">     sl.unlockRead(stamp);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="comment">// 加写锁</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 进行写操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// 释放写锁</span></span><br><span class="line">	sl.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐Condition"><a href="#⭐Condition" class="headerlink" title="⭐Condition"></a>⭐<b id='Condition'>Condition</b></h3><p>Condition是条件变量，可以用来做异步转同步。</p>
<p>Condition中主要有三个方法：<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>，对应的是Object类的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>。</p>
<ul>
<li><code>await()</code>：进入等待状态并释放锁。</li>
<li><code>signal()</code>：唤醒一个等待线程。</li>
<li><code>signalAll()</code>：唤醒所有等待线程。</li>
</ul>
<p>比如需要等待某一个异步接口返回结果之后才能执行后续的逻辑，就可以在调用接口之前执行<code>await()</code>方法阻塞当前线程，获取到返回值之后执行<code>signal()</code>方法唤醒当前线程。</p>
<blockquote>
<p>异步转同步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">	<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 等待结果返回</span></span><br><span class="line">			condition.await(timeout);</span><br><span class="line">			<span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">			<span class="keyword">if</span> (response != <span class="literal">null</span> || cur - start &gt; timeout) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送异步请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		<span class="type">Response</span> <span class="variable">res</span> <span class="operator">=</span> sendRequest();</span><br><span class="line">     doReceived(res);</span><br><span class="line"> &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结果时调用该方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doRecived</span><span class="params">(Response res)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     response = res;</span><br><span class="line">     <span class="comment">// 获取到返回值后，唤醒线程</span></span><br><span class="line">     condition.signal();</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐Semaphore"><a href="#⭐Semaphore" class="headerlink" title="⭐Semaphore"></a>⭐<b id='Semaphore'>Semaphore</b></h3><p>Semaphore可以让多个线程同时访问某一个资源，可以用来实现简单的限流器。</p>
<ul>
<li><code>acquire()</code>：Semaphore中的计数器+1，当计数器达到阈值，会阻塞当前线程，直到计数器减少。</li>
<li><code>release()</code>：Semaphore计数器-1。</li>
</ul>
<p>使用Semaphore时需要注意线程安全问题，因为Semaphore可以让多个线程进入临界区。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="comment">// 初始化信号量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			semaphore.acquire();</span><br><span class="line">			value++;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			semaphore.release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐CountDownLatch"><a href="#⭐CountDownLatch" class="headerlink" title="⭐CountDownLatch"></a>⭐<b id='CountDownLatch'>CountDownLatch</b></h3><p>CountDownLatch是一个线程同步工具，可以让父线程等待子线程执行的执行结果。</p>
<p>CountDownLatch可以理解为是一个计数器，在初始化时可以指定计数器的值，通常是子线程或者任务的数量，让主线程调用await()方法进入等待状态，子线程执行完毕就调用countDown()方法让计数器减一，当计数器为0时CountDownLatch会唤醒主线程。</p>
<p>CountDownLatch的计数器是不能循环利用的，计数器的值一旦减到0，再次调用await()方法会直接通过。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"><span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">	p = getP();</span><br><span class="line">	latch.countDown();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">	d = getD();</span><br><span class="line">	latch.countDown();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">latch.await();</span><br><span class="line"><span class="type">Diff</span> <span class="variable">diff</span> <span class="operator">=</span> check(p, d);</span><br><span class="line">save(diff);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐CyclicBarrier"><a href="#⭐CyclicBarrier" class="headerlink" title="⭐CyclicBarrier"></a>⭐<b id='CyclicBarrier'>CyclicBarrier</b></h3><p>CyclicBarrier是一个线程同步工具，可以让一组线程之间相互等待。</p>
<p>在初始化时可以指定计数器的值，子线程执行完之后调用await()方法，进入等待状态并让计数器减一。计数器为0时会重置计数器的值，并让最后一个调用await()方法的线程触发回调函数。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;P&gt; pos;</span><br><span class="line">Vector&lt;D&gt; dos;</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, () -&gt; &#123;</span><br><span class="line"> <span class="comment">// 将回调函数提交到线程池中执行</span></span><br><span class="line">	executor.execute(() -&gt; check())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> pos.remove(<span class="number">0</span>);</span><br><span class="line">	<span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> dos.remove(<span class="number">0</span>);</span><br><span class="line">	<span class="type">Diff</span> <span class="variable">diff</span> <span class="operator">=</span> check(p,d);</span><br><span class="line">	save(diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAll</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">while</span> (存在未对账的数据)  &#123;</span><br><span class="line">      	<span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> getP();</span><br><span class="line">	        pos.add(p);</span><br><span class="line"> 	    cyclicBarrier.await();</span><br><span class="line">  	&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">while</span> (存在未对账的数据)  &#123;</span><br><span class="line">     	<span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> getD();</span><br><span class="line">	        dos.add(d);</span><br><span class="line"> 	    cyclicBarrier.await();</span><br><span class="line">  	&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐FutureTask"><a href="#⭐FutureTask" class="headerlink" title="⭐FutureTask"></a>⭐<b id='FutureTask'>FutureTask</b></h3><p><strong>FutureTask实现了Runnable接口和Future接口，所以可以把FutureTask作为任务提交给线程池去执行，也可以用来获取任务的执行结果</strong>。</p>
<p>它有两个构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个构造函数的参数是Callable接口，Callable接口中的call()方法是有返回值的，调用FutureTask的get()方法得到的就是call()方法的返回值。</li>
<li>第二个构造函数的参数是Runnable接口和结果引用，调用FutureTask的get()方法得到的就是结果引用。</li>
</ul>
<h3 id="⭐CompletableFuture"><a href="#⭐CompletableFuture" class="headerlink" title="⭐CompletableFuture"></a>⭐<b id='CompletableFuture'>CompletableFuture</b></h3><p>CompletableFuture继承了Future接口和CompletionStage接口。</p>
<p>跟传统的Future相比，CompletableFuture可以更方便的处理任务之间的关联关系。</p>
<p>默认情况下CompletableFuture会使用公共的<a href="#ForkJoinPool">ForkJoinPool</a>线程池，这个线程池默认的线程数是CPU的核心数。</p>
<blockquote>
<p>在开发时尽量使用自定义的线程池，因为如果所有的CompletableFuture都使用同一个线程池，如果有一些任务执行了一些很慢的I/O操作，就会导致线程池中所有的任务都阻塞，会影响整个系统的性能，所以尽量根据不同的业务类型创建不同的线程池。</p>
</blockquote>
<p>主要方法：</p>
<ol>
<li><p>描述串行关系：</p>
<ul>
<li><p><code>thenApply(function)</code>：把前一个任务的执行结果，交给后面的<code>Function</code>处理（有返回值）。</p>
</li>
<li><p><code>thenAccept(consumer)</code>：把前一个任务的执行结果，交给后面的<code>Consume</code>处理（没有返回值）。</p>
</li>
<li><p><code>thenRun(runnable)</code>：忽略前一个任务的结果，执行额外的逻辑（没有返回值）。</p>
</li>
<li><p><code>thenCompose(function)</code>：会把前一个<code>CompletableFuture</code>的结果传递给内部的<code>CompletableFuture</code>，最后返回一个新的<code>CompletableFuture</code>对象。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture</span><br><span class="line"> .supplyAsync(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Integer&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">30</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;第一次运算：&quot;</span> + number);</span><br><span class="line">         <span class="keyword">return</span> number;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).thenCompose(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, CompletionStage&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> CompletionStage&lt;Integer&gt; <span class="title function_">apply</span><span class="params">(Integer param)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> CompletableFuture.supplyAsync(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Integer&gt;() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                 <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> param * <span class="number">2</span>;</span><br><span class="line">                 System.out.println(<span class="string">&quot;第二次运算：&quot;</span> + number);</span><br><span class="line">                 <span class="keyword">return</span> number;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>描述AND聚合关系：</p>
<ul>
<li><code>thenCombine(other, function)</code>：两个任务都要有返回值，可以对两个任务的结果做一些额外的处理（有返回值）。</li>
<li><code>thenAcceptBoth(other, consumer)</code>：两个任务都要有返回值，可以对两个任务的结果做一些额外的处理（没有返回值）。</li>
<li><code>runAfterBoth(other, runnable)</code>：不需要前面的任务有返回值，可以执行一些额外的逻辑（没有返回值）。</li>
</ul>
</li>
<li><p>描述OR聚合关系：</p>
<ul>
<li><code>applyToEither(other, function)</code>：两个任务都要有返回值，任意一个任务先结束，就会执行（有返回值）。</li>
<li><code>acceptEither(other, consumer)</code>：两个任务都要有返回值，任意一个任务先结束，就会执行（没有返回值）。</li>
<li><code>runAfterEither(other, runnable)</code>：不需要前面的任务有返回值，任意一个任务先结束，就会执行（没有返回值）。</li>
</ul>
</li>
<li><p>异常处理：</p>
<ul>
<li><code>exceptionally(function)</code>：前面的任务报错时就会执行，类似于catch{}代码块。</li>
<li><code>whenComplete(consumer)</code>：无论是否发生异常都会执行，相当于finally{}代码块，可以配合<code>exceptionally</code>使用（没有返回值）。</li>
<li><code>handle(function)</code>：无论是否发生异常都会执行，相当于finally{}代码块（有返回值）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>方法名带有Async表示会异步执行function、consumer或者runnable。</p>
</blockquote>
<p>CompletableFuture提供4个静态方法来创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认线程池</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplyer&lt;U&gt; supplyer)</span>;</span><br><span class="line"><span class="comment">// 指定线程池</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,Executor executor)</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplyer&lt;U&gt; supplyer, Executor executor)</span>;</span><br></pre></td></tr></table></figure>

<p>runAsync()方法接收的是Runnable接口，所以它是没有返回值的。</p>
<p>supplyAsync()方法接收的是Supplyer函数式接口，Supplyer的get()方法是有返回值的。</p>
<blockquote>
<p>用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; f1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;T1:洗⽔壶...&quot;</span>);</span><br><span class="line">	sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;T1:烧开⽔...&quot;</span>);</span><br><span class="line">	sleep(<span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;T2:洗茶壶...&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"> System.out.println(<span class="string">&quot;T2:洗茶杯...&quot;</span>);</span><br><span class="line"> sleep(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"> System.out.println(<span class="string">&quot;T2:拿茶叶...&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;⻰井&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; f3 = f1.thenCombine(f2, (_, tf) -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;T1:拿到茶叶:&quot;</span> + tf);</span><br><span class="line"> System.out.println(<span class="string">&quot;T1:泡茶...&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span>	<span class="string">&quot;上茶:&quot;</span>	+	tf;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待任务3执⾏结果</span></span><br><span class="line">System.out.println(f3.join());</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐CompletionService"><a href="#⭐CompletionService" class="headerlink" title="⭐CompletionService"></a>⭐<b id='CompletionService'>CompletionService</b></h3><p>有些时候我们会执行多个异步任务，并且需要获取返回值，比较简单的做法是调用线程池的submit()方法，获取Future对象，再调用Future对象的get()方法获取返回值。但是调用Future对象的get()方法会导致当前线程阻塞，直到任务执行完毕。</p>
<p>如果任务1的执行时间比任务2的执行时间长，如果先调用任务1的Future对象的get()方法，就会导致任务2即使执行完毕后也不能及时处理，需要等任务1执行完毕后才能处理，CompletionService就可以解决这样的问题。</p>
<p>CompletionService内部维护了一个阻塞队列，当任务执行结束后，就把Future对象加入到队列中。队列是先进先出的，这样先执行完的任务就可以先加入到队列中，就可以先进行处理。</p>
<p>CompletionService是一个接口，实现类是ExecutorCompletionService，这个实现类的构造方法有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ExecutorCompletionService</span><span class="params">(Executor executor)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ExecutorCompletionService</span><span class="params">(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>创建ExecutorCompletionService需要传入一个线程池和BlockingQueue，如果不指定BlockingQueue默认使用的是无界的LinkedBlockingQueue。</p>
<p>主要方法：</p>
<ul>
<li><code>Future&lt;V&gt; submit(Callable&lt;V&gt; task)</code>：</li>
<li><code>Future&lt;V&gt; submit(Runnable task, V result)</code>：执行</li>
<li><code>Future&lt;V&gt; take()</code>：从队列中获取并移除一个元素，就阻塞当前线程，直到有元素返回。</li>
<li><code>Future&lt;V&gt; pool()</code>：从队列中获取并移除一个元素，如果队列是空的，会返回null。</li>
<li><code>Future&lt;V&gt; pool(timeout, unit)</code>：从队列中获取并移除一个元素，如果队列是空的，会等待一定的时间，超时后返回null。</li>
</ul>
<blockquote>
<p>用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建CompletionService</span></span><br><span class="line">CompletionService&lt;Integer&gt; cs = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor);</span><br><span class="line"><span class="comment">// 异步向电商S1询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS1());</span><br><span class="line"><span class="comment">// 异步向电商S2询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS2());</span><br><span class="line"><span class="comment">// 异步向电商S3询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS3());</span><br><span class="line"><span class="comment">// 将询价结果异步保存到数据库</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">r</span> <span class="operator">=</span> cs.take().get();</span><br><span class="line">	executor.execute( () -&gt; save(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐Fork-Join"><a href="#⭐Fork-Join" class="headerlink" title="⭐Fork/Join"></a>⭐<b id='Fork/Join'>Fork/Join</b></h3><p>Fork/Join是一种分治任务模型，主要分为两个阶段：</p>
<ul>
<li>一个阶段是<strong>任务分解</strong>，把一个大任务分解成多个小任务。</li>
<li>另一个阶段是<strong>结果合并</strong>，合并所有小任务的执行结果，得到最终的结果。</li>
</ul>
<p>Java提供了ForkJoinPool和ForkJoinTask两个类来支持分治任务模型。这两个类的关系类似于线程池和线程的关系。</p>
<h4 id="⭐ForkJoinPool"><a href="#⭐ForkJoinPool" class="headerlink" title="⭐ForkJoinPool"></a>⭐<b id='ForkJoinPool'>ForkJoinPool</b></h4><p>ForkJoinPool是内部有多个任务队列，当我们通过<code>invoke()</code>或者<code>submit()</code>方法提交任务时，ForkJoinPool会把任务提交到一个任务队列中。如果任务在执行过程中还会创建子线程，那么子线程会被提交到父线程所在的任务队列中。</p>
<p>如果某一个队列空了，还会从其它队列中 “窃取” 任务。</p>
<p>任务队列采用的是双端队列，正常执行任务和 “窃取任务” 会从不同的端口消费。</p>
<h4 id="⭐ForkJoinTask"><a href="#⭐ForkJoinTask" class="headerlink" title="⭐ForkJoinTask"></a>⭐<b id='ForkJoinTask'>ForkJoinTask</b></h4><p>ForkJoinTask是一个抽象类，最核心的方法是<code>fork()</code>和<code>join()</code>，其中<code>fork()</code>方法会异步执行一个子任务（执行<code>compute()</code>方法），<code>join()</code>方法会阻塞当前线程等待子任务的执行结果。</p>
<p>ForkJoinTask有两个子类，RecursiveAction和RecursiveTask，它们都是用递归的方式来处理分治任务的。这两个子类也是抽象类，内部定义了<code>compute()</code>抽象方法，需要自己定义子类去拓展。</p>
<blockquote>
<p>RecursiveAction没有返回值。</p>
<p>RecursiveTask有返回值。</p>
<p>调用<code>fork()</code>方法时，会调用我们实现的<code>compute()</code>方法。</p>
</blockquote>
<blockquote>
<p>单词统计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	String[] words = &#123;<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello me&quot;</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">	<span class="comment">// 创建ForkJoinPool</span></span><br><span class="line">	<span class="type">ForkJoinPool</span> <span class="variable">taskPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">10</span>);</span><br><span class="line"> Map&lt;String, Integer&gt; result = taskPool.invoke(<span class="keyword">new</span> <span class="title class_">WordCount</span>(words, <span class="number">0</span>, words.length));</span><br><span class="line"> System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCount</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Map&lt;String, Integer&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String[] words;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> start, end;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">WordCount</span><span class="params">(String[] words, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.words = words;</span><br><span class="line">     <span class="built_in">this</span>.start = start;</span><br><span class="line">     <span class="built_in">this</span>.end = end;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> Map&lt;String, Integer&gt; <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> count(words[start]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">     <span class="type">WordCount</span> <span class="variable">wc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WordCount</span>(words, start, mid);</span><br><span class="line">     wc1.fork();</span><br><span class="line">     <span class="type">WordCount</span> <span class="variable">wc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WordCount</span>(words, mid, end);</span><br><span class="line">     <span class="keyword">return</span> merge(wc1.join(), wc2.compute());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, Integer&gt; <span class="title function_">merge</span><span class="params">(Map&lt;String, Integer&gt; r1, Map&lt;String, Integer&gt; r2)</span> &#123;</span><br><span class="line">     r1.forEach((key, value) -&gt; &#123;</span><br><span class="line">         r2.merge(key, value, Integer::sum);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">return</span> r2;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, Integer&gt; <span class="title function_">count</span><span class="params">(String line)</span> &#123;</span><br><span class="line">     String[] words = line.split(<span class="string">&quot;\\s&quot;</span>);</span><br><span class="line">     Map&lt;String, Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">         result.merge(word, <span class="number">1</span>, Integer::sum);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Rainy 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Rainy 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/08/Java%E9%9B%86%E5%90%88/" rel="prev" title="Java集合">
      <i class="fa fa-chevron-left"></i> Java集合
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/12/08/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" rel="next" title="性能调优">
      性能调优 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.</span> <span class="nav-text">产生并发安全问题的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.</span> <span class="nav-text">⭐线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">⭐核心参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.</span> <span class="nav-text">⭐线程池大小如何定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">2.3.</span> <span class="nav-text">⭐如何获取执行结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">阻塞线程的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90%E9%94%81%E5%AE%9A%E4%B9%89"><span class="nav-number">6.</span> <span class="nav-text">⭐锁定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">6.1.</span> <span class="nav-text">⭐乐观锁 &#x2F; 悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">6.2.</span> <span class="nav-text">⭐偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">6.3.</span> <span class="nav-text">⭐轻量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">6.4.</span> <span class="nav-text">⭐重量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E8%87%AA%E6%97%8B%E9%94%81-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">6.5.</span> <span class="nav-text">⭐自旋锁 &#x2F; 适应性自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">6.6.</span> <span class="nav-text">⭐可重入锁 &#x2F; 不可重入锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">6.7.</span> <span class="nav-text">⭐公平锁 &#x2F; 非公平锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%E7%8B%AC%E5%8D%A0%E9%94%81-%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">6.8.</span> <span class="nav-text">⭐独占锁 &#x2F; 共享锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90CAS"><span class="nav-number">7.</span> <span class="nav-text">⭐CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90JUC%E5%B8%B8%E7%94%A8%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">⭐JUC常用原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90AQS"><span class="nav-number">9.</span> <span class="nav-text">⭐AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90ThreadLocal"><span class="nav-number">10.</span> <span class="nav-text">⭐ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">10.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">10.2.</span> <span class="nav-text">内存泄漏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90ReentrantLock"><span class="nav-number">11.</span> <span class="nav-text">⭐ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90ReentrantReadWriteLock"><span class="nav-number">12.</span> <span class="nav-text">⭐ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90StampedLock"><span class="nav-number">13.</span> <span class="nav-text">⭐StampedLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90Condition"><span class="nav-number">14.</span> <span class="nav-text">⭐Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90Semaphore"><span class="nav-number">15.</span> <span class="nav-text">⭐Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90CountDownLatch"><span class="nav-number">16.</span> <span class="nav-text">⭐CountDownLatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90CyclicBarrier"><span class="nav-number">17.</span> <span class="nav-text">⭐CyclicBarrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90FutureTask"><span class="nav-number">18.</span> <span class="nav-text">⭐FutureTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90CompletableFuture"><span class="nav-number">19.</span> <span class="nav-text">⭐CompletableFuture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90CompletionService"><span class="nav-number">20.</span> <span class="nav-text">⭐CompletionService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%AD%90Fork-Join"><span class="nav-number">21.</span> <span class="nav-text">⭐Fork&#x2F;Join</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90ForkJoinPool"><span class="nav-number">21.1.</span> <span class="nav-text">⭐ForkJoinPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90ForkJoinTask"><span class="nav-number">21.2.</span> <span class="nav-text">⭐ForkJoinTask</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rainy"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Rainy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/rainy-zhang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rainy-zhang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rainy_zhang@foxmail.com" title="E-Mail → mailto:rainy_zhang@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rainy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'edb1b2802d6853e3cc24',
      clientSecret: '77dfb2ff88a1839ad1f7d904cb216b5e8b1cbaf1',
      repo        : 'rainy-zhang.github.io',
      owner       : 'rainy-zhang',
      admin       : ['rainy-zhang'],
      id          : '97e9e3fb6509b09b5bda5b851f8e3426',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
