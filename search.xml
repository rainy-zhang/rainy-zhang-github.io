<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java集合</title>
    <url>/2022/12/08/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="⭐ArrayList"><a href="#⭐ArrayList" class="headerlink" title="⭐ArrayList"></a>⭐ArrayList</h3><p>ArrayList底层是用数组实现的，数组长度可以在构造函数中指定，默认是0。</p>
<ul>
<li><p>调用<code>add()</code>方法时，如果长度不够，会触发扩容。所以在初始化时指定数量可以减少扩容次数。</p>
<blockquote>
<p>调用指定下标的<code>add(int index, E element)</code>方法时，也会拷贝数组。</p>
<p>比如要在下标为5的位置插入一个元素，就会从下标为5这个位置到数组末尾复制出一个的数组，然后把新的数组放在5+1这个位置上，最后在5这个位置插入数据。</p>
</blockquote>
</li>
<li><p>调用<code>remove()</code>方法时，会拷贝出一个新数组。</p>
<blockquote>
<p>比如要删除下标为5的元素，就会从5+1这个位置到数组末尾复制出一个新数组，然后放到下标为5这个位置。</p>
</blockquote>
</li>
</ul>
<p><strong>更适合读多写少的场景</strong>。</p>
<p><strong>扩容</strong>：初始化时如果没有指定数组长度，第一次会扩容为10。否则扩容为原来的1.5倍。</p>
<h3 id="⭐LinkedList"><a href="#⭐LinkedList" class="headerlink" title="⭐LinkedList"></a>⭐LinkedList</h3><p>LinkedList底层使用双向链表。</p>
<p>LinkedList插入操作的时间复杂度是O(1)的前提是：已经有了那个要插入节点的指针，但是在实现的时候，LinkedList需要先通过循环获取到那个节点的Node，然后再执行插入操作。所以LinkedList插入数据的效率也不一定比ArrayList高。</p>
<h3 id="⭐HashMap"><a href="#⭐HashMap" class="headerlink" title="⭐HashMap"></a>⭐HashMap</h3><p><strong>HashMap底层采用数组+链表组成</strong>。</p>
<ul>
<li>调用<code>put()</code>方法时，会根据key的哈希值，计算出要添加的数组下标，如果目标位置不为空，就会创建一个链表保存出现Hash冲突的数据。</li>
<li>调用<code>get()</code>方法时，根据key的哈希值，计算出目标数据的下表，如果目标位置是一个链表，则通过<code>equals()</code>方法与链表中的每个元素作比较。</li>
</ul>
<p>数组的长度默认是16，插入的数据越多，就会导致Hash冲突越多，链表就越长，进而影响查询数据的效率，所以当链表长度达到8时会转换为红黑树，当删除数据后长度小于6时重新变为链表。</p>
<p>并且当数组中元素数量大于数组长度 * 0.75时，就会进行扩容，扩容分为两步：</p>
<ol>
<li><p>创建一个空数组，长度是原来的2倍。</p>
</li>
<li><p>再遍历原来数组中的元素，重新经过Hash运算后保存到新数组中。</p>
<blockquote>
<p>因为数组长度变了，Hash规则也会变。（index = key.hashCode() &amp; array.length - 1）</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>线程A、B同时插入数据，线程A通过key的哈希值计算出数组的下标，并且目标位置为空，然后线程A挂起。</p>
<p>线程B成功插入数据。</p>
<p>线程A再次执行的时候会直接覆盖掉线程B写的数据。</p>
</blockquote>
<h3 id="⭐ConcurrentHashMap"><a href="#⭐ConcurrentHashMap" class="headerlink" title="⭐ConcurrentHashMap"></a>⭐ConcurrentHashMap</h3><p>ConcurrentHashMap底层是数组+链表组成的，不过在jdk 1.7和jdk 1.8中实现方式稍有不同：</p>
<p>在jdk 1.7中，是基于分段锁实现的，ConcurrentHashMap会把内部的数据拆分成一个个Segment，Segment继承自<a href="#ReentrantLock">ReentrantLock</a>，并且内部维护了一个HashEntry数组，HashEntry是key-value结构的对象，内部使用<a href="#volatile">volatile</a>关键字来保证可见性。</p>
<ul>
<li><p>调用<code>put()</code>方法时，通过key的哈希值得到该元素要添加到的Segment，然后对Segment进行加锁，不会影响到其它Segment。</p>
<blockquote>
<p>默认情况下，Segment的数量是16个，也就是说最多可以支持16个线程同时读写。</p>
</blockquote>
</li>
<li><p>调用<code>get()</code>方法时，只需要根据key的哈希值就可以定位到Segment，再通过key的哈希值就可以定位到具体的元素。</p>
<blockquote>
<p>第一次通过key的哈希值与Segment数组长度计算出key所在的Segment，第二次通过key的哈希值与HashEntry数组长度定位到具体的元素。</p>
</blockquote>
</li>
</ul>
<p>ConcurrentHashMap是通过链表解决Hash冲突的，会导致查询效率降低。</p>
<p>在jdk 1.8中，抛弃了分段锁，采用了<a href="#CAS">CAS</a> + <a href="#synchronized">synchronized</a>来保证并发安全性，并且在解决Hash冲突时引入了红黑树，当链表长度大于8时会转为红黑树。</p>
<ul>
<li>调用<code>put()</code>方法时，根据key的哈希值定位到要添加的位置，如果不为空就用<a href="#synchronized">synchronized</a>对当前Node加锁并写入数据。如果目标位置为空就通过<a href="#CAS">CAS</a>写入，如果<a href="#CAS">CAS</a>写入失败则重新判断位置是否为空，直到成功将数据写入。</li>
<li>调用<code>get()</code>方法时，根据key的哈希值定位到具体的数据。</li>
</ul>
<p><strong>抛弃分段锁的原因</strong>：</p>
<ol>
<li>分段锁会浪费更多的内存空间。</li>
<li>jdk8只会对Node加锁，降低了锁粒度。</li>
</ol>
<h3 id="⭐HashSet"><a href="#⭐HashSet" class="headerlink" title="⭐HashSet"></a>⭐HashSet</h3><p>HashSet内部维护了一个HashMap，所有元素都存到map中的key上，所以HashSet天然就是不可重复的。</p>
<blockquote>
<p>map中的value是一个统一的值，是用static final修饰的Object对象</p>
</blockquote>
<ul>
<li>调用<code>add()</code>方法时，底层调用的是HashMap的<code>put()</code>方法。</li>
</ul>
<p>HashSet没有提供<code>get()</code>方法，获取数据时需要通过迭代器遍历集合。</p>
<h3 id="CopyOnWrite模式"><a href="#CopyOnWrite模式" class="headerlink" title="CopyOnWrite模式"></a>CopyOnWrite模式</h3><p>CopyOnWrite模式就是在执行写操作的时候，会把数据复制出来一份，这样做的好处是读数据不需要加锁。</p>
<p>CopyOnWrite模式内部维护了一个数组，所有的读操作都是在这个数组上进行的。如果在遍历的过程中，其它线程执行写操作，会复制出一个新的数组，然后在新的数组上执行写操作，最后再把原来的数组替换掉。</p>
<p><strong>只适合读多写少的场景</strong>。</p>
<p>常用的实现类有：CopyOnWriteArrayList、CopyOnWriteArraySet。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ</title>
    <url>/2022/12/08/RocketMQ/</url>
    <content><![CDATA[<h2 id="⭐应用场景"><a href="#⭐应用场景" class="headerlink" title="⭐应用场景"></a>⭐应用场景</h2><p><strong>异步处理</strong>：</p>
<p>比如某些业务请求需要3个步骤才能完成，如果前2个步骤完成之后，就已经可以保证业务可以正常完成，就可以直接返回给客户端响应结果，然后把第三个步骤通过消息队列发送给消费者，由消费者来完成后续的流程。这样就可以提高服务的响应速度。</p>
<p>比如我们系统中的某些发行业务都是需要<strong>请求</strong>和<strong>确认</strong>2个步骤才能完成，如果每一个请求都需要把这2个步骤执行完才给用户响应结果的话，就会导致处理请求的时间变长。如果想要提高程序处理请求的速度，就可以在完成第1个步骤之后，直接给用户返回结果，然后把确认消息放到消息队列中，由消费者完成后续的步骤。</p>
<p><strong>流量控制</strong>：</p>
<p>通过消息队列把前端和后端隔离起来，后端按照自己的处理能力从消息队列中处理请求。</p>
<p>这样就可以避免大量的请求直接冲击到后端，可以减少后端服务的压力。</p>
<p>这种方案的缺点是，消息队列会导致总体的响应时间变长，增加系统的复杂度。</p>
<p><strong>服务解耦</strong>：</p>
<p>在微服务架构中，有些下游服务需要获取上游服务的数据，但是下游服务是会增加或者减少的的，如果每次增减下游服务，都需要调整上游服务的接口，这样服务之间的耦合度就太高了。</p>
<p>可以通过消息队列让服务之间解耦，上游服务可以把数据发送到消息队列中，下游服务只需要订阅这个消息队列就可以实时获得数据。无论增加还是减少下游服务，上游服务都不需要修改。</p>
<h2 id="如何选择消息队列"><a href="#如何选择消息队列" class="headerlink" title="如何选择消息队列"></a>如何选择消息队列</h2><p>RocketMQ 对响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，<strong>对于响应时延有要求的业务场景，那应该选择使用 RocketMQ</strong>。</p>
<p>Kafka在设计上采用的是批量和异步的思想，这种设计让Kafka能做到超高的性能。但是带来的问题是，它同步收发消息的响应时延比较高，因为当生产者发送一条消息的时候，Kafka 并不会立即发送出去，而是要等一会儿攒一批再发送。所以，<strong>Kafka更适合离线类的场景</strong>。</p>
<p>也可以通过<code>linger_ms_config</code>和<code>batch_size_config</code>这两个参数控制发送消息的时机。</p>
<blockquote>
<p><code>batch.size</code>：用来控制单次提交的字节数大小，默认是16k。当缓冲区中的数据达到16k时，就会触发一次提交。</p>
<p><code>linger_ms</code>：用来控制两次提交的时间间隔，如果两次提交的时间间隔达到了这个阈值，不管batch有没有满，都会发送出去。</p>
</blockquote>
<h3 id="⭐消息模型"><a href="#⭐消息模型" class="headerlink" title="⭐消息模型"></a>⭐消息模型</h3><p>RocketMQ使用的消息模型是发布-订阅模型。</p>
<p><strong>可靠性</strong>：</p>
<p>RocketMQ是通过<strong>请求-确认</strong>机制，来保证消息传递的可靠性。</p>
<p>具体的逻辑是这样的：</p>
<ul>
<li><p>生产者先将消息发送给Broker，Broker收到消息会把消息写进主题和队列中，然后给生产者发送确认的响应。如果生产者没有收到服务端的确认或者收到了失败的响应，就表示消息发送失败。</p>
</li>
<li><p>消费者在收到消息并完成自己的消费业务逻辑后，也会给服务端发送确认消息，服务端只有收到消费者的确认后，才认为一条消息被消费成功。否则消费者下次拉取的数据还是同一条消息。</p>
</li>
</ul>
<p><strong>有序性</strong>：</p>
<p>RocketMQ只在队列层面保证有序性，主题层面是无法保证有序性的，在同一个队列中，必须要等前一条消息被成功消费，才能继续消费下一条消息。</p>
<p>也就是说同一个队列，同一时刻最多只能有一个消费者进行消费，所以如果消费者的节点数量大于队列的数量，多出来的消费者是没有意义的。</p>
<p>在RocketMQ中每个消费者组都会消费主题中一份完整的消息，不同消费组之间互不影响，也就是说一条消息被消费组A消费过，还会再给消费组B消费。同一个组内的消费者是竞争关系，如果一条消息被一个消费者消费了，组内其他消费者就不会再收到这条消息了。</p>
<p>消息需要被不同的组进行多次消费，所以消息被消费后不会被删除。RocketMQ会为每个消费者组维护一个offset，每成功消费一条消息，就把对应的offset就+1。</p>
<h3 id="⭐RocketMQ分布式事务"><a href="#⭐RocketMQ分布式事务" class="headerlink" title="⭐RocketMQ分布式事务"></a>⭐RocketMQ分布式事务</h3><p>逻辑是这样的：</p>
<ol>
<li>首先在消息队列上开启一个事务，然后给消息队列发送一个“事务消息”，这个事务消息在事务提交之前，对消费者是不可见的。</li>
<li>事务消息发送成功之后，就可以开始执行本地事务了。</li>
<li>然后根据本地事务的执行结果决定是提交事务或者回滚事务，这样就基本实现了 “要么都成功，要么都失败”的一致性要求。</li>
</ol>
<p>但是还有一个问题是提交事务的消息有可能发送失败，所以<strong>RocketMQ增加了事务反查的机制来解决事务消息提交失败的问题。具体来说就是，如果Producer在提交或者回滚事务消息的时候发生了异常，Broker没有收到事务消息，这时候Broker就会定期去Producer上面反查这个事务对应的本地事务的状态，然后根据反查结果来决定提交或者回滚事务</strong>。</p>
<p><strong>为了支持事务反查机制，还需要实现一个反查本地事务状态的接口，告知RocketMQ本地事务是否成功</strong>。</p>
<p>比如根据消息中的主键ID，在数据库中查询这条记录是否存在，如果存在就返回成功，否则返回失败。RocketMQ会根据事务反查的结果来提交或者回滚事务。</p>
<p>这个反查本地事务的实现，并不依赖消息的发送方，就算发送事务消息的那个服务宕机了，RocketMQ也可以通过其他实例节点来执行反查，确保事务的完整性。</p>
<h3 id="⭐事务实现原理"><a href="#⭐事务实现原理" class="headerlink" title="⭐事务实现原理"></a>⭐事务实现原理</h3><p>RocketMQ的事务是基于<strong>两阶段提交</strong>来实现的。</p>
<ol>
<li><p>首先在Producer端，首先要重写TransactionListener中的两个方法：<code>executeLocalTransaction()</code>和<code>checkLocalTransaction()</code>。</p>
<blockquote>
<ul>
<li>**excuteLocalTransaction()**：是用来执行本地事务的，比如可以把数据插入到数据库中，并返回执行结果。</li>
<li>**checkLocalTransaction()**：是用来做事务反查的，比如可以判断数据库中是否存在刚刚插入的数据，如果存在就提交，如果不存在，就可能是本地事务执行失败了，就回滚。</li>
</ul>
</blockquote>
</li>
<li><p>然后，在发送消息的时候，先给待发送的消息添加一个属性<code>PROPERTY_TRANSACTION_PREPARED</code>，用来声明这是一个事务消息，然后把这条消息发送给Broker。</p>
</li>
<li><p>如果发送成功了，就会开始调用TransactionListener的实现类，然后执行<code>executeLocalTransaction()</code>这个方法来跑本地事务。</p>
</li>
<li><p>最后根据事务消息发送的结果和本地事务的执行结果，来决定是提交或者回滚事务。</p>
</li>
<li><p>Broker收到消息的时候，会判断一下这条消息是普通消息还是事务消息。如果是普通消息，就直接把消息放到指定的队列里面。如果是事务消息，会先记录一下指定的主题和队列，然后把消息保存在一个特殊的内部主题。这个主题对消费者是不可见的，这样就保证了事务在提交之前，这个事务消息消费者是无法消费的。</p>
</li>
<li><p>RocketMQ还会启动一个定时器，定时从事务消息队列中读取所有长时间未提交的事务消息，然后调用事务反查接口，根据返回的结果，来决定这个事务消息是提交还是回滚。</p>
</li>
<li><p>如果需要提交事务，那就把事务消息从这个特殊队列里面移动到真正的主题和队列中去。如果是回滚事务，就直接结束删除这个事务消息。</p>
</li>
</ol>
<h2 id="⭐如何保证消息不丢失"><a href="#⭐如何保证消息不丢失" class="headerlink" title="⭐如何保证消息不丢失"></a>⭐如何保证消息不丢失</h2><p>判断是否有消息丢失，<strong>可以利用消息队列的有序性来验证是否有消息丢失</strong>，逻辑是这样的：</p>
<ol>
<li>在Producer端，给每个发出去的消息附加一个连续递增的序号。</li>
<li>然后在Consumer端来检查这个序号的连续性</li>
<li>如果没有消息丢失，那Consumer接收到的消息必然是连续递增的，如果检测到序号不连续，就说明丢消息了。还可以通过丢失的序号确定是哪条消息丢失了，方便排查原因。</li>
</ol>
<p><strong>大部分的消息队列一般都会有拦截器机制，可以利用拦截器，在Producer发送消息之前，在拦截器中将序号注入到消息里面</strong>。</p>
<p>但是像Kafka和RocketMQ这样的消息队列，它并不保证Topic层面的顺序，只能保证partition上的消息是有序的，所以在发送消息的时候需要指定分区，并且每个分区都要单独校验序号的连续性。</p>
<p>如果Producer是有多个实例的，也需要每个Producer分别生成各自的序号，并且还需要加上Producer的标识，在Consumer端按照每个Producer分别来检测序号的连续性。</p>
<p>一条消息的传递主要分三个阶段：<a href="#Producer%E9%98%B6%E6%AE%B5">Producer阶段</a>、<a href="#Broker%E9%98%B6%E6%AE%B5">Broker阶段</a>、<a href="#Consumer%E9%98%B6%E6%AE%B5">Consumer阶段</a>。</p>
<p><b id='Producer阶段'>Producer阶段</b>：</p>
<p>在Producer端，消息队列通过<strong>请求-确认</strong>机制，来保证消息的可靠传递。</p>
<p>具体来说就是，Producer向Broker发送一条消息时，Broker收到消息之后会给Producer返回一个确认响应，表示消息已经收到了。只要Producer收到了Broker的确认响应，就可以保证消息在Producer阶段不会丢失。</p>
<p>但是有些消息队列在长时间没收到确认响应，会自动重试，如果重试失败就会以返回值或者抛异常的方式告诉用户消息发送失败。<strong>所以在写代码的时候，需要注意处理下返回值或者捕获异常，就可以保证这个发送阶段消息不会丢失</strong>。</p>
<blockquote>
<p>以Kafka为例，同步发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">RecordMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> producer.send(record).get();</span><br><span class="line"> System.out.println(<span class="string">&quot; 消息发送成功。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot; 消息发送失败！&quot;</span>);</span><br><span class="line"> System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.send(record, (metadata, exception) -&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span> (metadata != <span class="literal">null</span>) &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot; 消息发送成功。&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot; 消息发送失败！&quot;</span>);</span><br><span class="line">     System.out.println(exception);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b id='Broker阶段'>Broker阶段</b>：</p>
<p>在Broker阶段，一般情况下，只要Broker正常运行，就不会出现丢消息的情况，但是如果Broker出现故障，比如进程死掉，或者服务器宕机，就可能会丢消息。</p>
<p><strong>如果对消息的可靠性要求非常高，可以通过配置Broker参数来避免因为宕机导致丢消息</strong>。</p>
<p>如果是单个节点的Broker，可以配置一下Broker的参数，<strong>比如RocketMQ可以把<code>flushDiskType</code>配置为SYNC_FLUSH同步刷盘</strong>。这样Broker在收到一条消息后，会先把消息写到磁盘后，再给Producer返回确认响应。这样就算发生了宕机，因为消息已经被写到了磁盘上，所以是不会丢消息的。</p>
<p>如果Broker是由多个节点组成的集群，需要把Broker配置成：至少把消息发送到2个以上的节点，然后再给Producer发送确认响应，这样当某个Broker宕机后，其他的Broker可以替代宕机的Broker，也不会丢消息。</p>
<p><b id='Consumer阶段'>Consumer阶段</b>：</p>
<p>Consumer阶段也是通过<strong>请求-确认</strong>机制来保证消息的可靠传递。</p>
<p>具体来说就是，Consumer从Broker拉取一条消息后，开始执行消费业务的逻辑，执行成功后，向Broker发送消费确认的响应，如果Broker没有收到消费确认的响应，下次拉取的消息还会是同一条，这样就可以保证消息不会在网络传输过程中丢失，也不会因为消费逻辑出错导致数据丢失。</p>
<p><strong>所以在写代码的时候需要注意，不要在收到消息后立刻就发送消费确认，而是应该在执行完消费业务的逻辑之后，再发送消费确认的响应</strong>。</p>
<p>比如应该先把消息保存到数据库之后，再发送消费确认的响应。这样就算保存消息失败了，因为没有执行消费确认的代码，下次拉取的还是这条消息。</p>
<h2 id="⭐如何处理重复消息"><a href="#⭐如何处理重复消息" class="headerlink" title="⭐如何处理重复消息"></a>⭐如何处理重复消息</h2><blockquote>
<p>在MQTT协议里面，有三种传递消息的标准：</p>
<ul>
<li><strong>At most once</strong>：在传递消息时<strong>，消息最多会被发送一次，换一个说法就是，没什么消息可靠性保证，允许丢消息</strong>，一般都是一些对消息可靠性要求不高，可以接收数据少量丢失的场景用。</li>
<li><strong>At least once</strong>：在传递消息时，<strong>消息最少会被发送一次，也就是说，不允许丢消息，但是允许有少量的重复消息出现。</strong></li>
<li><strong>Exactly once</strong>：在传递消息时，<strong>消息只会被发送一次，不允许丢失，也不允许重复</strong>，这个是最高的等级。</li>
</ul>
<p>这三种标准对所有的消息队列都是适用的，现在常用的大部分消息队列提供的标准都是<strong>At most once</strong>，比如RocketMQ、Kafka、RabbitMQ都是这样。也就是说这些消息队列都有重复消息的可能。</p>
</blockquote>
<p><strong>一般解决重复消息的办法是让消费消息的接口具备幂等性</strong>。</p>
<p>幂等常见的实现方式主要有2种方案：<a href="#%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%BA%93%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F%E5%AE%9E%E7%8E%B0%E5%B9%82%E7%AD%89">通过数据库唯一约束实现幂等</a>、<a href="#%E9%80%9A%E8%BF%87%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%B9%82%E7%AD%89">通过前置条件实现幂等</a>。</p>
<blockquote>
<p><strong>幂等(Idempotence)：</strong>一个幂等的方法，使用相同的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的，所以幂等的方法不用担心重复数据会对系统造成影响。</p>
<p>比如：一个方法可以把张三的账户余额设置为100元，执行一次对系统产生的影响是，把张三的账户余额设置成了100元，只要提供的参数100元不变，就算执行多少次，张三的账户余额始终都是100元，这就是一个幂等操作。</p>
</blockquote>
<p>⭐<b id='通过数据库唯一约束实现幂等'>通过数据库唯一约束实现幂等</b>：</p>
<p>可以在表中定义唯一约束来实现幂等，如果入库时发生了唯一键冲突，就表示这条记录已经消费过了，可以直接丢弃。</p>
<p>⭐<b id='通过前置条件实现幂等'>通过前置条件实现幂等</b>：</p>
<p>就是给修改数据设置一个前置条件，如果满足条件就更新数据，否则就拒绝更新。</p>
<p>可以给数据增加一个版本号，每次更新数据前比较一下当前数据的版本号和消息中的版本号是否一致，如果不一致就拒绝更新。更新数据后同时把版本号+1，这样也可以实现幂等。</p>
<h2 id="⭐消息积压如何处理"><a href="#⭐消息积压如何处理" class="headerlink" title="⭐消息积压如何处理"></a>⭐消息积压如何处理</h2><p><strong>一般出现消息积压的主要原因是，生产者发送消息的速度大于消费者处理消息的速度</strong>。</p>
<p>如果只是短时间内有大量的请求发送到后端，这种情况消息积压是正常的现象，因为这些积压的消息会被逐渐消费掉。如果消息队列中一直积压了大量的数据，就需要排查问题了：</p>
<ol>
<li>首先可以排查日志，看是不是消费逻辑报错，导致同一条消息反复消费。</li>
<li>排查消费端和Broker之间的网络状态是否正常</li>
<li>扩容，增加partition和consumer节点，来提高消费端的处理能力。</li>
<li>优化消费逻辑，如果代码执行到某一个步骤就可以确定消息可以被正确处理，就可以提前给Broker发送消费成功的响应，然后把后续流程交给其它线程进行异步处理。</li>
</ol>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next 隐藏分类和标签页面的评论框</title>
    <url>/2022/12/13/hexo-next-%E9%9A%90%E8%97%8F%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%84%E8%AE%BA%E6%A1%86/</url>
    <content><![CDATA[<p>在<code>categories/index.md</code>和<code>tags/index.md</code>文件头中添加：<code>comments: false</code>。</p>
<img src="/2022/12/13/hexo-next-%E9%9A%90%E8%97%8F%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%84%E8%AE%BA%E6%A1%86/hexo-next-%E9%9A%90%E8%97%8F%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%84%E8%AE%BA%E6%A1%86.png" class="" title="image-20221213151555319">

<blockquote>
<p>如果想要禁止某篇文章被评论，也可以使用这样的方式。</p>
</blockquote>
]]></content>
      <categories>
        <category>questions</category>
      </categories>
      <tags>
        <tag>hexo next</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring相关</title>
    <url>/2022/12/08/Spring%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="⭐AOP"><a href="#⭐AOP" class="headerlink" title="⭐AOP"></a>⭐AOP</h2><p>AOP就是按照一定的规则去匹配方法，然后在方法的执行前后添加一些额外的通用逻辑。</p>
<p>常用的场景有：日志、接口鉴权、异常处理、Spring中的事务也是通过AOP实现的。</p>
<ul>
<li>切面（Aspect）：可以用<code>@Aspect</code>注解或者<code>&lt;aop:aspect&gt;</code>标签定义一个切面。</li>
<li>切点（Pointcut）：可以用来定义方法的匹配规则，当符合规则的方法被调用时，会触发对应的通知。</li>
<li>通知（Advice）：<ul>
<li>环绕通知（around）：目标方法执行前和执行后都会触发。用<code>@Around</code>声明。</li>
<li>前置通知（before）：目标方法执行前触发。用<code>@Before</code>声明。</li>
<li>后置通知（after）：目标方法执行后触发。用<code>@After</code>声明。</li>
<li>异常通知（exception）：目标方法执行抛异常时触发。用<code>@AfterThrowing</code>声明。</li>
<li>返回通知（return）：目标方法返回时触发。用<code>@AfterReturning</code>声明。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明切面</span></span><br><span class="line"><span class="meta">@Aspect</span>	</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.ao.bing.demo.spring.aop..*.*(..))&quot;)</span>	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pctMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;pctMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;Around advice&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pctMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before advice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@After(value = &quot;pctMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After advice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回通知</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pctMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterReturning advice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pctMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterThrowing advice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="⭐IOC"><a href="#⭐IOC" class="headerlink" title="⭐IOC"></a>⭐IOC</h2><p>如果没有IOC，假设A依赖B，就需要自己手动创建B的实例，如果后面B又需要依赖C，这个时候就需要调整A的代码，让A再创建C的实例并注入给B，这样对象之间的耦合度就太高了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果之后B又需要依赖C，就需要调整A的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="keyword">new</span> <span class="title class_">C</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">// 构造器注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> C c;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(C c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="⭐Spring事务"><a href="#⭐Spring事务" class="headerlink" title="⭐Spring事务"></a>⭐Spring事务</h2><h3 id="⭐事务的隔离级别"><a href="#⭐事务的隔离级别" class="headerlink" title="⭐事务的隔离级别"></a>⭐事务的隔离级别</h3><p>TransactionDefinition接口中定义了五个表示隔离级别的常量。</p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT</strong>：数据库默认的隔离级别（Mysql是RR，Oracle是RC）。</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</strong>：读未提交，可能会出现脏读。</li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED</strong>：读提交，可以解决脏读，会出现不可重复读。</li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ</strong>：可重复读，可以解决不可重复读，会出现幻读。</li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE</strong>：串行化。</li>
</ul>
<h3 id="⭐事务的传播方式"><a href="#⭐事务的传播方式" class="headerlink" title="⭐事务的传播方式"></a>⭐事务的传播方式</h3><ul>
<li><p><strong>TransactionDefinition.PROPAGATION_REQUIRED</strong>：（默认的隔离级别）如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
</li>
<li><p><strong>TransactionDefinition.PROPAGATION_SUPPORTS</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p>
</li>
<li><p><strong>TransactionDefinition.PROPAGATION_MANDATORY</strong>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p>
<blockquote>
<p>适用于对于一些不会单独执行，一旦被调用就必须包含事务的方法。</p>
</blockquote>
</li>
<li><p><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW</strong>：创建一个新的事务，如果当前存在事务，则把当前事务挂起，等新事物执行完之后，再恢复之前的事务继续执行。</p>
</li>
<li><p><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</strong>：以非事务方式运行，如果当前存在事务，则把当前事务挂起，方法执行完之后，再恢复之前的事务继续执行。</p>
</li>
<li><p><strong>TransactionDefinition.PROPAGATION_NEVER</strong>：以非事务方式运行，如果当前存在事务，则抛出异常。</p>
</li>
<li><p><strong>TransactionDefinition.PROPAGATION_NESTED</strong>：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则创建一个新事务。</p>
<blockquote>
<p>嵌套事务是指：子事务是父事务的一部分，父事务执行到子事务时，会创建一个回滚点，如果子事务回滚，父事务只会回滚到回滚点，也就是说，父事务之前的操作不会受到影响。</p>
<p>如果父事务回滚，子事务也会一起回滚，因为子事务需要和父事务统一提交。</p>
</blockquote>
</li>
</ul>
<h3 id="⭐事务失效的情况"><a href="#⭐事务失效的情况" class="headerlink" title="⭐事务失效的情况"></a>⭐事务失效的情况</h3><ul>
<li><p>@Transactional注解只能在public修饰的方法上才起作用。</p>
<blockquote>
<p>因为Spring是通过动态代理的方式实现AOP，private修饰的方法无法被代理到。</p>
</blockquote>
</li>
<li><p>如果<strong>数据库不支持事务</strong>，事务也会不起作用。</p>
<blockquote>
<p>比如MySQL的MyISAM引擎。</p>
</blockquote>
</li>
<li><p>默认情况下，如果<strong>抛出了非RuntimeException异常</strong>，事务不会回滚。</p>
<blockquote>
<p>可以在@Transactional注解中指定rollbackFor为特定的异常类。@Transactional(rollbackFor = Exception.class)。</p>
</blockquote>
</li>
<li><p>如果<strong>用try-catch捕获了异常，但是却没有手动回滚事物</strong>，事务不会回滚。</p>
<blockquote>
<p>在Spring的TransactionAspectSupport类中有个<code>invokeWithTransaction()</code>方法，这里面就是处理事物的逻辑，只有在捕获到异常之后才会进行后续的事物处理。</p>
<p>可以在catch代码块中使用TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();手动提交事务。</p>
</blockquote>
</li>
<li><p>在同一个类中有a()和b()两个方法，在b()方法上加@Transactional注解，然后在a()方法中调用b()方法，这种情况b()方法中得事务不会生效。</p>
<blockquote>
<p>因为必须通过代理过的类从外部调用目标方法才能生效。可以在代码中注入一个this，然后通过this在调用b()方法。</p>
</blockquote>
</li>
</ul>
<h2 id="⭐循环依赖"><a href="#⭐循环依赖" class="headerlink" title="⭐循环依赖"></a>⭐循环依赖</h2><p>多个bean之间相互引用，比如A依赖B，B也依赖A。</p>
<p>出现循环引用的bean必须是单例的，多例模式(propotype)的bean是不支持循环依赖的，会抛异常。因为propotype多例模式每次都会创建一个新的bean，当创建A时，发现引用了B就会创建B，发现B引用了A，这时又会去创建A，这就套娃了。</p>
<p>Spring内部维护了三个Map，就是通常说的三级缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ObjectFactory&lt;?&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>singletonObjects：</strong>一级缓存，缓存的是创建完成的Bean。</li>
<li><strong>earlySingletonObjects：</strong>二级缓存，缓存的是提前暴露出来的Bean，在这个Map里的Bean还未完成初始化，属于半成品。</li>
<li><strong>singletonFactories：</strong>三级缓存，映射了创建Bean的原始工厂。</li>
</ul>
<p>假设A和B互相依赖：</p>
<ol>
<li><p>首先A会被创建出来，并将自己暴露到三级缓存中，然后进行初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">		Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">				<span class="built_in">this</span>.singletonFactories.put(beanName, singletonFactory);	<span class="comment">// 将bean添加到三级缓存中</span></span><br><span class="line">				<span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">				<span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在初始化的过程中发现A依赖B，此时就会尝试从一级缓存中去获取B，然后发现B还没有被创建，这个时候就会触发B的创建。</p>
</li>
<li><p>B在初始化的时候发现依赖A，就会尝试从一级缓存中获取A。这个时候A还没有初始化完成，所以一级缓存中肯定没有，然后尝试从二级缓存中获取，此时也没有，最后尝试从三级缓存中获取A的工厂类，然后调用其<code>getObject()</code>就可以获取到A。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);	<span class="comment">// 1.从一级缓存中获取bean</span></span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; </span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">				singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);	<span class="comment">// 2.一级缓存如果没有,就从二级缓存中获取</span></span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);	<span class="comment">// 3.如果二级缓存中也没有，就从三级缓存中获取其工厂类</span></span><br><span class="line">					<span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();	<span class="comment">// 4.调用其工厂类的getObject()方法获取bean</span></span><br><span class="line">						<span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);	<span class="comment">// 5.将其加入到二级缓存</span></span><br><span class="line">						<span class="built_in">this</span>.singletonFactories.remove(beanName);	<span class="comment">// 6.从三级缓存中删除</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>B拿到A对象的引用之后可以顺利的完成自己的初始化，并将自己加入到一级缓存中。</p>
</li>
<li><p>然后A得到B对象的引用之后也可以完成初始化，进入到一级缓存中。</p>
</li>
</ol>
<h2 id="⭐Bean生命周期"><a href="#⭐Bean生命周期" class="headerlink" title="⭐Bean生命周期"></a>⭐Bean生命周期</h2><ol>
<li>实例化Bean对象，设置Bean属性。</li>
<li>如果实现了各种Aware接口，则会对Bean注入一些其它信息。比如BeanNameAware会注入Bean ID、BeanFactoryAware会注入Bean Factory、ApplicationContextAware会注入ApplicationContext。</li>
<li>如果实现了BeanPostProcessor接口，则会调用<code>postProcessBeforeInitialization()</code>和<code>postProcessAfterInitialization()</code>方法。</li>
<li>调用Bean自身定义的init方法。</li>
<li>最后依次调用DisposableBean的<code>destroy()</code>方法和Bean自身定制的<code>destroy()</code>方法。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优</title>
    <url>/2022/12/08/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="字符串性能优化"><a href="#字符串性能优化" class="headerlink" title="字符串性能优化"></a>字符串性能优化</h2><p>String对象的实现原理在不同的JDK版本是不同的：</p>
<ul>
<li><p>在JDK 6以及之前的版本中，String对象主要有四个成员变量：char[] 数组、偏移量 offset、字符数量 count、哈希值 hash。</p>
<blockquote>
<p>String对象是通过offset和count属性通过char[]数组获取字符串，这种方式效率很高，但是有可能会导致内存泄漏。</p>
<p>因为<code>substring()</code>方法返回的子字符串对象会使用原字符串中的char[]数组，这就会导致原字符串始终无法被回收掉。</p>
</blockquote>
</li>
<li><p>JDK 7版本对String类做了修改，移除了offset和count这两个属性，<code>substring()</code>方法也不再共享char[]数组，解决了内存泄漏的问题。</p>
</li>
<li><p>JDK 9版本将String类中的char[]数组改为了 byte[]数组，新增编码格式属性coder。</p>
<blockquote>
<p>这样做的好处是可以节约内存，因为一个char字符占2个字节，一个byte字符占1个字节。</p>
<p>coder属性的作用是，在计算字符串长度或者使用<code>indexOf()</code>方法时，需要根据这个字段，判断如何计算字符串长度。</p>
</blockquote>
</li>
</ul>
<p><strong>通过 String.intern方法节省内存</strong>：</p>
<p>调用<code>intern()</code>方法时，会判断字符串常量池中是否有相同的对象，如果没有，就在常量池中新增该对象，如果有，就返回常量池中的对象。</p>
<p>如果对空间要求很高，并且存在大量重复字符串时，可以考虑调用<code>intern()</code>方法。</p>
<h2 id="⭐GC调优"><a href="#⭐GC调优" class="headerlink" title="⭐GC调优"></a>⭐GC调优</h2><p>⭐<strong>降低<a href="#">Minor GC</a>Minor GC频率</strong>：</p>
<p>[Minor GC](#Minor GC)只有Eden区耗尽才会触发，如果新生代空间比较小，就会导致[Minor GC](#Minor GC)很频繁，可以通过增大新生代空间降低[Minor GC](#Minor GC)的频率。</p>
<p>扩容Eden区虽然可以减少[Minor GC](#Minor GC)的次数，但是会导致新生代中堆积更多对象，有可能会增加单次[Minor GC](#Minor GC)的时间？</p>
<p>[Minor GC](#Minor GC)主要分为两部分：扫描新生代、将存活对象复制到Survivor区</p>
<p>通常复制对象的成本要远高于扫描成本。</p>
<ul>
<li>如果内存中大部分对象存活时间都比较长，这种情况增加新生代空间，会导致新生代中堆积更多还活着的对象，[Minor GC](#Minor GC)要复制更多对象，反而会增加[Minor GC](#Minor GC)时长。</li>
<li>如果内存中的对象存活时间都比较短，这种情况扩容新生代，并不会增加单次[Minor GC](#Minor GC)的时间，因为[Minor GC](#Minor GC)时长主要取决于，扫描后存活对象的数量。如果Eden区空间比较大，[Minor GC](#Minor GC)的时间间隔就会变长，大部分对象在[Minor GC](#Minor GC)开始之前就已经死掉了，这样就可以减少复制对象的数量。</li>
</ul>
<p>⭐<strong>降低[Full GC](#Full GC)频率</strong>：</p>
<p>堆空间不足、老年代空间不足，会触发[Full GC](#Full GC)。</p>
<p>[Full GC](#Full GC)会导致上下文切换，降低系统性能，降低Full GC的频率：</p>
<ol>
<li>避免创建大对象，如果对象的大小超过了新生代最大对象阈值，会被直接创建在老年代，</li>
<li>增大堆空间。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论</title>
    <url>/2022/12/08/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="⭐CAP理论"><a href="#⭐CAP理论" class="headerlink" title="⭐CAP理论"></a>⭐CAP理论</h2><p>CAP理论是说：在一个分布式系统中，最多只能满足C、A、P中的两个需求。</p>
<ul>
<li>C（Consistency）：表示一致性，同一个数据的多个副本能够保持严格的一致性。</li>
<li>A（Availability）：表示可用性，系统提供的服务必须一直处于可用状态，每次请求都能得到正确的响应。</li>
<li>P（Partation Tolerance）：表示分区容错性，将同一个系统部署在多个服务器上，某一个系统宕机，其它系统可以提供同样的服务。</li>
</ul>
<p>CAP之所以只能三选二，是因为在分布式系统中<strong>分区容错性</strong>是必须要实现的，不能因为某个节点故障导致整个系统不可用的情况，所以<strong>一致性</strong>和<strong>可用性</strong>只能二选一。</p>
<p>比如某个节点进行写操作，为了保证一致性，必须要禁止其它节点的读写操作，这就和<strong>可用性</strong>发生冲突了。</p>
<p>如果要保证其它节点也可以读写的话，<strong>一致性</strong>就没办法保证了。</p>
<p>对于保存系统元信息的节点，比如策略信息、数据库信息，必须保证所有节点的一致性，所以更适合CP架构。</p>
<p>对于读写频繁的节点，性能和可用性更加重要，所以更适合AP架构。</p>
<ul>
<li><p><strong>ZooKeeper</strong>：<strong>ZooKeeper保证的是CP</strong>，任何时刻对ZooKeeper的读请求都能得到一致性的结果，但是ZooKeeper在进行Leader选举的时候，或者半数以上机器不可用的时候，服务是不可用的。</p>
</li>
<li><p><strong>Eureka</strong>：<strong>Eureka保证的是AP</strong>，在Eureka中不存在Leader节点，每个节点都是平等的，只要有一台节点是可用的，就可以提供正常的服务。只不过这台节点上的数据不一定是最新的。</p>
</li>
<li><p><strong>Nacos</strong>：既支持CP也支持AP。</p>
</li>
</ul>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE理论可以理解为是CAP理论中AP架构的延伸，主要强调的是可用性。</p>
<p>BASE理论主要包括：<a href="#%E5%9F%BA%E6%9C%AC%E5%8F%AF%E7%94%A8">基本可用</a>，<a href="#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7">最终一致性</a>。</p>
<p><b id='基本可用'>基本可用</b>：</p>
<p>当分布式系统出现故障时，允许损失部分功能的可用性，来保障核心功能的可用性。</p>
<p>比如通过消息队列缓存请求，避免大量请求直接进入后台，就是牺牲了响应时间的可用性，来保证核心功能的正常运行。</p>
<p>还有当系统无法支撑高并发访问时，对非核心业务降级（返回系统繁忙页面）。</p>
<p><b id='最终一致性'>最终一致性</b>：</p>
<p>多个节点之间由于同步延迟的问题导致数据暂时不一致，经过一定时间之后，可以保证数据最终是一致的。</p>
<p>比如定时对账检测数据一致性，并修复。</p>
<h2 id="⭐分布式锁"><a href="#⭐分布式锁" class="headerlink" title="⭐分布式锁"></a>⭐<b id='分布式锁'>分布式锁</b></h2><p>分布式锁是分布式环境下同一时刻只有一个节点可以访问共享资源。</p>
<p>分布式锁必须存放在所有节点都可用看到的地方，比如Redis、数据库等。</p>
<p>分布式锁的实现方式有：</p>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">基于关系型数据库实现分布式锁</a>。</li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">基于缓存实现分布式锁</a>。</li>
<li><a href="#%E5%9F%BA%E4%BA%8EZookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">基于Zookeeper实现分布式锁</a>。</li>
<li>[fecing token方案](#fecing token方案)。</li>
</ul>
<p>Zookeeper分布式锁的可靠性是最高的，而且有封装好的框架（Curator），实现起来也很简单。</p>
<p><b id='基于关系型数据库实现分布式锁'>基于关系型数据库实现分布式锁</b>：</p>
<p>最简单的办法就是创建一张锁表。要锁住资源时，就在表中添加一条记录，释放锁时，就删除这条记录。</p>
<p>但是数据库是需要持久化到磁盘上的，频繁的读写数据库会导致IO开销很大，这种分布式锁适合对性能要求不高的场景。</p>
<p>⭐<b id='基于缓存实现分布式锁'>基于缓存实现分布式锁</b>：</p>
<p>加锁时，用Redis的<code>setnx key value</code>命令，这个命令的逻辑是这样的：当key不存在时，则设置key和value，并返回1，如果key已经存在了，直接返回0.</p>
<p>如果客户端加完锁之后就掉线了，那其它节点就再也获取不到锁了，所以还要通过<code>set expire</code>命令设置过期时间。</p>
<p>需要注意的是，如果客户端执行完<code>setnx</code>命令之后，还没来得及设置过期时间就掉线了，同样会产生死锁，所以需要Redis 2.6.12版本之后拓展了SET命令的参数：<code>SET lock 1 EX 10 NX</code>。</p>
<p>缓存中的数据放在内存中，不需要额外的IO开销。也可以设置key的失效时间，来控制锁的超时时间，可以避免死锁问题。</p>
<p>⭐<b id='基于Zookeeper实现分布式锁'>基于Zookeeper实现分布式锁</b>：</p>
<ol>
<li>加锁时，在zookeeper中/lock目录下创建一个临时有序节点，然后获取/lock目录下所有临时节点，并监听自己前面的那个节点（每个客户端只需要监听一个节点）。</li>
<li>然后再判断当前创建的节点是否是最小的节点。<ul>
<li>如果是最小的节点，则认为加锁成功。</li>
<li>如果不是最小的节点，则对节点序号的前一个节点添加一个监听事件。</li>
</ul>
</li>
<li>解锁时，删除当前最小的节点，注册了监听事件的客户端就会收到watcher事件，然后客户端再判断是否是最小的节点。</li>
</ol>
<p>需要注意的是：</p>
<ol>
<li><p>zookeeper需要频繁的添加和删除节点，所以性能不如缓存实现的分布式锁。</p>
</li>
<li><p>客户端与zookeeper建立连接后，zookeeper需要通过定时心跳来维持连接，如果zookeeper长时间没有收到客户端的心跳，就会认为客户端断开连接了，也会把对应的临时节点删除掉。如果出现网络波动，zookeeper有可能误判客户端下线，导致锁释放错误。</p>
</li>
</ol>
<p>⭐<b id='fecing token方案'>fecing token方案</b>：</p>
<p>fecing token方案流程如下：</p>
<ol>
<li>客户端获取锁时，锁服务提供一个递增的token</li>
<li>客户端拿着这个token去操作共享资源</li>
<li>共享资源判断token是否是当前最新的token，如果是则执行操作，如果不是则拒绝执行。</li>
</ol>
<p>如果要对数据库中的记录加锁，可以给每条记录新增一个token字段，记录更新成功对应的token+1。</p>
<p>要更新数据时先根据记录ID获取其最新的token，然后在update语句中将token作为更新条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> <span class="keyword">value</span> <span class="operator">=</span> $&#123;<span class="keyword">value</span>&#125;, token <span class="operator">=</span> token<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> $&#123;id&#125; <span class="keyword">and</span> token <span class="operator">=</span> $&#123;current_token&#125;</span><br></pre></td></tr></table></figure>



<p>这个方案对共享资源的要求比较高，要有判断token和拒绝执行的能力，如果是写磁盘文件这样的场景就没法使用了。</p>
<h2 id="⭐分布式事务"><a href="#⭐分布式事务" class="headerlink" title="⭐分布式事务"></a>⭐分布式事务</h2><p>目前主流的思路有3种：</p>
<ul>
<li>基于XA协议的两阶段提交；（强一致性）</li>
<li>三阶段提交；（强一致性）</li>
<li>基于消息的最终一致性；（最终一致性）</li>
</ul>
<h3 id="⭐基于XA协议的两阶段提交"><a href="#⭐基于XA协议的两阶段提交" class="headerlink" title="⭐基于XA协议的两阶段提交"></a>⭐基于XA协议的两阶段提交</h3><p><strong>两阶段提交的思路是</strong>：<strong>协调者下发事务操作，节点将操作结果通知协调者，协调者根据节点的反馈决定是提交还是回滚</strong>。</p>
<p>XA是一个分布式事务协议，规定了事务管理器和资源管理器接口。</p>
<p><strong>事务管理器</strong>作为协调者，负责各个资源的提交和回滚；</p>
<p><strong>资源管理器</strong>就是分布式事务的节点，通常是数据库，比如MySQL 5.5版本、Oracle、DB2都实现了XA接口。</p>
<p>两阶段提交分为<strong>投票</strong>和<strong>提交</strong>两个过程：</p>
<ol>
<li><p>首先是<strong>投票阶段</strong>，协调者会向所有节点发起执行操作请求，并等待节点的响应。</p>
</li>
<li><p>节点收到请求后，会执行请求中的事务操作，但是不提交。执行完之后，根据执行结果会向协调者发送 “是” 或者 “否” 。</p>
</li>
<li><p>当所有节点都返回了操作结果后，就会进入<strong>提交阶段</strong>：</p>
<ul>
<li>如果协调者接收的都是 “是” ，就会向所有节点发送<strong>提交</strong>请求，节点收到请求后，就会提交本地事务。</li>
<li>如果协调者收到的消息中包含 “否”，就向所有节点发送<strong>回滚</strong>请求，节点收到请求后，就会回滚之前的操作。</li>
</ul>
</li>
</ol>
<p><strong>问题</strong>：</p>
<ul>
<li><strong>同步阻塞问题</strong>：在两阶段提交的过程中，当本地资源管理器占有资源时，其它资源管理器如果访问同一资源时会被阻塞。</li>
<li><strong>单点故障问题</strong>：一旦事务管理器发生故障，资源管理器就会一直等待事务管理器的消息，导致一直锁定事务。</li>
<li><strong>数据不一致问题</strong>：在提交阶段的时候，协调者发送<strong>提交</strong>请求后，如果发生了网络异常，就会导致可能只有一部分节点接收到了请求并提交了事务。其它节点无法执行事务，导致数据不一致。</li>
</ul>
<h3 id="⭐三阶段提交"><a href="#⭐三阶段提交" class="headerlink" title="⭐三阶段提交"></a>⭐三阶段提交</h3><p>三阶段提交是对两阶段提交的改进，在协调者和参与者引入了超时机制（2pc只是在协调者引入了超时）减少了整个集群的阻塞时间。</p>
<p>在提交阶段之前，新增一个预提交阶段，保证在最后提交阶段之前各节点的状态是一致的。</p>
<ol>
<li><p>协调者向所有节点发送请求操作，参与者收到请求后，如果节点可以执行事务就回复  “是”，不然就回复 “否”。</p>
</li>
<li><p>协调者根据节点的回复，来决定是否进行预提交(PreCommit)</p>
<ul>
<li>如果所有节点回复的都是Yes，协调者就会向所有节点发送预提交请求，节点收到预提交请求后，就会执行请求内的事务操作，并记录回滚信息，根据执行结果回复 “是”或”否”。</li>
<li>如果有任何一个节点回复了 “否”、或者协调者等待超时之后，就会向所有节点发送回滚事物的请求，节点收到回滚请求后，或者等待超时后，就会回滚事务。</li>
</ul>
</li>
<li><p>当所有节点都返回了操作结果后，就会进入<strong>提交阶段</strong>：</p>
<ul>
<li>如果协调者接收的都是 “是” 消息，就会向所有节点发送<strong>提交</strong>事务的请求，节点收到请求后，提交本地事务。然后给协调者发送响应。</li>
<li>如果协调者接收的都是 “否” 消息，就会向所有节点发送<strong>回滚</strong>事务的请求，节点收到请求后，就会回滚本地事务，然后给协调者发送响应。</li>
</ul>
</li>
</ol>
<p><strong>问题</strong>：在提交阶段的时候，协调者发送提交请求后，如果发生了网络异常，就会导致可能只有一部分节点接收到了请求并提交了事务。其它节点无法执行事务，导致数据不一致。</p>
<h3 id="⭐基于分布式消息的最终一致性"><a href="#⭐基于分布式消息的最终一致性" class="headerlink" title="⭐基于分布式消息的最终一致性"></a>⭐基于分布式消息的最终一致性</h3><p>基于分布式消息的最终一致性方案，需要引入一个消息中间件，用于在多个系统之间传递消息。</p>
<p>假如在电商系统中的下单操作需要订单系统、支付系统、库存系统来完成。具体流程：</p>
<ol>
<li>订单系统把订单消息发送给消息中间件，消息状态标记为 “待确认”。</li>
<li>消息中间件收到消息后，对消息持久化。并标记为 “待发送”。然后给订单系统返回持久化结果(成功/失败)</li>
<li>订单系统根据持久化结果判断如何进行业务操作。成功则创建订单，失败则返回订单创建失败。然后把订单创建结果返回给消息中间件。</li>
<li>消息中间件收到操作结果后，根据结果进行后续操作。成功则更新消息状态为 “可发送”，失败则删除消息。</li>
<li>消息中间件将 “可发送”的消息发送给支付系统，支付系统也按照上面的流程进行支付操作。</li>
<li>支付系统操作完成后，会将支付消息返回给消息中间件，中间件再把消息发送给订单系统。订单系统再调用库存系统，进行出库操作。</li>
</ol>
<h3 id="⭐补偿事务-TCC"><a href="#⭐补偿事务-TCC" class="headerlink" title="⭐补偿事务(TCC)"></a>⭐补偿事务(TCC)</h3><p>比如下单操作：</p>
<ul>
<li>Try阶段：扣库存。</li>
<li>Confirm阶段：更新订单状态，如果更新失败，则进入Cancel阶段。</li>
<li>Cancel阶段：恢复库存。</li>
</ul>
<p><strong>缺点</strong>：开发难度大，会导致每个业务操作都需要开发try、confirm、cancel三个接口，要保证数据一致性confirm和cancel阶段还需要实现幂等性。</p>
<h2 id="分布式选举算法"><a href="#分布式选举算法" class="headerlink" title="分布式选举算法"></a>分布式选举算法</h2><h3 id="Bully算法"><a href="#Bully算法" class="headerlink" title="Bully算法"></a>Bully算法</h3><p>Bully算法比较简单粗暴，它的选举规则是在所有活跃的节点中，选取ID最大的节点作为主节点。</p>
<p>在Bully算法中，节点分为普通节点和主节点，初始化时所有节点都是普通节点。选举完成后只有一个节点能成为主节点，当主节点故障后，才会重新选举。</p>
<p>Bully算法的选举过程，需要用到3种消息：</p>
<ul>
<li>Election消息：用于发起选举。</li>
<li>Alive消息：对Election消息的应答。</li>
<li>Victory消息：竞选成功后主节点向其它节点发送的消息。</li>
</ul>
<p>集群中每个节点都需要维护其它所有节点的ID，具体的选举过程是：</p>
<ol>
<li>每个节点判断自己的ID是否是当前所有活跃节点中最大的，如果是则向其它节点发送Victory消息。</li>
<li>如果不是最大的ID，则向比自己大的所有节点发送Election消息。</li>
<li>在一定时间内，某一节点没有收到其它节点回复的Alive消息，则认为自己是主节点，并向其它节点发送Victory消息；如果收到比自己ID大的节点的Alive消息，则等待其它节点发送Victory消息。</li>
<li>如果节点收到比自己ID小的节点发送的Election消息，则回复Alive消息。</li>
</ol>
<h3 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h3><p>Raft算法是少数服从多数的选举算法。</p>
<p>在Raft算法中，集群节点分为三种：</p>
<ul>
<li>Leader：主节点</li>
<li>Candidate：后选择</li>
<li>Follower：Leader的跟随者，不可以发起选举。</li>
</ul>
<p>具体的选举过程是：</p>
<ol>
<li>初始化时，所有节点都是Follower状态</li>
<li>开始选举时，所有节点变为Candidate，并向其它节点发送选举请求。</li>
<li>其它节点根据收到的选举请求的先后顺序，回复是否同意其成为主节点。每一轮选举中每个节点只能投一张票。</li>
<li>某一节点获得一半以上的票数则成为主节点，状态转为Leader，其它节点变为Follower。主节点和从节点会定期发送心跳包，检测主节点是否活跃。</li>
<li>当主节点故障，会重新发起选举。</li>
</ol>
<h3 id="ZAB算法"><a href="#ZAB算法" class="headerlink" title="ZAB算法"></a>ZAB算法</h3><p>ZAB(Zookeeper Atomic Broadcast)算法是为Zookeeper实现分布式协调功能设计的。</p>
<p>ZAB算法通过节点ID和数据ID作为参考，进行选举。<strong>首先是数据ID最大的成为Leader，如果数据ID相同，则节点ID最大的成为Leader</strong>。</p>
<p>每个节点都有一个三元组(当前节点ID，当前节点数据ID，当前选举轮数)</p>
<p>ZAB算法中有三种角色：</p>
<ul>
<li>Leader：主节点</li>
<li>Follower：跟随者</li>
<li>Observer：观察者，无权投票。</li>
</ul>
<p>选举过程中节点还会有4个状态：</p>
<ul>
<li><strong>Looking状态</strong>：选举状态，Looking状态下的节点，会认为当前集群没有Leader，会自己进入选举状态。</li>
<li><strong>Leading状态</strong>：领导者状态，表示当前节点为Leader</li>
<li><strong>Following状态</strong>：跟随者状态，选出主节点后，其它节点更新为Following状态。</li>
<li><strong>Observing状态</strong>：观察者状态，表示当前节点为Observer，没有投票权和选举权。</li>
</ul>
<p>具体的选举过程：</p>
<ol>
<li>初始化时，所有节点会将元组内的信息，发送给其它节点。</li>
<li>每个节点都会用收到的选举信息和当前节点的选举信息进行比较。数据ID大的为Leader，数据ID一致的话，节点ID大的成为Leader。</li>
<li>选举完成后，Leader会向其它服务器发送心跳包并维护连接。</li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式理论</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计</title>
    <url>/2022/12/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h2><p><strong>巨大的瞬时流量</strong>：</p>
<p>秒杀系统的特点，就是几乎所有的请求会集中到同一时刻，这种场景会在短时间内产生巨大的流量。</p>
<ol>
<li><p><strong>验证码</strong>：验证码可以拦截掉机器人发出的请求，可以起到防刷作用。也可以延缓并发，因为有的用户手速快，有的手速慢，可以让一瞬间的集中流量平均到5~10秒。</p>
</li>
<li><p><strong>消息队列</strong>：可以把请求暂存到消息队列中，让服务根据自己的处理能力来消费请求，避免大量请求直接进入后台。</p>
</li>
<li><p><strong>限流</strong>：限流就是通过校验，丢弃掉多余流量，减少下游服务需要处理的请求数量。</p>
<ul>
<li><p>Nginx限流：Nginx自带限流功能，可以根据IP地址或者自定义参数来做限流。</p>
<blockquote>
<p>比如可以限制每个IP只能发送一个请求，或者每个用户ID只能发送一个请求。</p>
</blockquote>
</li>
<li><p>线程池限流：通过配置线程池的最大线程数，当等待队列满了，并且所有线程都处于工作状态，多余的请求就会被丢弃，也可以实现限流。</p>
</li>
</ul>
</li>
</ol>
<p><strong>流量隔离</strong>：</p>
<p>参与秒杀活动的商品通常只占很少一部分，为了不影响普通商品的交易，需要对流量进行隔离。</p>
<ul>
<li><strong>商品打标</strong>：可以通过对秒杀商品打上特殊的标签，然后在网关层将秒杀商品的请求路由到对应的秒杀服务。</li>
</ul>
<p><strong>热点数据问题</strong>：</p>
<p>对于秒杀系统，大家抢购的通常都是同一件商品，不管是用数据库，还是用缓存，都无法支撑几十万、上百万对同一个key的读写。</p>
<blockquote>
<p>Redis最高只能支撑几万的TPS。</p>
</blockquote>
<p>热点数据可以分为<strong>读热数据</strong>和<strong>写热数据</strong>：</p>
<ol>
<li><strong>读热数据</strong>：可以把热点数据加载到本地缓存中，需要注意的是本地缓存会导致数据延迟，可以通过调整本地缓存的有效期降低数据不一致的时间。</li>
<li><strong>写热数据</strong>：先把库存数据同步到Redis中，通过Lua脚本把校验库存、扣减库存的命令打包到一个脚本中，发送给Redis执行。Redis扣减库存成功后，再通过异步将数据保存到数据库中。</li>
</ol>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则</title>
    <url>/2022/12/08/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h2><p><strong>贫血模式主要就是把数据和行为分隔开，会破坏面向对象中的封装特性，是一种面向过程的编程风格</strong>。</p>
<p>比如现在的Web项目一般都是基于MVC三层架构来设计的，项目分为Repository层、Service层、Controller层。</p>
<p>Entity和Repository负责数据访问层、BO和Service负责业务逻辑层、VO和Controller负责接口层。</p>
<p>但是实际上，BO通常是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑，逻辑主要集中在Service层，然后通过Service来操作BO，这种被称为 <strong>贫血模型</strong>。还有Entity和VO也都是基于贫血模型设计的。</p>
<h2 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h2><p><strong>充血模型是一种基于的DDD开发模式，贫血模型是把数据和业务逻辑分割到不同的类中，充血模型是相反的，是把数据和业务逻辑封装到同一个类中，这种模型可以满足面向对象的封装特性</strong>。</p>
<p><strong>实际上，基于充血模型的DDD设计模式，也还是按照MVC三层架构设计的。Controller负责暴露接口，Service负责业务逻辑，Repository负责数据存取。只不过在充血模型中，Service层包含Service和Domain两个部分，Domain相当于实体类，只不过它既包含数据，也包含业务逻辑。Service作为Repository层和Domain之间的连接层，用来获取数据库中的数据，然后再转换成Domain，用Domain来完成业务逻辑，然后调用Repository将数据写入到数据库</strong>。</p>
<p>Entity被设计成贫血模型，虽然违背了面向对象的封装特性，但Entity的生命周期是有限的，一般被传递到Service层就会转换成BO或者Domain来完成后面的逻辑，所以Entity通常不会被任意修改。</p>
<p>VO主要是作为接口传输数据的载体，从功能上来讲，它不应该包含业务逻辑，只包含数据，所以设计成贫血模型也是比较合理的。</p>
<p>贫血模型的开发模式，比较适合业务简单的系统，充血模型更适合业务复杂的场景。</p>
<h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><p>单一职责的意思是：<strong>一个类或者一个模块只负责完成一个功能</strong>。</p>
<p>也就是说，要设计粒度小、功能单一的类，如果一个类包含了多个完全不相干的功能，这种类的职责就不够单一，应该把他拆分成多个简单的类。</p>
<h2 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（OCP）</h2><p>开闭原则的意思是：<strong>添加一个新的功能，应该是在已有代码的基础上拓展代码，而不是修改已有代码</strong>。</p>
<p>开闭原则的关键是预留拓展点，需要针对业务尽量识别出所有拓展点，不过也没有必要为一些遥远的、不一定发生的需求提前买单，做过度设计。合理的做法是，对一些短期内、比较确定的需求做一些拓展性的设计。</p>
<p>通常拓展性和可读性是相互冲突的，拓展性高的代码可能会复杂很多，有时候就需要在可读性和拓展性之间做权衡。</p>
<h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><p>里氏替换原则的意思是：<strong>在继承关系中子类要保证替换父类的时候，不改变原来的程序逻辑和正确性</strong>。</p>
<p>比如在父类中运行出错的时候返回null，数据为空返回空集合。子类重写函数之后，变成了运行出错返回空集合，数据为空返回null。这种设计就违背了里氏替换原则。</p>
<p>再比如父类中只会抛出IOException异常，如果子类再抛出其它异常，也会违背里氏替换原则。</p>
<h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><p>接口隔离原则的意思是：<strong>不应该强迫调用者依赖它不需要的接口</strong>。<strong>如果部分接口只被一部分调用者使用，那就可以把这部分接口拆分出来，单独给对应的调用者使用，而不是强迫其它调用者也依赖这部分不会被调用的接口</strong>。</p>
<p>比如有一个管理用户的UserService，现在需要提供一个删除用户的方法，如果直接在UserService中添加删除用户的方法，那所有依赖UserService的类都可以调用这个接口，就有可能导致误删用户。</p>
<p>通过接口隔离原则，可以把删除相关的操作单独放到另外一个DeleteUserService中，然后让某些特定的类来依赖这个Service。</p>
<h2 id="依赖反转原则（DIP）"><a href="#依赖反转原则（DIP）" class="headerlink" title="依赖反转原则（DIP）"></a>依赖反转原则（DIP）</h2><p>依赖反转原则的意思是：<strong>外层模块不要直接依赖底层模块，应该通过抽象层来实现底层模块的依赖</strong>。这样就可以通过抽象层动态切换底层模块的实现细节。</p>
<p>比如<a href="#%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86">Java中的反射调用</a>，就是通过委派层动态切换<a href="#%E6%9C%AC%E5%9C%B0%E5%AE%9E%E7%8E%B0">本地实现</a>和<a href="#%E5%8A%A8%E6%80%81%E5%AE%9E%E7%8E%B0">动态实现</a>。</p>
]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2022/12/08/Kafka/</url>
    <content><![CDATA[<h2 id="⭐应用场景"><a href="#⭐应用场景" class="headerlink" title="⭐应用场景"></a>⭐应用场景</h2><p><strong>异步处理</strong>：</p>
<p>比如某些业务请求需要3个步骤才能完成，如果前2个步骤完成之后，就已经可以保证业务可以正常完成，就可以直接返回给客户端响应结果，然后把第三个步骤通过消息队列发送给消费者，由消费者来完成后续的流程。这样就可以提高服务的响应速度。</p>
<p>比如我们系统中的某些发行业务都是需要<strong>请求</strong>和<strong>确认</strong>2个步骤才能完成，如果每一个请求都需要把这2个步骤执行完才给用户响应结果的话，就会导致处理请求的时间变长。如果想要提高程序处理请求的速度，就可以在完成第1个步骤之后，直接给用户返回结果，然后把确认消息放到消息队列中，由消费者完成后续的步骤。</p>
<p><strong>流量控制</strong>：</p>
<p>通过消息队列把前端和后端隔离起来，后端按照自己的处理能力从消息队列中处理请求。</p>
<p>这样就可以避免大量的请求直接冲击到后端，可以减少后端服务的压力。</p>
<p>这种方案的缺点是，消息队列会导致总体的响应时间变长，增加系统的复杂度。</p>
<p><strong>服务解耦</strong>：</p>
<p>在微服务架构中，有些下游服务需要获取上游服务的数据，但是下游服务是会增加或者减少的的，如果每次增减下游服务，都需要调整上游服务的接口，这样服务之间的耦合度就太高了。</p>
<p>可以通过消息队列让服务之间解耦，上游服务可以把数据发送到消息队列中，下游服务只需要订阅这个消息队列就可以实时获得数据。无论增加还是减少下游服务，上游服务都不需要修改。</p>
<h2 id="如何选择消息队列"><a href="#如何选择消息队列" class="headerlink" title="如何选择消息队列"></a>如何选择消息队列</h2><p>RocketMQ 对响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，<strong>对于响应时延有要求的业务场景，那应该选择使用 RocketMQ</strong>。</p>
<p>Kafka在设计上采用的是批量和异步的思想，这种设计让Kafka能做到超高的性能。但是带来的问题是，它同步收发消息的响应时延比较高，因为当生产者发送一条消息的时候，Kafka 并不会立即发送出去，而是要等一会儿攒一批再发送。所以，<strong>Kafka更适合离线类的场景</strong>。</p>
<p>也可以通过<code>linger_ms_config</code>和<code>batch_size_config</code>这两个参数控制发送消息的时机。</p>
<blockquote>
<p><code>batch.size</code>：用来控制单次提交的字节数大小，默认是16k。当缓冲区中的数据达到16k时，就会触发一次提交。</p>
<p><code>linger_ms</code>：用来控制两次提交的时间间隔，如果两次提交的时间间隔达到了这个阈值，不管batch有没有满，都会发送出去。</p>
</blockquote>
<h2 id="⭐消息模型"><a href="#⭐消息模型" class="headerlink" title="⭐消息模型"></a>⭐消息模型</h2><p>Kafka使用的消息模型是发布-订阅模型。</p>
<p><strong>可靠性</strong>：</p>
<p>Kafka是通过请求-确认机制，来保证消息的可靠性。</p>
<p>具体来说就是：</p>
<ul>
<li><p>生产者先将消息发送给Broker，Broker收到消息会把消息写进topic的partition中，然后给生产者发送确认的响应。如果生产者没有收到服务端的确认或者收到了失败的响应，就表示消息发送失败。</p>
</li>
<li><p>消费者在收到消息并完成消费业务逻辑后，也会给Broker发送确认响应，Broker收到消费者的确认后，才会认为消息被消费成功。否则消费者下一次拉取到的数据还是同一条消息。</p>
</li>
</ul>
<p><strong>有序性</strong>：</p>
<p>Kafka只在partition层面保证有序性，topic层面是无法保证有序性的，在同一个partition中，前一条消息被成功消费，才能继续消费下一条消息。</p>
<p>也就是说同一个partition，同一时刻最多只能有一个消费者进行消费，所以如果消费者的节点数量大于partition的数量，多出来的消费者是没有意义的。</p>
<p>在Kafka中每个消费者组都会消费主题中一份完整的消息，不同消费组之间互不影响，也就是说一条消息被消费组A消费过，还会再给消费组B消费。同一个组内的消费者是竞争关系，如果一条消息被一个消费者消费了，组内其他消费者就不会再收到这条消息了。</p>
<p>消息需要被不同的组进行多次消费，所以消息被消费后不会被删除。Kafka会为每个消费者组维护一个offset，每成功消费一条消息，就把对应的offset就+1。</p>
<h2 id="⭐Kafka分布式事务"><a href="#⭐Kafka分布式事务" class="headerlink" title="⭐Kafka分布式事务"></a>⭐Kafka分布式事务</h2><p>逻辑是这样的：</p>
<ol>
<li>首先在消息队列上开启一个事务，然后给消息队列发送一个“事务消息”，这个事务消息在事务提交之前，对消费者是不可见的。</li>
<li>事务消息发送成功之后，就可以开始执行本地事务了。</li>
<li>然后根据本地事务的执行结果决定是提交事务或者回滚事务，这样就基本实现了 “要么都成功，要么都失败”的一致性要求。</li>
</ol>
<p>但是最后提交事务的消息有可能会发送失败，<strong>Kafka的解决方案比较简单，就是直接抛异常，让用户自己处理，我们可以在业务代码中重试，或者回滚之前的操作</strong>。所以在写代码的时候，调用send方法时一定要捕获异常。</p>
<h2 id="⭐事务实现原理"><a href="#⭐事务实现原理" class="headerlink" title="⭐事务实现原理"></a>⭐事务实现原理</h2><p>Kafka中的事务是基于<strong>两阶段提交</strong>来实现的。</p>
<p>Kafka引入了事务协调者来负责管理服务端的事务，这个事务协调者是Broker的一部分。</p>
<p>Kafka中有一个特殊的Topic，用来记录事务日志。在Kafka集群中，可以存在多个协调者，每个协调者负责管理事务日志中的几个分区，这样是为了并行执行多个事务。</p>
<p>具体的逻辑是这样的：</p>
<ol>
<li><p>在开启事务的时候，生产者会给协调者发送一个开启事务的请求，协调者会在事务日志中记录下事务ID。</p>
</li>
<li><p>然后，Producer在发送消息之前，还要给协调者发送请求，告诉消息属于哪个topic和哪个partition。这些信息会被协调者记录在事务日志里面。</p>
</li>
<li><p>然后就可以正常发送消息了，Kafka会在Consumer端过滤掉未提交的事务消息。</p>
</li>
<li><p>消息发送完成后，Producer会给协调者发送提交或者回滚事务的请求，然后协调者就会开始<strong>两阶段提交</strong>：</p>
<ul>
<li>第一阶段：协调者会把事务的状态设置为prepare预提交，然后写到事务日志里。</li>
<li>第二阶段：协调者会写一条“事务结束”的消息并把事务状态改为 “已提交”。Consumer读到事务提交的消息之后，就会去消费对应的事务消息。</li>
</ul>
</li>
<li><p>最后协调者会记录最后一条事务日志，表示这个事务已经结束了。</p>
</li>
</ol>
<p>⭐Kafka高性能IO原理</p>
<ol>
<li><a href="#%E6%89%B9%E9%87%8F%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E5%BC%80%E9%94%80">批处理消息，减少网络通信的开销</a>。</li>
<li><a href="#%E5%88%A9%E7%94%A8%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99%E6%8F%90%E5%8D%87%E7%A3%81%E7%9B%98IO%E6%80%A7%E8%83%BD">顺序读写磁盘，减少磁盘寻址时间</a>。</li>
<li><a href="#%E5%88%A9%E7%94%A8PageCache%E5%8A%A0%E9%80%9F%E6%B6%88%E6%81%AF%E8%AF%BB%E5%86%99">利用PageCache加速消息的读写</a>。</li>
<li><a href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF">零拷贝</a>。</li>
</ol>
<p><b id='批量收发消息减少网络通信的开销'>批量收发消息减少网络通信的开销</b>：</p>
<p>在Kafka内部消息都是批量处理的：</p>
<ul>
<li><p>在生产端，虽然Kafka的Producer只提供了单条发送的API，实际上Kafka采用了批量和异步的发送机制。</p>
<ul>
<li><p>调用<code>send()</code>方法时，不管是同步发送还是异步发送，Kafka都不会立刻把这条消息发送出去，而是放到内存中缓存起来，然后在合适的时候一次性把缓存中的数据全部发送出去。这样可以减少网络通信的次数。</p>
<blockquote>
<p>可以通过<code>linger_ms_config</code>和<code>batch_size_config</code>这两个参数控制发送消息的时机。</p>
<p><code>batch.size</code>：用来控制单次提交的字节数大小，默认是16k。当缓冲区中的数据达到16k时，就会触发一次提交。</p>
<p><code>linger_ms</code>：用来控制两次提交的时间间隔，如果两次提交的时间间隔达到了这个阈值，不管batch有没有满，都会发送出去。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>在消费端，消息也是批量处理的，Consumer拉到一批消息后，会把消息拆分开，再一条一条发送给我们的程序来处理。</p>
</li>
</ul>
<p><b id='利用顺序读写提升磁盘IO性能'>利用顺序读写提升磁盘IO性能</b>：</p>
<blockquote>
<p>磁盘有一个特性，就是顺序读写的性能要比随机读写快好几倍。</p>
<p>因为操作系统每次从磁盘读写数据的时候，需要先寻址，也就是找到数据在磁盘上的物理位置，然后再进行数据读写。</p>
<p>顺序读写比随机读写省去了大部分的寻址时间，因为它只要一次寻址，就可以连续的写下去，所以性能会好很多。</p>
</blockquote>
<p><strong>Kafka利用了磁盘顺序读写速度很快的特点，对于每个分区，它从Producer接收的消息，会顺序的写入到对应的log文件中，一个文件写满了，就开启一个新的文件这样顺序写下去</strong>。</p>
<p>消费的时候也是从某个log文件中的某个位置，顺序的把消息读出来。</p>
<p><b id='利用PageCache加速消息读写'>利用PageCache加速消息读写</b>：</p>
<p>Kafka还会利用PageCache加速消息的读写。</p>
<blockquote>
<p>PageCache是操作系统都有的一个特性，可以简单的理解为PageCache就是操作系统在内存中给磁盘上的文件建立的缓存，读写文件的时候，并不会直接去读写磁盘上的文件，应用程序实际上操作的是PageCache，也就是文件在内存中缓存的副本。</p>
</blockquote>
<p>PageCache有两种情况：</p>
<ul>
<li>一种情况是PageCache中有数据，那就直接读取，这样就节省了从磁盘上读取数据的时间。</li>
<li>另一种情况是PageCache中没有数据，这个时候应用程序会被阻塞，操作系统会把数据从文件复制到PageCache中，这种情况下，才会真正的读一次磁盘上的文件，这样就比较慢。</li>
</ul>
<p>应用程序用完某块PageCache后，操作系统并不会立刻就清理PageCache中的数据，除非系统内存不够用，操作系统才会去清理一部分数据。</p>
<p><b id='零拷贝技术'>零拷贝技术（Zero Copy）</b>：</p>
<p>Kafka还使用了一种“零拷贝”的操作系统特性来提升消费性能。</p>
<p>在Broker中，一条消息的消费的逻辑大概是这样的：</p>
<ol>
<li><p>首先从文件中把数据复制到PageCache中，如果PageCache中已经有数据了，这一步是可以省略的。</p>
<blockquote>
<p>在Kafka中，消息被写入到Broker中，通常很快就会被消费掉，像这种刚刚写入到PageCache中的数据，很快就会被消费者消费掉，PageCache命中率会非常高</p>
</blockquote>
</li>
<li><p>然后从PageCache中把数据复制到内存中。</p>
</li>
<li><p>最后从内存中把数据复制到Socket缓冲区里面，最后发送给客户端。</p>
</li>
</ol>
<p>Kafka使用“零拷贝”技术可以把这个复制次数减少一次，直接从PageCache里面把数据复制到Socket缓冲区里面，速度会很快。</p>
<h2 id="⭐如何保证消息不丢失"><a href="#⭐如何保证消息不丢失" class="headerlink" title="⭐如何保证消息不丢失"></a>⭐如何保证消息不丢失</h2><p>判断是否有消息丢失，<strong>可以利用消息队列的有序性来验证是否有消息丢失</strong>，逻辑是这样的：</p>
<ol>
<li>在Producer端，给每个发出去的消息附加一个连续递增的序号。</li>
<li>然后在Consumer端来检查这个序号的连续性</li>
<li>如果没有消息丢失，那Consumer接收到的消息必然是连续递增的，如果检测到序号不连续，就说明丢消息了。还可以通过丢失的序号确定是哪条消息丢失了，方便排查原因。</li>
</ol>
<p><strong>大部分的消息队列一般都会有拦截器机制，可以利用拦截器，在Producer发送消息之前，在拦截器中将序号注入到消息里面</strong>。</p>
<p>但是像Kafka和RocketMQ这样的消息队列，它并不保证Topic层面的顺序，只能保证partition上的消息是有序的，所以在发送消息的时候需要指定分区，并且每个分区都要单独校验序号的连续性。</p>
<p>如果Producer是有多个实例的，也需要每个Producer分别生成各自的序号，并且还需要加上Producer的标识，在Consumer端按照每个Producer分别来检测序号的连续性。</p>
<p>一条消息的传递主要分三个阶段：<a href="#Producer%E9%98%B6%E6%AE%B5">Producer阶段</a>、<a href="#Broker%E9%98%B6%E6%AE%B5">Broker阶段</a>、<a href="#Consumer%E9%98%B6%E6%AE%B5">Consumer阶段</a>。</p>
<p><b id='Producer阶段'>Producer阶段</b>：</p>
<p>在Producer端，消息队列通过<strong>请求-确认</strong>机制，来保证消息的可靠传递。</p>
<p>具体来说就是，Producer向Broker发送一条消息时，Broker收到消息之后会给Producer返回一个确认响应，表示消息已经收到了。只要Producer收到了Broker的确认响应，就可以保证消息在Producer阶段不会丢失。</p>
<p>但是有些消息队列在长时间没收到确认响应，会自动重试，如果重试失败就会以返回值或者抛异常的方式告诉用户消息发送失败。<strong>所以在写代码的时候，需要注意处理下返回值或者捕获异常，就可以保证这个发送阶段消息不会丢失</strong>。</p>
<blockquote>
<p>以Kafka为例，同步发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="type">RecordMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> producer.send(record).get();</span><br><span class="line"> System.out.println(<span class="string">&quot; 消息发送成功。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot; 消息发送失败！&quot;</span>);</span><br><span class="line"> System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.send(record, (metadata, exception) -&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span> (metadata != <span class="literal">null</span>) &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot; 消息发送成功。&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot; 消息发送失败！&quot;</span>);</span><br><span class="line">     System.out.println(exception);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b id='Broker阶段'>Broker阶段</b>：</p>
<p>在Broker阶段，一般情况下，只要Broker正常运行，就不会出现丢消息的情况，但是如果Broker出现故障，比如进程死掉，或者服务器宕机，就可能会丢消息。</p>
<p><strong>如果对消息的可靠性要求非常高，可以通过配置Broker参数来避免因为宕机导致丢消息</strong>。</p>
<p>如果是单个节点的Broker，可以配置一下Broker的参数，<strong>比如RocketMQ可以把<code>flushDiskType</code>配置为SYNC_FLUSH同步刷盘</strong>。这样Broker在收到一条消息后，会先把消息写到磁盘后，再给Producer返回确认响应。这样就算发生了宕机，因为消息已经被写到了磁盘上，所以是不会丢消息的。</p>
<p>如果Broker是由多个节点组成的集群，需要把Broker配置成：至少把消息发送到2个以上的节点，然后再给Producer发送确认响应，这样当某个Broker宕机后，其他的Broker可以替代宕机的Broker，也不会丢消息。</p>
<p><b id='Consumer阶段'>Consumer阶段</b>：</p>
<p>Consumer阶段也是通过<strong>请求-确认</strong>机制来保证消息的可靠传递。</p>
<p>具体来说就是，Consumer从Broker拉取一条消息后，开始执行消费业务的逻辑，执行成功后，向Broker发送消费确认的响应，如果Broker没有收到消费确认的响应，下次拉取的消息还会是同一条，这样就可以保证消息不会在网络传输过程中丢失，也不会因为消费逻辑出错导致数据丢失。</p>
<p><strong>所以在写代码的时候需要注意，不要在收到消息后立刻就发送消费确认，而是应该在执行完消费业务的逻辑之后，再发送消费确认的响应</strong>。</p>
<p>比如应该先把消息保存到数据库之后，再发送消费确认的响应。这样就算保存消息失败了，因为没有执行消费确认的代码，下次拉取的还是这条消息。</p>
<h2 id="⭐如何处理重复消息"><a href="#⭐如何处理重复消息" class="headerlink" title="⭐如何处理重复消息"></a>⭐如何处理重复消息</h2><blockquote>
<p>在MQTT协议里面，有三种传递消息的标准：</p>
<ul>
<li><strong>At most once</strong>：在传递消息时<strong>，消息最多会被发送一次，换一个说法就是，没什么消息可靠性保证，允许丢消息</strong>，一般都是一些对消息可靠性要求不高，可以接收数据少量丢失的场景用。</li>
<li><strong>At least once</strong>：在传递消息时，<strong>消息最少会被发送一次，也就是说，不允许丢消息，但是允许有少量的重复消息出现。</strong></li>
<li><strong>Exactly once</strong>：在传递消息时，<strong>消息只会被发送一次，不允许丢失，也不允许重复</strong>，这个是最高的等级。</li>
</ul>
<p>这三种标准对所有的消息队列都是适用的，现在常用的大部分消息队列提供的标准都是<strong>At most once</strong>，比如RocketMQ、Kafka、RabbitMQ都是这样。也就是说这些消息队列都有重复消息的可能。</p>
</blockquote>
<p><strong>一般解决重复消息的办法是让消费消息的接口具备幂等性</strong>。</p>
<p>幂等常见的实现方式主要有2种方案：<a href="#%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%BA%93%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F%E5%AE%9E%E7%8E%B0%E5%B9%82%E7%AD%89">通过数据库唯一约束实现幂等</a>、<a href="#%E9%80%9A%E8%BF%87%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%B9%82%E7%AD%89">通过前置条件实现幂等</a>。</p>
<blockquote>
<p><strong>幂等(Idempotence)：</strong>一个幂等的方法，使用相同的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的，所以幂等的方法不用担心重复数据会对系统造成影响。</p>
<p>比如：一个方法可以把张三的账户余额设置为100元，执行一次对系统产生的影响是，把张三的账户余额设置成了100元，只要提供的参数100元不变，就算执行多少次，张三的账户余额始终都是100元，这就是一个幂等操作。</p>
</blockquote>
<p>⭐<b id='通过数据库唯一约束实现幂等'>通过数据库唯一约束实现幂等</b>：</p>
<p>可以在表中定义唯一约束来实现幂等，如果入库时发生了唯一键冲突，就表示这条记录已经消费过了，可以直接丢弃。</p>
<p>⭐<b id='通过前置条件实现幂等'>通过前置条件实现幂等</b>：</p>
<p>就是给修改数据设置一个前置条件，如果满足条件就更新数据，否则就拒绝更新。</p>
<p>可以给数据增加一个版本号，每次更新数据前比较一下当前数据的版本号和消息中的版本号是否一致，如果不一致就拒绝更新。更新数据后同时把版本号+1，这样也可以实现幂等。</p>
<h2 id="⭐消息积压如何处理"><a href="#⭐消息积压如何处理" class="headerlink" title="⭐消息积压如何处理"></a>⭐消息积压如何处理</h2><p><strong>一般出现消息积压的主要原因是，生产者发送消息的速度大于消费者处理消息的速度</strong>。</p>
<p>如果只是短时间内有大量的请求发送到后端，这种情况消息积压是正常的现象，因为这些积压的消息会被逐渐消费掉。如果消息队列中一直积压了大量的数据，就需要排查问题了：</p>
<ol>
<li>首先可以排查日志，看是不是消费逻辑报错，导致同一条消息反复消费。</li>
<li>排查消费端和Broker之间的网络状态是否正常</li>
<li>扩容，增加partition和consumer节点，来提高消费端的处理能力。</li>
<li>优化消费逻辑，如果代码执行到某一个步骤就可以确定消息可以被正确处理，就可以提前给Broker发送消费成功的响应，然后把后续流程交给其它线程进行异步处理。</li>
</ol>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议</title>
    <url>/2022/12/08/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="⭐HTTP"><a href="#⭐HTTP" class="headerlink" title="⭐HTTP"></a>⭐HTTP</h2><p><strong>HTTP是一种计算机之间通信的协议，是客户端与服务端之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong>。</p>
<p><strong>HTTP通常跑在TCP/IP协议上，依靠IP协议实现寻址和路由，通过TCP协议实现数据传输，通过DNS协议实现域名查找，通过SSL/TLS协议实现安全通信</strong>。</p>
<p>HTTP和HTML的区别：</p>
<p>HTML是超文本的载体，是一种标记语言，使用各种标签来描述文字、图片、超链接等资源，而且还可以嵌入CSS、JavaScript来实现复杂的动态效果，最终通过浏览器来渲染出可视化的页面。</p>
<h3 id="⭐HTTP调用过程"><a href="#⭐HTTP调用过程" class="headerlink" title="⭐HTTP调用过程"></a>⭐HTTP调用过程</h3><ol>
<li>首先浏览器首先要从URI中提取协议名称和域名，再用DNS解析域名，得到目标IP地址。</li>
<li>然后通过 ”三次握手“ 与目标服务器建立TCP连接。</li>
<li>建立连接后，浏览器会按照HTTP协议规定的格式，通过TCP发送一个 <code>GET / HTTP/1.1</code> 这样的请求报文。</li>
<li>服务器收到请求报文后，会在TCP协议层面回复一个确认消息，表示请求报文已经收到了。然后根据HTTP协议开始解析报文内容。并把请求的资源拼接成HTTP格式的响应报文 <code>HTTP/1.1 200 OK</code>，发送回去。</li>
<li>浏览器收到返回的响应报文之后，也会给服务器发送一个确认消息，表示响应报文已经收到了。</li>
</ol>
<h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><p>HTTP协议的请求报文和响应报文的结构基本差不多，由三部分组成：</p>
<ol>
<li>起始行（Start Line）</li>
<li>报文头（Header）</li>
<li>报文体（Body）</li>
</ol>
<p>报文必须有header，但是可以没有body。</p>
<h4 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h4><p>请求报文中起始行也叫<strong>请求行</strong>，主要包含三部分：</p>
<ol>
<li>请求方式：GET、POST、DELETE、PUT等，表示对资源的操作类型。</li>
<li>请求目标：通常是一个资源路径，表示具体要请求的资源。</li>
<li>版本号：表示使用的HTTP协议版本。</li>
</ol>
<p><code>GET / HTTP/1.1</code>：这个请求行里，”GET” 是请求方式，”/“ 是请求目标，”HTTP/1.1” 是版本号。</p>
<p>响应报文中的起始行叫<strong>状态行</strong>，主要包含三部分：</p>
<ol>
<li>版本号：表示使用的HTTP协议版本。</li>
<li>状态码：表示请求处理的结果，比如200是成功，404是资源未找到，500是服务器错误。</li>
<li>原因：是状态码的补充，是更详细的文字描述。</li>
</ol>
<p><code>HTTP/1.1 200 OK</code>：这个状态行中，”HTTP/1.1” 是版本号、”200” 是状态码、”OK” 是具体的描述。</p>
<h4 id="报文头"><a href="#报文头" class="headerlink" title="报文头"></a>报文头</h4><p>请求报文和响应报文中头部结构基本是一样的，头部字段是key-value的形式，用 “:” 分隔，用换行符表示字段结束。</p>
<p>报文头中可以添加任意自定义的字段，拓展性很强。</p>
<p>需要注意的是：</p>
<ol>
<li>字段名不区分大小写，Host也可以写成host。</li>
<li>字段名不可用包含空格，可以用横杠 “-“ ，不能用下划线 “_”。</li>
<li>字段名后面必须紧跟着冒号 “:”，不能有空格。</li>
</ol>
<h3 id="常用的头字段"><a href="#常用的头字段" class="headerlink" title="常用的头字段"></a>常用的头字段</h3><ul>
<li><p>通用字段：在请求报文和响应报文都可以出现。</p>
<ul>
<li><strong>Date</strong>：表示HTTP报文的创建时间，客户端可以根据这个字段做一些缓存策略。</li>
<li><strong>Via</strong>：用来表示代理服务器身份。每经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾：<code>Via: proxy1,proxy2...</code>。</li>
</ul>
</li>
<li><p>请求字段：只能出现在请求头中，一般是用来说明请求信息。</p>
<ul>
<li><p><strong>Host</strong>：是唯一一个HTTP协议规定的必须出现的字段，主要是告诉服务器这个请求应该由哪个主机来处理。</p>
</li>
<li><p><strong>User-Agent</strong>：用来描述发起这个HTTP请求的客户端的信息，服务器可以根据这个字段来返回最适合这个浏览器的页面。</p>
<blockquote>
<p>但是实际上User-Agent特别混乱，有很多外壳浏览器都自称是 “Chrome”、”FireFox”、”Safari”，企图通过这个字段来伪装，就导致User-Agent变得毫无意义。</p>
<p>也有一些比较友好的爬虫会在User-Agent里用 “spider” 表明自己是爬虫，可以利用这个字段做简单的反爬虫策略。</p>
</blockquote>
</li>
<li><p><strong>Accept</strong>：表示客户端希望接收到什么样的数据。</p>
</li>
</ul>
</li>
<li><p>响应字段：只能出现在响应头中，用来补充响应报文信息。</p>
<ul>
<li><strong>Server</strong>：用来表示当前正在提供服务的软件名称和版本号。因为这会把服务器的一部分信息暴露给外界，如果这个版本正好有一些bug，那黑客就可能会利用这个bug去攻击服务器。所以一般网站的响应头中要么没有这个字段，要么就给一个不相关的信息。</li>
<li><strong>Content-Type</strong>：告诉客户端实际返回了什么类型的数据。</li>
<li><strong>Connection: keep-alive</strong>：表示支持长连接。</li>
</ul>
</li>
<li><p>实体字段：专门用来描述body的额外信息。</p>
<ul>
<li><strong>Content-Length</strong>：表示报文中body的长度，如果没有这个字段，就说明body是不定长的，需要用<strong>chunked</strong>方式分段传输。</li>
</ul>
</li>
</ul>
<h3 id="⭐连接管理"><a href="#⭐连接管理" class="headerlink" title="⭐连接管理"></a>⭐连接管理</h3><p>HTTP/1.1版本之前，采用的是短链接，收到报文后会立刻关闭连接。</p>
<p>短链接的短板很严重，因为在TCP协议中，建立连接需要 “3次握手”，会发送3个数据包，关闭连接是 “4次握手”，会发送4个数据包。而一次请求和响应只需要发送4个数据包（请求、收到请求、响应、收到响应）。</p>
<p>创建和销毁连接的代价比实际传输数据的代价还要高。</p>
<p>在HTTP/1.1版本采用了长连接，客户端向服务器发送一次请求，之后的请求会复用第一次创建的连接。</p>
<blockquote>
<p>服务器一般都会在响应头中添加<strong>Connection: keep-alive</strong>表示支持长连接。</p>
</blockquote>
<p>长连接也是有缺点的，因为服务器必须在内存中保存连接的状态，这就占用了服务器的资源，如果有大量空连接存在，就会浪费很多服务器的资源。</p>
<p>客户端可以在请求头中，添加<strong>Connection: close</strong>字段，通知服务器关闭连接，服务器就会在响应头中也加上这个字段，发送之后就会关闭连接。</p>
<p>服务端一般不会主动关闭连接，也可以使用一些策略：</p>
<p>比如Nginx可以使用 <code>keepalive_timeout</code>指令，设置长连接的超时时间，如果一段时间内没有任何数据收发就会主动断开连接。</p>
<p><b id='队头阻塞'>队头阻塞</b>：</p>
<p>因为HTTP规定了报文必须是 “一发一收”，这就形成了一个先进先出的队列，如果前面的请求处理的很慢，就会阻塞后面的请求。</p>
<p>因为 “请求-应答” 模型不能改，所以队头阻塞无法彻底解决，HTTP通过<a href="#%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5">并发连接</a>来缓解队头阻塞的问题。</p>
<p>但是<a href="#%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5">并发连接</a>压榨出的性能还是跟不上需求，有些公司就开始用<a href="#%E5%9F%9F%E5%90%8D%E5%88%86%E7%89%87">域名分片</a>来提升长连接的数量。</p>
<p><b id='并发连接'>并发连接</b>：就是同时对一个域名发起多个长连接，这种方式也有缺点，如果每个客户端都建立很多连接，并发量就会很高，服务器根本扛不住。HTTP协议建议每个客户端最多并发2个连接。</p>
<p><b id='域名分片'>域名分片</b>：域名分片就是用多个域名指向同一台服务器，这样实际长连接的数量就上去了。</p>
<h3 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h3><ul>
<li><p>拓展性：</p>
<ul>
<li>HTTP协议最开始的时候比较简单，只是规定了报文的基本格式，比如用空格分隔单词，用换行分隔字段，报文内容没有严格的语法限制，可以由开发者随意定制。</li>
<li>后来HTTP协议逐渐增加了请求方法、版本号、状态码、头字段等特性，而body也不只是文本或HTML，而是可以传输图片、视频等任意数据。这些都依赖HTTP的灵活可扩展的特性。</li>
</ul>
</li>
<li><p>可靠性：</p>
<ul>
<li>因为HTTP协议是基于TCP/IP协议的，TCP/IP本身就是一个可靠的传输协议。</li>
</ul>
</li>
<li><p>通用性：</p>
<ul>
<li>HTTP几乎可以传输任何数据，通用性很强。相比于其它协议，比如FTP只能传文件、SMTP只能发邮件、SSH只能远程登录。</li>
</ul>
</li>
<li><p><b id='无状态'>无状态</b>：</p>
<ul>
<li>在HTTP协议中，每次收发报文都是独立的操作，没有任何联系。</li>
</ul>
<blockquote>
<p>状态其实就是客户端或者服务器保存的一些数据或标志位，记录了通信过程中的一些变化信息。</p>
</blockquote>
</li>
</ul>
<h3 id="Cookie机制"><a href="#Cookie机制" class="headerlink" title="Cookie机制"></a>Cookie机制</h3><p>HTTP是<a href="#%E6%97%A0%E7%8A%B6%E6%80%81">无状态</a>的，但是现在很多的应用程序都需要用户登录之后才能执行某些操作，在HTTP协议中每次请求都是独立的操作，服务器就不知道有哪些客户端是已经登陆过的。</p>
<p>Cookie机制就相当于把 “登录状态” 给缓存起来，发送请求的时候再把这些信息发送给服务器，这样服务器就知道这个请求是谁发的了。</p>
<p>Cookie可以理解为就是服务器委托浏览器存储在客户端里的一些数据，这些数据可以用来表示用户的身份信息。</p>
<p><strong>Cookie的工作流程</strong>：</p>
<ol>
<li>浏览器第一次访问服务器的时候，服务器肯定不知道他是谁。服务器就需要创建一个key-value格式的标识，然后放到响应头中的 <strong>Set-Coolie</strong> 这个字段里面，然后发送给浏览器。</li>
<li>浏览器收到响应报文之后，看到响应头中有 <strong>Set-Cookie</strong> 字段，就知道这是服务器给的身份标识，就会把这个标识保存起来，下次再请求的时候就会自动把这个值放到请求头中的 <strong>Cookie</strong> 字段里面，发送给服务器。</li>
<li>第二次请求里面有了 <strong>Cookie</strong> 字段，服务器就可以通过 <strong>Cookie</strong> 字段中的值，识别出用户的身份。</li>
</ol>
<p><strong>Cookie的作用域</strong>：</p>
<p>可以通过 <strong>Domain</strong>和 <strong>Path</strong> 这两个属性指定Cookie所属的域名和路径，让浏览器只发送给特定的URI。</p>
<p>浏览器在发送Cookie前会从URI中提取出host和path部分，然后跟Cookie中的属性对比，如果不相等，就不会在请求头中发送Cookie。</p>
<p>可以用这两个属性为不同的URI分别设置Cookie。Path用一个 “/“ 表示域名下的任意路径都可以用Cookie。</p>
<p><strong>Cookie的安全性</strong>：</p>
<p>在JS脚本中可以用<code>document.cookie</code>来读写Cookie中的数据，这就有可能导致跨站脚本(XSS)攻击。</p>
<p>解决办法有三种：</p>
<ol>
<li><p><strong>HttpOnly</strong>： 告诉浏览器，这个Cookie只能通过HTTP协议传输，这样浏览器就会禁用<code>document.cookie</code>这些脚本。</p>
</li>
<li><p><strong>SameSite</strong>：可以防止”跨站请求伪造”(XSRF)攻击。</p>
<blockquote>
<p>“SameSite=Strict” 可以严格限定Cookie不能跨站发送，</p>
<p>“SameSite=Lax”允许 GET/HEAD安全方法，但是禁止POST跨站发送。</p>
</blockquote>
</li>
<li><p><strong>Secure</strong>：表示这个Cookie只能用HTTPS协议加密传输，明文的HTTP协议会禁止发送，但Cookie本身不是加密的，浏览器中还是以明文的形式存在。</p>
</li>
</ol>
<p><strong>Cookie的应用场景</strong>：</p>
<ol>
<li><p>身份识别：Cookie最常见的应用场景就是识别客户端身份，保存用户登录的信息。</p>
</li>
<li><p>广告跟踪：我们在上网的时候，网页上一般都会有很多广告图片，这些图片点击之后都会跳转到广告商的网站，这些广告就会在Cookie上添加一些信息，这样在上其它网站的时候，别的广告就能用Cookie读出这些信息，分析之后，再推广告。</p>
</li>
</ol>
<p>为了防止滥用Cookie搜集用户信息，互联网组织相继提出了 DNT(Do Not Track) 和 P3P(Platform for Privacy Preference Project)。但实际上作用不大。</p>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><p>浏览器使用HTTP获取资源的成本比较高，就会把一些数据缓存起来，下次请求的时候尽可能的复用，可以节约带宽，加快响应速度。</p>
<p><strong>缓存验证</strong>：</p>
<p>浏览器做缓存使用前还需要去服务器验证是否是最新的，这样的请求成本太高了，所以HTTP协议就定义了一些条件请求字段，专门来检查资源是否过期。</p>
<ol>
<li>服务器第一次在响应头中需要提供 <strong>Last-modified</strong> 和 <strong>ETag</strong> 字段</li>
<li>客户端第二次请求的时候，通过 <strong>if-Modified-Since</strong> 字段带上缓存里的原值，验证资源是否是最新的。</li>
<li>如果资源没有变，服务器会回应“<strong>304 Not Modified</strong>” 表示缓存依然有效，浏览器就可以更新一下有效期，继续使用缓存了。</li>
</ol>
<blockquote>
<p><strong>Last-Modified</strong>：文件最后的修改时间。</p>
<p><strong>ETag</strong>：实体标签(Entity Tag)，是资源的唯一标识。</p>
</blockquote>
<p><strong>服务器对客户端的缓存控制</strong>：</p>
<p>服务器会在响应头中添加 <strong>Cache-Control: max-age=value</strong> 字段，用来标记数据的有效期，max-age的单位是秒，相当于告诉浏览器，这个页面只能缓存这么久。</p>
<ul>
<li><strong>Cache-Control: no_store</strong>：不允许缓存，一般用在一些变化特别频繁的数据。比如秒杀页面。</li>
<li><strong>Cache-Control: no_cache</strong>：可以缓存，但是使用之前需要去服务器验证是否有新的版本。</li>
<li><strong>Cache-Control: must_revalidate</strong>：如果缓存不过期就可以继续使用，如果过期了就需要去服务器验证一下，如果没有新的版本就可以继续使用。</li>
</ul>
<p><strong>服务器对代理服务器的缓存控制</strong>：</p>
<p>客户端和代理服务器是不一样的，客户端的缓存只是用户自己使用，代理的缓存可能会给很多客户端提供服务，所以就需要对它的缓存加一些限制条件。</p>
<p><strong>private</strong>：表示缓存只能在客户端保存，是用户私有的，不能和别人共享。<code>private,max-age=5</code></p>
<p><strong>public</strong>：表示缓存是完全开放的，谁都可以用。<code>public,max-age=5,s-maxage=10</code></p>
<p><strong>proxy-revalidate</strong>：表示客户端可以到存储在代理服务器上的缓存做验证，但如果是私有缓存也需要回源服务器验证。</p>
<p><strong>s-maxage</strong>：用来限定数据可以在代理服务器中生存多久。</p>
<p><strong>no-transform</strong>：表示禁止对数据做一些额外的处理，比如把图片生成png、webp之类的格式。</p>
<p><strong>客户端对源服务器的缓存控制</strong>：</p>
<p>浏览器也可以在请求头中添加 <strong>Cache-Control</strong> 字段。</p>
<p>其实在浏览器中点刷新按钮的时候，浏览器就会在请求头上加一个 “<strong>Cahce-Control: max-age=0</strong>“，服务器看到max-age=0，就会返回最新的数据给浏览器。</p>
<p>浏览器中 “Ctrl+F5” 的强制刷新，就是发了一个 “<strong>Cache-Control: no-cache</strong>“，和 max-age=0含义一样。</p>
<p>浏览器中点击 “前进” 和 “后退” 按钮，通常可以在状态栏中看到 <code>from disk cache</code> 的描述，意思是从磁盘上读取的缓存。</p>
<p><strong>客户端对代理服务器的缓存控制</strong>：</p>
<p><strong>max-stale</strong>：表示如果代理服务器上的缓存过期了也可以接受，但是不能过期太多，必须在指定的时间内。</p>
<p><strong>min-fresh</strong>：表示缓存必须有效，而且必须在指定的时间内依然有效。</p>
<p><strong>only-if-cached</strong>：表示只接受代理缓存的数据，不接受源服务器的响应。</p>
<h3 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h3><p>代理服务就是指，服务本身不生产数据，而是转发上下游的请求和响应。</p>
<p>代理服务器需要用 <strong>Via</strong> 字段表明身份。每经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾：<code>Via: proxy1,proxy2...</code>。</p>
<p>可以通过 <strong>X-Forwarded-For</strong> 和 <strong>X-Real-IP</strong> 来获取客户端的地址：</p>
<p><strong>X-Forwarded-For</strong> 每经过一个代理节点就会在字段里追加代理服务器的IP地址，所以第一个IP地址就是客户端的地址。</p>
<p><strong>X-Real-IP</strong> 就是记录客户端的IP地址，没有中间代理服务器的信息。</p>
<p>有了 <strong>X-Forwarded-For</strong> 等字段，源服务器就可以拿到客户端的信息了，但是对于代理服务器来说并不是最佳方案。因为通过 <strong>X-Forwarded-For</strong> 操作代理信息必须要解析修改HTTP报文，会降低代理的转发性能。并且如果使用HTTPS通信，是无法修改原始报文的，所以就出现了专门的<a href="#%E4%BB%A3%E7%90%86%E5%8D%8F%E8%AE%AE">代理协议</a>。</p>
<p><b id='代理协议'>代理协议</b>：</p>
<p>它其实是在HTTP报文前增加了一行ASCII码文本，相当于又多了一个头。</p>
<p>这行文本的开头必须是 “PROXY” 五个大写字母，然后是 “TCP4” 或者 “TCP6”，表示客户端的IP地址类型，再后面是请求方地址、应答方地址、请求方端口、应答方端口、最后用一个换行符结束。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">PROXY TCP4 192.168.0.1 192.168.0.2 5555 80</span><br></pre></td></tr></table></figure>

<p>这样服务器只需要解析第一行就可以拿到客户端的地址。</p>
<p><strong>代理的作用</strong>：</p>
<ul>
<li><p><strong>负载均衡</strong>：代理最基本的一个功能就是 <strong>负载均衡</strong>，由代理服务器来控制由哪台服务器来响应请求。</p>
</li>
<li><p><strong>健康检查</strong>：使用 “心跳” 机制监控后端服务器，发现有故障就踢出集群，保证服务的可用性。</p>
</li>
<li><p><strong>加密卸载</strong>：对外网使用SSL/TLS加密通信认证，对内网不加密，消除加密成本。</p>
</li>
<li><p><strong>内容缓存</strong>：暂存、复用服务器响应。</p>
</li>
</ul>
<h2 id="⭐HTTPS"><a href="#⭐HTTPS" class="headerlink" title="⭐HTTPS"></a>⭐HTTPS</h2><p>HTTPS为HTTP增加了一些安全特性，默认端口号从80改成443。</p>
<p>之所以会有HTTPS，是因为HTTP的传输过程是透明的，任何人都能在链路中获取并修改报文结构。</p>
<p>比如代理服务器可以作为HTTP通信的中间人，可以修改报文的结构，浏览器和服务器没办法辨别报文的真假。</p>
<p>HTTPS把底层的传输协议换成了<a href="#%E2%AD%90SSL/TLS">SSL/TLS</a>，传输报文调用的都是安全接口。</p>
<h3 id="⭐调用过程"><a href="#⭐调用过程" class="headerlink" title="⭐调用过程"></a>⭐调用过程</h3><ol>
<li>浏览器首先会从URI中提取出协议名称和域名，然后通过DNS解析域名，得到目标的IP地址。</li>
<li>然后通过 “三次握手” 与服务器建立TCP链接。</li>
<li>然后执行TLS握手，建立安全链接。</li>
<li>之后就是和<a href="#%E2%AD%90HTTP%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">HTTP</a>一样的报文收发过程了。</li>
</ol>
<h3 id="HTTPS的性能优化"><a href="#HTTPS的性能优化" class="headerlink" title="HTTPS的性能优化"></a>HTTPS的性能优化</h3><p>HTTPS的连接主要分为两部分，第一个是建立连接时的非对称加密握手，第二个是握手之后的对称加密报文传输。</p>
<p>目前主流的加密算法的性能都很好，所以通常HTTPS比HTTP慢，主要是慢在建立安全连接。</p>
<p>TCP建立连接之后，HTTPS比HTTP多了一个<a href="#TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">TLS握手</a>的环节，不做任何优化的情况下，HTTPS建立连接可能比HTTP慢几百毫秒到几秒。</p>
<p>现在的优化方案也有很多：<a href="#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96">硬件优化</a>、<a href="#%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96">软件优化</a>、<a href="#%E8%AF%81%E4%B9%A6%E4%BC%98%E5%8C%96">证书优化</a>、<a href="#%E4%BC%9A%E8%AF%9D%E5%A4%8D%E7%94%A8">会话复用</a></p>
<p><b id='硬件优化'>硬件优化</b>：</p>
<p>可以选择<strong>SSL加速服务器</strong>，加解密的时候调用它的API，让专门的硬件来做加密和解密，这样可以分摊CPU的运算压力。</p>
<p><b id='软件优化'>软件优化</b>：</p>
<p>把正在使用的软件尽量升级到新的版本，比如把Linux内核从2.x升级到4.x，把nginx从1.6升级到1.1.6。</p>
<p><b id='证书优化'>证书优化</b>：</p>
<p>握手过程中，证书的验证也是一个比较耗时的操作，服务器需要把自己的证书链全发给客户端，客户端接收后再验证。</p>
<p>客户端验证证书其实是个很复杂的过程，首先要根据公钥解密验证证书的签名，还要再去访问证书认证机构，确保证书没有被撤销，这又会产生网络通信。</p>
<p>可以通过OCSP补丁让服务器预先访问证书认证机构获取响应，然后在建立连接的时候和证书一起发送给客户端，这样就可以避免客户端再去连接证书认证机构了。</p>
<p><b id='会话复用'>会话复用</b>：</p>
<p>会话复用分两种：</p>
<p>第一种叫 “Session ID”，就是客户端和服务器建立连接之后，会各自保存一个会话的ID号存在内存里，里面主要存储一些密钥之类的信息，当客户端发送第二次请求的时候，把”Session ID”一起发过去，服务器就在内存中找这个”Session ID”，找到了就直接恢复会话状态，跳过证书验证和密钥交换，可以直接建立通信。</p>
<p>因为服务器必须保存每一个客户端的会话ID，如果用户量很大的话，就会加重服务器的负担，所以又出现了第二种 <strong>会话票证</strong> 的方案。</p>
<p>会话票证（Session Ticket），它有点类似Cookie。服务器加密会话信息之后，发送给客户端，由客户端来存储会话信息。重新连接的时候，客户端再把会话信息发送给服务器，服务器验证有效期之后就可以恢复会话了。</p>
<p>“Session Ticket” 需要使用一个固定的密钥文件来加密，为了防止密钥被破解，密钥文件需要定期更换。</p>
<h3 id="什么是安全"><a href="#什么是安全" class="headerlink" title="什么是安全"></a>什么是安全</h3><p>一般来说，如果通信过程具备了四个特性就可以认为是安全的：</p>
<ol>
<li><a href="#%E6%9C%BA%E5%AF%86%E6%80%A7">机密性</a>：对数据进行加密。</li>
<li><a href="#%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>：是指数据在传输过程中不会被修改。</li>
<li><a href="#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81">身份认证</a>：确认对方的真实身份。</li>
<li><a href="#%E4%B8%8D%E5%8F%AF%E5%90%A6%E8%AE%A4">不可否认</a>：已经发生过的行为不能诋毁。</li>
</ol>
<p><b id='机密性'>机密性</b>：</p>
<p>加密主要分为两大类：<strong>对称加密</strong>和<strong>非对称加密</strong>。</p>
<ul>
<li><p><strong>对称加密</strong>：</p>
<ul>
<li>对称加密就是，加密和解密用的都是同一个密钥，只要保证密钥的安全，就是安全的。</li>
<li>对称加密有一个很大的问题，就是如何把密钥安全的传递给对方，也叫<strong>密钥交换</strong>。所以就出现了<strong>非对称加密</strong>。</li>
</ul>
</li>
<li><p><strong>非对称加密</strong>：</p>
<ul>
<li>非对称加密有两个密钥，一个叫 <strong>公钥</strong>，一个叫 <strong>私钥</strong>。这两个密钥是不一样的，公钥可以公开给任何人，但是私钥必须严格保密。</li>
<li>非对称加密可以解决 <strong>密钥交换</strong>的问题，网站来管理私钥，然后在网上发布公钥，用公钥就可以登录网站，但是密码必须要通过私钥才能破解，黑客没有私钥，所以就没办法破解密码。</li>
<li>非对称加密的问题是，算法的运算速度很慢，于是又有通过<strong>混合加密</strong>的方式解决运算速度的问题。</li>
</ul>
</li>
<li><p><strong>混合加密</strong>：</p>
<ul>
<li><strong>TLS协议中使用的就是混合加密</strong>。</li>
<li>混合加密其实就是<strong>对称加密</strong>和<strong>非对称加密</strong>的混合版本，通过非对称加密解决密钥交换的问题，之后的通信全部使用对称加密。</li>
<li>加密流程：<ol>
<li>服务端生成一对公钥和私钥，并且把公钥发送给客户端。</li>
<li>客户端随机生成一个会话密钥，并且用会话密钥加密需要发送的数据。</li>
<li>客户端再用公钥加密会话密钥，然后把前两步的加密结果发送给服务端</li>
<li>服务端收到数据后，利用自己的私钥解密，可以得到会话密钥。</li>
<li>最后利用会话密钥解密客户端发送的数据。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><b id='完整性'>完整性</b>：</p>
<p>实现完整性的手段主要是摘要算法，比如哈希函数。摘要算法可以把任意长度的数据压缩成一个固定长度的字符串。</p>
<p><strong>只要在原始数据后面附上它的摘要，如果黑客在中间改动了任何内容，摘要就会完全不同，这样就可以保证数据的完整性</strong>。</p>
<p><b id='身份认证'>身份认证</b>和<b id='不可否认'>不可否认</b>：</p>
<p>非对称加密中的私钥，再加上摘要算法，就能实现数字签名。数字签名可以保证身份认证和不可否认。</p>
<p>数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。</p>
<p>数字签名是完全公开的，但是这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再对比源数据的完整性，就像签字盖章一样。</p>
<p>只要客户端和服务器互相交换公钥，就可以用“签名”和“验签”来确认消息的真实性，因为私钥保密，黑客不能伪造签名，就能够保证通信双方的身份。</p>
<p><strong>数字证书和CA</strong>：</p>
<p>这里还有一个问题就是，谁都可以发布公钥，怎么来判断这个公钥是百度的还是黑客的呢？</p>
<p>CA是证书认证机构，由它来给各个公钥签名，确保公钥是可信的。</p>
<p>CA 对公钥的签名认证也是有格式的，会把序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“<strong>数字证书</strong>”（Certificate）。</p>
<h2 id="⭐SSL-TLS"><a href="#⭐SSL-TLS" class="headerlink" title="⭐SSL/TLS"></a>⭐SSL/TLS</h2><p><strong>SSL协议是一个负责加密通信的安全协议，运行在在TCP/IP协议上</strong>。</p>
<p>SSL协议是由网景公司发明的，发展到3.0版本时改名为TLS。</p>
<p><strong>OpenSSL</strong>：是一个开源密码学工具包，支持很多加密算法和协议，很多软件都用它来实现TLS功能，比如Apache、Nginx。</p>
<h3 id="TLS协议的组成"><a href="#TLS协议的组成" class="headerlink" title="TLS协议的组成"></a>TLS协议的组成</h3><p>TLS协议包含几个子协议，可以理解成是负责不同功能的模块：</p>
<ul>
<li><b id='记录协议'>记录协议</b>：规定了TLS收发数据的基本单位：记录，其它子协议都需要通过记录协议发送数据，多个记录可以在一个TCP包中一次发出去，不需要像<a href="#TCP/IP">TCP</a>那样返回确认消息。</li>
<li><b id='报警协议'>报警协议</b>：用来向对方发出警报信息，有点像HTTP协议中的状态码，收到警报后可以选择继续或者终止连接。</li>
<li><b id='握手协议'>握手协议</b>：浏览器和服务器会在握手过程中协商TLS版本号、随机数、密码套件等信息，然后交换证书和密钥，最终双方得到会话密钥。</li>
<li><b id='变更密码协议'>变更密码协议</b>：通知对方，后续的数据会被加密。</li>
</ul>
<h3 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h3><ol>
<li>在建立了TCP连接之后，浏览器首先会发一个 “Client Hello” 消息，里面包含协议的版本信息、支持的密码组件、随机数(用于后续生成会话密钥)。</li>
<li>服务器收到消息之后，会返回一个 “Server Hello” 消息，包含协议的版本号、根据客户端发来的消息选择一个密码组件和服务器生成的随机数。</li>
<li>之后服务器会把证书以及公钥和私钥的签名认证发送给客户端。</li>
<li>客户端拿到服务器的证书后就开始验证证书是否有效，再验证公钥和签名，就可以确认服务器的身份。</li>
<li>客户端再把公钥发送给服务器。</li>
<li>服务器和客户端都拿到两个随机数之后，就用ECDHE算法算出一个新的随机数，然后用这三个随机数生成会话密钥。</li>
<li>最后客户端和服务器把之前发送的数据做个摘要，再加密一下，发送给服务器做验证， 双方都验证加密解密没问题，握手就结束了。</li>
</ol>
<h2 id="⭐TCP-IP"><a href="#⭐TCP-IP" class="headerlink" title="⭐TCP/IP"></a>⭐TCP/IP</h2><p>TCP/IP协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是TCP和IP。其它的还有UDP、ICMP、ARP等。</p>
<p>TCP/IP协议一共有四层：应用层，传输层，网络层，连接层。</p>
<p>TCP和IP分别属于传输层和网络层。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议主要是用来解决寻址和路由的问题，以及如何在两个节点之间传送数据包。</p>
<p>IP协议需要通过IP地址来定位互联网上的每一台计算机。</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP协议位于IP协议之上，基于IP协议提供可靠的字节流形式的通信。</p>
<p>TCP协议是一个有状态的协议，需要先与对方建立连接才能发送数据，并且保证数据不丢失，不重复。数据是连续的。</p>
<blockquote>
<p>UDP协议是无状态的，不用先建立连接就可以发送数据，但不保证数据一定会发送到对方。数据是分散的小数据包，顺序发，乱序收。</p>
</blockquote>
<h3 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h3><ul>
<li><p><strong>第一层叫 ”链接层“ ，负责在底层网络上发送原始数据包，在网卡层面工作，使用mac地址来标记网络中的设备</strong>。</p>
</li>
<li><p><strong>第二层叫 ”网络层“，IP协议就在这一层，因为IP协议规定了IP地址的概念，所以就可以在 ”链接层“的基础上，用IP地址取代mac地址，把许多局域网、广联网连接成一个大的网络，在这个网络查找设备时，只要把IP地址再翻译成mac地址就可以了</strong>。</p>
</li>
<li><p><strong>第三层叫 ”传输层“，TCP协议就在这一层，用来保证数据可靠的传输</strong>。</p>
</li>
<li><p><strong>第四层叫 ”应用层“，应用层是面向具体应用的协议。比如FTP、SMTP、HTTP</strong>。</p>
</li>
</ul>
<blockquote>
<p>层次的顺序是<strong>从下往上</strong>的，第一层也就是最下面的一层。</p>
</blockquote>
<h3 id="OSI网络分层模型"><a href="#OSI网络分层模型" class="headerlink" title="OSI网络分层模型"></a>OSI网络分层模型</h3><p>OSI全称是<strong>开放式系统互联通信参考模型</strong>。</p>
<ul>
<li>第一层是 ”<strong>物理层</strong>“，是网络的物理形式，比如电缆、光纤、网卡之类的设备。</li>
<li>第二层是 ”<strong>数据链路层</strong>“，它基本相当于TCP/IP的链路层。</li>
<li>第三层是 ”<strong>网络层</strong>“，相当于TCP/IP协议中的网际层。</li>
<li>第四层是 ”<strong>传输层</strong>“，相当于TCP/IP协议中的传输层。</li>
<li>第五层是 ”<strong>会话层</strong>“，用来维护网络中的连接状态，保持会话和同步。</li>
<li>第六层是 ”<strong>表示层</strong>“，把数据转换为合适，可理解的语法和语义。</li>
<li>第七层是 ”<strong>应用层</strong>“，面向具体的应用传输数据。</li>
</ul>
<blockquote>
<p><strong>两个分层模型的映射关系</strong>：</p>
<p>第一层：物理层，TCP/IP中无对应</p>
<p>第二层：数据链路层，对应TCP/IP的连接层。</p>
<p>第三层：网络层，对应TCP/IP的网际层。</p>
<p>第四层：传输层，对应TCP/IP的传输层。</p>
<p>第五层、第六层、第七层：对应TCP/IP的应用层。</p>
</blockquote>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>RPC就是把网络通信封装成函数调用的形式，本质上还是网络通信。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN（Content Delivery Network），<strong>主要应用在HTTP协议中的缓存和代理技术，用来代替原网站响应客户端的请求</strong>。</p>
<p><strong>CDN可以缓存网站上的数据，让浏览器的请求在半路上就可以得到响应</strong>。</p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>浏览器的正式名字叫 ”<strong>Web Browser</strong>“，就是<strong>用来查看互联网上的网页资源</strong>。</p>
<p>浏览器的本质是一个HTTP协议中的<strong>请求方</strong>，使用HTTP协议获取网络上的各种资源。</p>
<p>在HTTP协议中，浏览器的角色被称为 ”User Agent“（用户代理），意思是作为访问者的”代理“来发起HTTP请求，一般都简单的称为”客户端“。</p>
<h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>服务器就是HTTP协议中的应答方。</p>
<p>Web服务器包含两个含义：软件和硬件</p>
<p><strong>软件</strong>：就是提供Web服务的应用程序，运行在硬件服务器上，利用硬件能力来处理客户端发来的HTTP请求。</p>
<p><strong>硬件</strong>：就是<strong>物理形式</strong>或者<strong>云形式</strong>的机器，通常是利用反向代理、负载均衡技术组成的集群。</p>
<p>常见的Web服务器有：Apache、Nginx、Jetty、Tomcat等</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p><strong>代理是HTTP协议中，请求方和应答方中间的一个环节，可以转发客户端的请求，也可以转发服务器的应答</strong>。</p>
<p>代理的种类有很多：</p>
<ol>
<li>匿名代理：完全隐匿了被代理的机器，外界只能看到被代理的服务器。</li>
<li>透明代理：在传输过程中是透明的，外界知道代理，也知道客户端。</li>
<li>正向代理：代表客户端向服务端发送请求。</li>
<li>反向代理：代表服务器响应客户端的请求。</li>
</ol>
<p>CDN实际上也是一种代理，它代替服务器响应客户端的请求，通常扮演者透明代理和反向代理的角色。</p>
<p>因为在传输过程中，插入了中间环节，所以在这个环节可以做很多事情：</p>
<ol>
<li>负载均衡：把请求均匀分发到多台机器。</li>
<li>内容缓存：暂存上下行的数据，减轻后端的压力。</li>
<li>安全防护：隐藏IP，使用WAF抵御网络攻击，保护被代理的机器。</li>
<li>数据处理：可以提供压缩、加密等额外功能。</li>
</ol>
<h2 id="HTML-WebService-WAF"><a href="#HTML-WebService-WAF" class="headerlink" title="HTML / WebService / WAF"></a>HTML / WebService / WAF</h2><p><strong>HTML</strong>：</p>
<p><strong>HTML是HTTP协议传输的主要内容之一，它主要用来描述超文本页面，通过各种标签，来定义文字、图片等资源的排版和布局，最终由浏览器渲染出可视化的页面</strong>。</p>
<p>HTML目前主要有两个标准，HTML4和HTML5。</p>
<p><strong>WebService</strong>：</p>
<p><strong>WebService是一种应用服务开发规范，采用的是CS架构，用HTTP协议传输XML或JSON消息，它是一个基于HTTP的服务架构技术</strong>。</p>
<p>因为采用了HTTP协议传输数据，所以在WebService中，服务端和客户端可以采用不同的操作系统和编程语言开发。</p>
<p><strong>WAF</strong>：</p>
<p>WAF是”网络应用防火墙“，用来检测HTTP流量，是防护Web应用安全的技术。</p>
<p><strong>WAF通常在Web服务器之前，可以防止SQL注入、跨站脚本攻击等</strong>。目前应用比较多的一个开源项目是ModSecurity，可以集成进Apache或者Nginx。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发</title>
    <url>/2022/12/08/Java%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h3 id="产生并发安全问题的原因"><a href="#产生并发安全问题的原因" class="headerlink" title="产生并发安全问题的原因"></a>产生并发安全问题的原因</h3><p>在计算机架构中，一直有一个核心矛盾，就是CPU、内存、I/O设备这三者的读写速度差异很大，为了平衡读写速度：</p>
<ol>
<li>给CPU增加了缓存，用来平衡CPU和内存的速度差异，<a href="#CPU%E7%BC%93%E5%AD%98%E5%AF%BC%E8%87%B4%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98">会导致数据可见性问题</a>。</li>
<li>又增加了进程和线程，来复用CPU缓存，用来平衡CPU和I/O设备的速度差异，<a href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98">线程切换会带来原子性问题</a>。</li>
<li>编译程序也会优化指令执行顺序，让程序更加合理的运用缓存，<a href="#%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98">会带来有序性问题</a>。</li>
</ol>
<p>⭐<b id='CPU缓存导致的可见性问题'>CPU缓存导致的可见性问题</b>：</p>
<p>在单核时代，所有线程都运行在同一个CPU上，所有线程操作的都是同一个CPU缓存，一个线程对缓存的读写，对另外一个线程是可见的，所以不会有可见性问题。</p>
<p>在多核时代，每个CPU都有自己的缓存，线程运行在不同的CPU上，这些线程操作的不是同一个CPU缓存，一个线程对变量的写操作对另一个线程就不具备可见性了。</p>
<blockquote>
<p>比如有两个线程对同一个共享变量做+1操作，每个线程循环100次，最终得到的值是100~200之间的随机数，而不是200。</p>
</blockquote>
<p><strong>Java中可以通过<a href="#volatile">volatile</a>关键字禁用CPU缓存，解决可见性问题</strong>。</p>
<blockquote>
<p>也就是说，对于volatile字段的写操作其它线程是可以看到的。</p>
<p>volatile关键字解决不了<code>i++</code>操作，因为还会有原子性问题。</p>
</blockquote>
<p>⭐<b id='线程切换导致的原子性问题'>线程切换导致的原子性问题</b>：</p>
<p>我们写代码时，一行表达式通常会被编译成多条指令，比如<code>i++</code>就需要3条指令才能完成：</p>
<ol>
<li>把<code>i</code>从内存加载到CPU寄存器。</li>
<li>在寄存器中执行+1操作。</li>
<li>最后把结果写回内存。</li>
</ol>
<p>假设有两个线程对共享变量<code>i</code>做<code>+1</code>操作：</p>
<ol>
<li>线程A把<code>i=0</code>加载到寄存器。</li>
<li>然后切换线程，线程B执行完<code>+1</code>操作并写回内存。</li>
<li>线程A会以寄存器中的值为准，<code>+1</code>后并写回内存，最终的结果就是1。</li>
</ol>
<blockquote>
<p>原子性是指：<strong>多个操作的执行过程，不被中断的特性被称为原子性</strong>。</p>
</blockquote>
<p><strong>在Java中可以通过<a href="#Synchronized">Synchronized</a>解决原子性问题</strong>。</p>
<p>⭐<b id='编译优化带来的有序性问题'>编译优化带来的有序性问题</b>：</p>
<p>有一个经典的案例就是，单例模式的<a href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6">双重检测机制</a>。之所以要做双重检测，是因为<code>new</code>关键字经过编译优化后，指令序列可能会发生变化。</p>
<blockquote>
<p>new关键字包含三个指令：</p>
<ol>
<li>分配一块内存</li>
<li>在内存上初始化对象</li>
<li>把内存地址赋值给变量</li>
</ol>
<p>优化之后的指令序列可能是：</p>
<ol>
<li>分配一块内存</li>
<li>把内存地址赋值给变量</li>
<li>在内存上初始化对象</li>
</ol>
<p>假设有两个线程同时获取这个单例对象：</p>
<ol>
<li>线程A发现对象为空，就开始加锁并创建对象，线程A执行<code>new</code>操作的时候，先把内存地址赋值给了成员变量，但是内存中的对象还没有初始化。</li>
<li>然后线程切换，线程B发现对象不为空，就直接返回当前未被初始化的对象，如果调用这个对象的方法，就会出现空指针异常。</li>
</ol>
</blockquote>
<p><strong>对于volatile字段，Java编译器会在该字段的读写操作前后插入内存屏障，来禁止指令重排序</strong>。</p>
<h3 id="⭐线程池"><a href="#⭐线程池" class="headerlink" title="⭐线程池"></a>⭐线程池</h3><p>线程池可以重复利用已创建的线程，降低线程创建和销毁造成的消耗。</p>
<p>当收到请求时，不需要等待线程创建就能立即执行。</p>
<p>线程池的逻辑是这样的：</p>
<ol>
<li>线程池内部会维护一个任务队列。</li>
<li>在收到一个任务后，首先会判断当前线程池中的任务数量是否小于核心线程的数量，如果小于的话，创建一个线程，开始执行任务。</li>
<li>如果任务数量大于或者等于核心线程数，就会把新的任务放到等待队列中。</li>
<li>如果等待队列满了，就会开始创建新的线程，如果创建的线程数量达到最大线程数的配置之后，就会触发拒绝策略（默认是抛异常）。</li>
<li>如果创建线程失败，也会开始执行拒绝策略。</li>
</ol>
<blockquote>
<p>实际上，优先把任务放到队列中，比较适合CPU密集型的任务，因为CPU密集型的任务执行时，CPU占用率会比较高，只需要创建和CPU核心数差不多的线程数量就好，线程多了反而会造成上下文切换，降低执行效率。</p>
<p>但是我们平时开发的Web项目，通常都属于IO密集型，所以Tomcat线程池就是当线程数超过核心线程数之后，会优先创建线程，直到超过最大线程数，才会把请求放到等待队列。</p>
<p>这样是更适合IO密集型场景的。</p>
</blockquote>
<h4 id="⭐核心参数"><a href="#⭐核心参数" class="headerlink" title="⭐核心参数"></a>⭐核心参数</h4><ul>
<li><p><strong>corePoolSize</strong>：核心线程数，线程池中最少的线程数量。</p>
</li>
<li><p><strong>maximumPoolSize</strong>：表示线程池最大线程数，如果线程池的核心线程都在运行中，并且等待队列也满了之后，就会开始创建额外的线程，额外线程的数量最多不会超过这个参数指定的数量。</p>
</li>
<li><p><strong>workQueue</strong>：等待队列，如果线程池收到的任务大于核心线程的数量，额外的任务就会放到这个等待队列中。</p>
</li>
<li><p><strong>keepAliveTime</strong>：如果一个线程在这个参数指定的时间内都没有收到新的任务，并且线程池中的线程数量大于核心线程数，这些多余的线程就会被回收掉。</p>
</li>
<li><p><strong>unit</strong>：keepAliveTime 参数的时间单位。</p>
</li>
<li><p><strong>threadFactory</strong>：ThreadFactory是一个接口，可以重写<code>newThread()</code>方法自定义创建线程的逻辑。</p>
</li>
<li><p><strong>handler</strong>：如果线程池中核心线程都在运行的时候，会把新的任务放到等待队列中，如果等待队列满了之后，就会开始创建新的线程，如果创建的线程数量达到最大线程数的配置之后，就会触发拒绝策略了。</p>
<blockquote>
<p><strong>线程池提供了4种拒绝策略</strong>：</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy：抛出异常来拒绝处理新任务，这是默认的拒绝策略。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：让提交任务的线程来执行这个任务。</li>
<li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：把最早进入等待队列的任务丢弃掉。</li>
<li>也可以通过实现<code>RejectedExecutionHandler</code>接口，重写<code>rejectedExecution</code>方法来自定义拒绝策略。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="⭐线程池大小如何定义"><a href="#⭐线程池大小如何定义" class="headerlink" title="⭐线程池大小如何定义"></a>⭐线程池大小如何定义</h4><p>线程池的大小，要看具体的应用场景。</p>
<p>CPU密集型：</p>
<blockquote>
<p>如果大部分功能都是纯CPU计算，那就是CPU密集型程序。比如对内存中的数据做大量运算。</p>
</blockquote>
<p>对于CPU密集型应用，一个4核的CPU，每个核心对应一个线程，理论上创建4个线程就可以了，创建再多的线程只会增加线程切换的成本。所以<strong>线程的数量 = CPU核心数</strong>就是合适的。</p>
<p>不过线程有些时候可能会因为一些原因进入阻塞状态，所以可以多设置一个线程，保证CPU的利用率。<strong>线程数量可以设置为CPU核心数+1</strong>。</p>
<p>I/O密集型：</p>
<blockquote>
<p>CPU计算和I/O操作交叉执行，但是因为I/O操作耗时比较长，所以这种场景一般称为I/O密集型计算。</p>
<p>（网络、磁盘、数据库都属于I/O操作）</p>
</blockquote>
<p>一个单核计算机，假设我们需要从表1中查询数据，计算完成后，再写入到表2中。假设有A、B、C三个线程：</p>
<ol>
<li>线程A查询数据（I/O操作），线程B和线程C阻塞；（I/O设备利用率100%，CPU利用率0%）</li>
<li>线程A获取到数据后，在内存中计算（CPU操作），线程B开始查询数据（I/O操作）。（I/O设备利用率100%，CPU利用率100%）</li>
<li>线程A计算完成后，继续执行最后的写表操作（I/O操作），线程B获取到数据后开始计算（CPU操作），线程C查询数据（I/O操作）。（I/O设备利用率100%，CPU利用率100%）</li>
<li><strong>线程数量可以设置为3</strong>.</li>
</ol>
<p>**对于多核CPU最佳线程数 = CPU核心数 * [1 + (I/O耗时 / CPU耗时)]**。</p>
<blockquote>
<p>对于4核8线程这种超线程技术，是指一个CPU物理核心包含两个逻辑核心，这两个逻辑核心也还是会存在竞争，所以这两个逻辑核心并不能完全并行运行。所以不管是4还是8都不一定是最合适的，还需要根据具体的测试结果进行调整。</p>
</blockquote>
<h4 id="⭐如何获取执行结果"><a href="#⭐如何获取执行结果" class="headerlink" title="⭐如何获取执行结果"></a>⭐如何获取执行结果</h4><p>ThreadPoolExecutor提供了3个submit()方法配合FutureTask工具类来支持获得线程池的返回值。</p>
<p>这三个submit()方法的返回值都是Future接口，Future接口提供了2个get()方法用来获取返回值（一个包含超时机制，一个没有超时机制）。</p>
<p>这两个get()方法都是阻塞的，如果任务没有执行完，会导致调用方被阻塞，直到任务完成或者超时才会被唤醒。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> ThreadPoolExecutor.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">// 创建结果引用</span></span><br><span class="line"> <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line"> result.setData(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 提交任务</span></span><br><span class="line"> Future&lt;Result&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(result), result);</span><br><span class="line"> <span class="comment">// 获取线程池返回值</span></span><br><span class="line"> <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> future.get();</span><br><span class="line"> res.getData();	<span class="comment">// lisi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Result result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(Result result)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.result = result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		result.setData(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>Java中的线程一共有5种状态，分别是：</p>
<ol>
<li><p><strong>初始化状态</strong>：指的是线程已经被创建了，但是还没有被分配CPU执行，是在编程语言层面被创建，在操作系统层面还没被创建。</p>
</li>
<li><p><strong>可运行状态</strong>：指的是线程在操作系统层面线程已经被创建出来了，可以分配给CPU执行。</p>
</li>
<li><p><strong>运行状态</strong>：当有空闲的CPU时，操作系统就会把CPU分配给可运行状态的线程，被分配的线程就会变成运行状态。</p>
</li>
<li><p><strong>阻塞状态</strong>：运行状态中的线程，如果调用了一个阻塞API，线程就会变为阻塞状态，并且让出CPU的使用权。</p>
</li>
<li><p><strong>终止状态</strong>：线程执行完run()方法，会自动进入终止状态。也可以手动调用<code>stop()</code> 或者 <code>interrupt() </code>方法终止一个线程。</p>
<blockquote>
<p><code>stop()</code> 和 <code>interrupt() </code>方法的区别：</p>
<ul>
<li><p><code>stop()</code>方法会立刻杀死线程，线程持有的锁也会不释放，那其它线程就再也没有机会获得这个锁了。</p>
<ul>
<li>类似的方法还有<code>suspend()</code>和<code>resume()</code>。</li>
</ul>
</li>
<li><p><code>interrupt()</code>只会通知线程，线程还可以继续执行后续的操作。</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="阻塞线程的方式"><a href="#阻塞线程的方式" class="headerlink" title="阻塞线程的方式"></a>阻塞线程的方式</h3><ul>
<li>**sleep()**：<ul>
<li>sleep方法可以指定一个以毫秒为单位的时间，线程在这个时间内会进入阻塞状态。</li>
<li><strong>不会释放锁</strong>，会让出CPU时间片，等待再次调度。</li>
</ul>
</li>
<li>**yield()**：<ul>
<li>yield方法会让出cpu时间片，但是线程还是会处于可执行的状态，当下次获得时间片之后还是会正常执行。</li>
<li><strong>不会释放锁</strong>。</li>
</ul>
</li>
<li>**wait()**：<ul>
<li>wait方法会使线程进入阻塞状态，wait方法可以指定一个以毫秒为单位的时间，时间到了之后会自动唤醒。如果不指定时间则需要通过notify()或者notifyAll()方法来唤醒，否则会一直阻塞。</li>
<li><strong>会释放锁</strong>，会让出CPU时间片，等待再次调度。</li>
</ul>
</li>
<li>**join()**：<ul>
<li>当线程A调用线程B的join方法，线程A就会进入阻塞状态，直到线程B运行结束，线程A才会进入可执行状态。</li>
<li>底层还是调用wait方法，<strong>会释放锁</strong></li>
</ul>
</li>
<li>**notify()和notifyAll()**：<ul>
<li>notify()会随机唤醒一个等待中的线程，notifyAll()会唤醒所有等待中的线程。但是notify()有可能导致一些线程无法直接被唤醒。</li>
<li>假设有A、B两个资源，线程1申请到了A、线程2申请到了B、线程3再次申请A会进入等待队列，线程4申请B会进入等待队列。这个时候等待队列中有3、4两个线程。线程1归还资源后，如果用notify()来通知等待队列中的线程，有可能被通知的线程是4，但是线程4申请的是资源B，所以还会继续等待。</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>产生死锁的4个条件</strong>：</p>
<ol>
<li>互斥：共享资源只能被一个线程占用。</li>
<li>占有且等待：线程A占有资源A，在等待资源B的时候，不释放资源A。</li>
<li>不可抢占：其它线程不能抢占线程A已经占有的资源。</li>
<li>循环等待：线程A等待线程B占有的资源，线程B等待线程A占有的资源。</li>
</ol>
<p><strong>预防死锁</strong>：</p>
<p>对资源进行加锁时，可以先对资源排序，然后按照顺序加锁。这样就不会出现线程1占用资源A，线程2占用资源B，双方都等待对方释放资源了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">	<span class="comment">// 转账</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">		<span class="type">Account</span> <span class="variable">left</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">		<span class="type">Account</span> <span class="variable">right</span> <span class="operator">=</span> target;</span><br><span class="line">        <span class="comment">// 根据id对账户进行排序</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.getId() &gt; target.getId()) &#123;</span><br><span class="line">			right = target;</span><br><span class="line">			left = <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">synchronized</span>(left) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(right) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; money) &#123;</span><br><span class="line">					<span class="built_in">this</span>.balance -= money;</span><br><span class="line">					target.balance += money;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>等待-通知优化循环等待</strong>：</p>
<p><strong>可以通过synchronized关键字配合wait()、notify()、notifyAll()这三个方法实现等待通知机制</strong>。</p>
<p>就是在synchronized代码块中，判断条件如果不满足，就调用wait()方法让当前线程进入等待状态。其他线程执行完毕之后，调用notifyAll()方法唤醒等待队列中的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> List&lt;Object&gt; als = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> 	<span class="comment">// 一次性申请所有资源</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Object from, Object to)</span>&#123;</span><br><span class="line"> 		<span class="comment">// 经典写法</span></span><br><span class="line"> 		<span class="keyword">while</span>(als.contains(from) || als.contains(to))&#123;</span><br><span class="line"> 			<span class="keyword">try</span> &#123;</span><br><span class="line"> 				wait();</span><br><span class="line"> 			&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"> 			</span><br><span class="line"> 			&#125;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	als.add(from);</span><br><span class="line">		als.add(to);</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="comment">// 归还资源</span></span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Object from, Object to)</span>&#123;</span><br><span class="line">		 als.remove(from);</span><br><span class="line">		 als.remove(to);</span><br><span class="line">		 notifyAll();</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Allocator</span> <span class="variable">allocator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Allocator</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        allocator.apply(o1, o2);</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        allocator.free(o1, o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="⭐锁定义"><a href="#⭐锁定义" class="headerlink" title="⭐锁定义"></a>⭐锁定义</h3><h4 id="⭐乐观锁-悲观锁"><a href="#⭐乐观锁-悲观锁" class="headerlink" title="⭐乐观锁 / 悲观锁"></a>⭐<b id='乐观锁'>乐观锁 </b>/ <b id='悲观锁'>悲观锁</b></h4><p><strong>乐观锁</strong>：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断数据是否发生变更。如果数据已经被其他线程更新，则报错或者重试。<strong>乐观锁适合读多写少操作</strong>。</p>
<blockquote>
<p>乐观锁在Java中是通过使用无锁编程来实现，通常采用的是<a href="#CAS">CAS</a>算法，Java原子类中的递增操作就通过<a href="#CAS">CAS</a>实现的。</p>
</blockquote>
<p><strong>悲观锁</strong>：悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p>
<p><strong>悲观锁适合写操作多的场景</strong>。</p>
<blockquote>
<p><a href="#synchronized">synchronized</a>关键字和Lock接口的实现类都是悲观锁。</p>
</blockquote>
<h4 id="⭐偏向锁"><a href="#⭐偏向锁" class="headerlink" title="⭐偏向锁"></a>⭐<b id='偏向锁'>偏向锁</b></h4><p>偏向锁认为，同一把锁只会被一个线程多次获得，不存在多线程竞争。</p>
<p>在JVM中，当一个线程获取偏向锁时，会在对象头中的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>中存储当前线程的ID，在加锁和解锁时，只需要判断<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>中是否保存着当前线程的ID就可以了。</p>
<h4 id="⭐轻量级锁"><a href="#⭐轻量级锁" class="headerlink" title="⭐轻量级锁"></a>⭐<b id='轻量级锁'>轻量级锁</b></h4><p>当<a href="#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>被多个线程访问时，就会升级为轻量级锁。</p>
<p>加锁时，JVM会在当前线程的栈帧分配一块空间，用来保存锁记录（Lock Record），然后把锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>拷贝到锁记录中。</p>
<p>然后通过<a href="#CAS">CAS</a>操作，把<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>替换为锁记录的内存地址：</p>
<ul>
<li>如果更新成功，就说明加锁成功。</li>
<li>如果更新失败，就说明有其它线程获取当前锁，Java虚拟机就会把这把锁升级为<a href="#synchronized-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">重量级锁</a>，并阻塞当前线程。</li>
</ul>
<p>解锁时，Java虚拟机会通过<a href="#CAS">CAS</a>操作，比较锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>是否是锁记录的地址。</p>
<ul>
<li>如果是，就把<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>替换为锁记录中的值，也就是锁对象原本的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>。这样就成功释放锁了。</li>
<li>如果不是，说明锁已经升级为<a href="#synchronized-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">重量级锁</a>了。</li>
</ul>
<h4 id="⭐重量级锁"><a href="#⭐重量级锁" class="headerlink" title="⭐重量级锁"></a>⭐<b id='重量级锁'>重量级锁</b></h4><p>重量级锁会阻塞所有加锁失败的线程，解锁时再唤醒这些线程。</p>
<h4 id="⭐自旋锁-适应性自旋锁"><a href="#⭐自旋锁-适应性自旋锁" class="headerlink" title="⭐自旋锁 / 适应性自旋锁"></a>⭐<b id='自旋锁'>自旋锁</b> / <b id='适应性自旋锁'>适应性自旋锁</b></h4><p><strong>自旋锁</strong>：因为阻塞或者唤醒一个Java线程，需要操作系统切换CPU状态来完成，如果代码中的逻辑比较简单，状态转换消耗的时间有可能比代码执行的时间还要长。</p>
<p>所以为了减少减少线程切换带来的消耗，可以让没有获取到锁的线程去执行一个无意义的循环。如果循环结束后锁已经被释放了，当前线程就可以避免切换线程的开销。</p>
<p>自旋锁也是有缺点的，自旋虽然可以避免切换线程的开销，但是会占用处理器时间。如果锁被占用的时间很短，自旋锁的效果就很好，否则自旋只会白白浪费处理器资源。所以自旋一定要有次数限制（默认是10次，可以通过<code>-XX:PreBlockSpin</code>修改）。</p>
<p><strong>适应性自旋锁</strong>：</p>
<p>JDK1.6引入了适应性自旋锁，适应性自旋表示自旋的次数不固定，而是根据以往能否通过自旋获取到锁来决定。</p>
<p>如果通过自旋获取到锁的概率非常高，Java虚拟机就会允许自旋更长的时间。</p>
<p>如果某个锁只有很少的次数能通过自旋获取到，Java虚拟机就会减少自旋时间或者跳过自旋，直接阻塞线程。</p>
<h4 id="⭐可重入锁-不可重入锁"><a href="#⭐可重入锁-不可重入锁" class="headerlink" title="⭐可重入锁 / 不可重入锁"></a>⭐<b id='可重入锁'>可重入锁</b> / <b id='不可重入锁'>不可重入锁</b></h4><p>如果一个类中有多个synchronized方法，这些方法之间相互调用，就会对同一把锁重复加锁。</p>
<p>如果是可重入锁，就可以正常加锁。</p>
<p>如果是不可重入锁，就会产生死锁。</p>
<blockquote>
<p>ReentrantLock 和 synchronized 都是可重入锁。</p>
</blockquote>
<h4 id="⭐公平锁-非公平锁"><a href="#⭐公平锁-非公平锁" class="headerlink" title="⭐公平锁 / 非公平锁"></a>⭐<b id='公平锁'>公平锁</b> / <b id='非公平锁'>非公平锁</b></h4><p><strong>公平锁</strong>：</p>
<p>公平锁是指多个线程直接在队列中排队，队列中第一个线程才能获得锁。</p>
<p>公平锁的优点是每个线程都能获取到锁，不会饿死。</p>
<p>缺点是效率比非公平锁低，队列中除了第一个线程都会阻塞，CPU唤醒线程的开销会很大。</p>
<blockquote>
<p>ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认是非公平锁。传入true就是公平锁。</p>
</blockquote>
<p><strong>非公平锁</strong>：</p>
<p>非公平锁是指多个线程加锁时，直接尝试获取锁，获取不到的才会进入等待队列。如果某一个线程尝试获取锁时，锁刚好可用，这个线程可以直接获取到锁。</p>
<p>非公平锁的优点是可以减少唤醒线程的开销，因为线程有几率不阻塞直接获取到锁。</p>
<p>缺点是等待队列中的线程可能会饿死，或者要等很久才能获取到锁。</p>
<blockquote>
<p><a href="#synchronized">synchronized</a>是非公平锁，ReentantLock默认也是非公平锁。</p>
</blockquote>
<h4 id="⭐独占锁-共享锁"><a href="#⭐独占锁-共享锁" class="headerlink" title="⭐独占锁 / 共享锁"></a>⭐<b id='独占锁'>独占锁</b> / <b id='共享锁'>共享锁</b></h4><p><strong>独占锁</strong>：独占锁只能被一个线程持有。</p>
<blockquote>
<p><a href="#synchronized">synchronized</a>和JUC中Lock接口的实现类都是互斥锁。</p>
</blockquote>
<p><strong>共享锁</strong>：共享锁可以被多个线程持有，共享锁与独占锁之间是互斥的。获得共享锁的线程只能读数据，不能修改数据。</p>
<blockquote>
<p><code>ReentrantReadWriteLock</code>类中有两把锁：<code>ReadLock</code>和<code>WriteLock</code>，可以分别加读锁和写锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K, V&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">	<span class="comment">// 读锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">	<span class="comment">// 写锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果缓存不存在，就加载数据到缓存中</span></span><br><span class="line">	<span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">		<span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 加读锁</span></span><br><span class="line">         readLock.lock();</span><br><span class="line">         value = cache.get(key);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         readLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 加写锁</span></span><br><span class="line">         writeLock.lock();</span><br><span class="line">         <span class="comment">// 查询数据库</span></span><br><span class="line">         value = fromDB(key);</span><br><span class="line">         cache.put(key, value);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         writeLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐CAS"><a href="#⭐CAS" class="headerlink" title="⭐CAS"></a>⭐<b id='CAS'>CAS</b></h3><p>CAS全称 Compare And Swap（比较并替换），是一种无锁算法。</p>
<blockquote>
<p>单核 CPU 和多核 CPU 下都能够保证的原子性。</p>
<p>在多核CPU环境下：</p>
<ol>
<li>通过总线锁，保证修改操作的互斥性</li>
<li>通过缓存一致性协议，保证CPU缓存中的值对其它核心可见</li>
<li>通过内存屏障，保证多线程下的有序性</li>
</ol>
</blockquote>
<p>CAS算法需要三个参数：</p>
<ul>
<li>需要修改的原值</li>
<li>要比较的期望值</li>
<li>要写入的新值</li>
</ul>
<p>当 “原值” 等于 “期望值” 时，通过原子操作用 “新值” 替换 “原值”，否则就重新执行CAS流程。</p>
<p>CAS虽然很高效，但是也有两个问题：</p>
<ul>
<li><p><strong>ABA问题</strong>：CAS会检查 “原值” 是否发生变化，如果原来是A，后来变成了B，然后又变成了A，那么CAS进行检查的时候会发现 “原值” 没有变化过，但实际上是有变化的。</p>
<p>解决思路就是给数据添加版本号，每次更新数据都把版本号加一。</p>
<blockquote>
<p>JDK1.5提供了<code>AtomicStampedReference</code>类来解决ABA问题，具体的逻辑封装在<code>compareAndSet()</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是原值，第二个参数是版本号</span></span><br><span class="line">AtomicStampedReference&lt;String&gt; asf = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;String&gt;(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是期望值，第二个参数是新值，第三个参数是期望版本号，第四个参数是新版本号</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> asf.compareAndSet(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>只能保证单个变量的原子操作</strong>，多个共享变量无法保证原子操作。</p>
<blockquote>
<p>JDK1.5提供了<code>AtomicReference</code>类来保证对象之间的原子性，可以把多个变量放在一个对象里面进行原子操作。</p>
</blockquote>
</li>
</ul>
<h3 id="⭐JUC常用原子类"><a href="#⭐JUC常用原子类" class="headerlink" title="⭐JUC常用原子类"></a>⭐JUC常用原子类</h3><p><strong>基本类型</strong>：</p>
<p>AtomicInteger、AtomicLong、AtomicBoolean。</p>
<p>主要方法：</p>
<ul>
<li><code>getAndIncrement()</code>：原子化的<code>i++</code>。</li>
<li><code>getAndDecrement()</code>：原子化的<code>i--</code>。</li>
<li><code>incrementAndGet()</code>：原子化的<code>++i</code>。</li>
<li><code>decrementAndGet()</code>：原子化的<code>--i</code>。</li>
<li><code>compareAndSet()</code>：CAS操作，返回是否成功。</li>
</ul>
<p><strong>引用类型</strong>：</p>
<p>AtomicReference、AtomicStampedReference、AtomicMarkableReference。可以实现引用类型对象属性的原子化更新。</p>
<p>主要方法：</p>
<ul>
<li><code>compareAndSet()</code>：CAS操作，返回是否成功。</li>
</ul>
<p><strong>数组</strong>：</p>
<p>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray。可以实现原子化更新数组中的每一个元素。</p>
<p>主要方法：</p>
<ul>
<li><code>compareAndSet()</code>：CAS操作，返回是否成功。</li>
</ul>
<p><strong>累加器</strong>：</p>
<p>DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder。只能用来执行累加操作，相比原子化的基本类型，计算速度更快，但是不支持<code>compareAndSet()</code>方法。</p>
<p>主要方法：</p>
<ul>
<li><code>increment()</code>：累加。</li>
<li><code>decrement()</code>：减少。</li>
</ul>
<h3 id="⭐AQS"><a href="#⭐AQS" class="headerlink" title="⭐AQS"></a>⭐AQS</h3><p>AbstractQueuedSynchronizer（AQS）：它是AQS体系的核心基类，实现了锁的基本结构，内部的数据结构是链表，它继承自AOS。</p>
<blockquote>
<p>AbstractOwnableSynchronizer（AOS）：用来记录锁当前的持有者。</p>
</blockquote>
<p>ReentrantLock是锁的具体实现，它继承自Lock抽象类，用内部类Sync继承AQS，所以ReentrantLock具体的锁实现都是委托Sync完成的。</p>
<blockquote>
<p>Sync有两个子类，分别是FairSync（公平锁）和NonfairSync（非公平锁）</p>
</blockquote>
<p><strong>获取锁</strong>：</p>
<p>调用<code>tryLock()</code>方法获取锁时，会委托给Sync来处理。</p>
<p>首先会判断当前的锁状态，state如果等于0，表示当前锁没有被占用，公平锁和非公平锁会有不同的处理逻辑：</p>
<ul>
<li>如果是公平锁：需要先判断等待队列中有没有其它线程在排队。<ul>
<li>如果有，就返回false并进入等待队列。</li>
<li>如果没有，就返回true，然后通过<a href="#CAS">CAS</a>操作更新state，如果更新成功，说明成功获取锁，就设置锁的拥有者为当前线程。否则就进入等待队列。</li>
</ul>
</li>
<li>如果是非公平锁：通过<a href="#CAS">CAS</a>操作更新state。<ul>
<li>如果更新成功，说明成功获取锁，就设置锁的拥有者为当前线程。</li>
<li>如果更新失败，就直接进入等待队列。</li>
</ul>
</li>
</ul>
<p>如果state不等于0，说明锁已经被占用，会判断当前线程是不是锁的持有者：</p>
<ul>
<li>如果是，就通过<a href="#CAS">CAS</a>更新state。</li>
<li>如果不是，就进入等待队列。</li>
</ul>
<p><strong>释放锁</strong>：</p>
<p>调用<code>unlock()</code>方法释放锁时，会委托给Sync来处理。</p>
<p>释放锁主要包含这样几个步骤：</p>
<ol>
<li>判断当前线程释放是锁的持有者，如果不是则抛异常。</li>
<li>判断state是否为0，如果为0，表示锁已释放，需要唤醒等待队列中的线程。</li>
</ol>
<h3 id="⭐ThreadLocal"><a href="#⭐ThreadLocal" class="headerlink" title="⭐ThreadLocal"></a>⭐<b id='ThreadLocal'>ThreadLocal</b></h3><p>比如MVC架构的Web应用，在Service层无法直接获取HttpServletRequest，需要通过Controller以参数的形式传递进来。可以用ThreadLocal解决这种过度传参的问题。</p>
<blockquote>
<p>可以在拦截器中把HttpServletRequest放到ThreadLocal中，Service层就可以直接获取了。需要注意的是要在拦截器中请求结束的回调方法中清除ThreadLocal，不然可能会导致<a href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄漏</a>。</p>
</blockquote>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>Thread内部维护了一个ThreadLocalMap对象，ThreadLocalMap是ThreadLocal中的内部类，</p>
<p>ThreadLocal只是一个代理类，内部并不保存任何数据。</p>
<p>ThreadLocalMap内部用一个Entry数组保存数据，Entry对ThreadLocal是弱引用。</p>
<ul>
<li><p>ThreadLocalMap保存数据的时候，会根据ThreadLocal对象的hash值定位数组的位置，所以也会有Hash冲突：</p>
<ul>
<li><p>在遇到Hash冲突时，如果是同一个ThreadLocal则替换Entry中的value，否则就直接寻找下一个空闲的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">		ThreadLocal&lt;?&gt; k = e.get();	<span class="comment">// 这里的get()方法是Reference类中的</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;	<span class="comment">// 如果是同一个ThreadLocal，就直接替换Value</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;	<span class="comment">// 如果目标位置为空，则插入数据，否则继续找下一个位置</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ThreadLocalMap获取数据的时候，也是根据ThreadLocal对象的hash值获取数组中对应的数据，获取到数据之后还需要判断是否是同一个ThreadLocal，如果不是就继续找下一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">	<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key) &#123;	<span class="comment">// 判断是否是同一个ThreadLocal</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// getEntryAfterMiss(): 会遍历ThreadLocalMap中所有Entry，直到找到ThreadLocal相同的元素</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>之所以要用Entry数组保存数据，是因为一个Thread可以创建多个ThreadLocal，这些ThreadLocal保存的数据只会放在同一个ThreadLocalMap中。</p>
</blockquote>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a><b id='ThreadLocal内存泄漏'>内存泄漏</b></h4><p>线程池中的线程可能会一直存活下去，这就意味着Thread持有的ThreadLocalMap不会被回收，然后ThreadLocalMap中的Entry对ThreadLocal是<a href="#%E5%BC%B1%E5%BC%95%E7%94%A8">弱引用</a>，所以ThreadLocal是可以被回收掉的。但是Entry对Value是<a href="#%E5%BC%BA%E5%BC%95%E7%94%A8">强引用</a>的，所以Value无法被回收也无法被访问到，就会导致内存泄漏。</p>
<p>所以在写代码时，使用完ThreadLocal一定要在finally代码块中调用<code>remove()</code>方法。</p>
<h3 id="⭐ReentrantLock"><a href="#⭐ReentrantLock" class="headerlink" title="⭐ReentrantLock"></a>⭐<b id='ReentrantLock'>ReentrantLock</b></h3><p>ReentrantLock继承自Lock接口，它是可重入锁。</p>
<p>可以通过构造函数设置为公平锁，默认是非公平锁。</p>
<ul>
<li><code>lock()</code>：获取锁，如果锁被其它线程持有，则阻塞当前线程，直到获取到锁。</li>
<li><code>tryLock()</code>：尝试获取锁，如果获取到锁则返回true，否则返回false。不会阻塞当前线程。</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">	<span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			value++;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐ReentrantReadWriteLock"><a href="#⭐ReentrantReadWriteLock" class="headerlink" title="⭐ReentrantReadWriteLock"></a>⭐<b id='ReentrantReadWriteLock'>ReentrantReadWriteLock</b></h3><p>ReentrantReadWriteLock实现了ReadWriteLock接口，它是支持可重入的读写锁。</p>
<p>可以通过构造函数设置为公平锁，默认是非公平锁。</p>
<p>ReadWriteLock不支持锁升级：不释放读锁的前提下，无法再获取写锁。</p>
<p>ReadWriteLock支持锁降级：不释放写锁的前提下，可以再次获取读锁。</p>
<blockquote>
<p>常用写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K, V&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">	<span class="comment">// 读锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">	<span class="comment">// 写锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果缓存不存在，就加载数据到缓存中</span></span><br><span class="line">	<span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">		<span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 加读锁</span></span><br><span class="line">         readLock.lock();</span><br><span class="line">         value = cache.get(key);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         readLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 加写锁</span></span><br><span class="line">         writeLock.lock();</span><br><span class="line">         <span class="comment">// 查询数据库</span></span><br><span class="line">         value = fromDB(key);</span><br><span class="line">         cache.put(key, value);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         writeLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐StampedLock"><a href="#⭐StampedLock" class="headerlink" title="⭐StampedLock"></a>⭐<b id='StampedLock'>StampedLock</b></h3><p>StampedLock是JDK1.8提供的，它的性能比ReadWriteLock（读写锁）更好。但是StampedLock不支持重入。</p>
<p>StampedLock支持三种锁模式：<strong>写锁</strong>、<strong>悲观读锁</strong>、<strong>乐观读</strong>。</p>
<ul>
<li>它允许多个线程同时获取悲观读锁，只允许一个线程获取写锁，写锁和悲观读锁是互斥的。</li>
<li>当多个线程同时进行乐观读时，是允许一个线程获取写锁的，并不是所有的写操作都会阻塞。</li>
</ul>
<p>StampedLock之所以比ReadWriteLock性能好，就是因为StampedLock支持乐观读，乐观读不会加锁的，所以性能上会好很多。</p>
<p>StampedLock进行写锁、读锁、乐观读的时候，都会返回一个long类型的stamp，解锁时需要传入stamp。</p>
<p>需要注意的是，StampedLock是是支持锁升级和降级的，可以通过tryConvertToReadLock()和tryConvertToWriteLock()方法，但是这两个会返回新的stamp，在解锁时一定要使用这个新的stamp。</p>
<blockquote>
<p>读模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="comment">// 乐观读</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 判断乐观读期间是否发生写操作，如果有则返回则返回false</span></span><br><span class="line"><span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">	<span class="comment">// 如果发生了写操作，则升级为悲观读锁</span></span><br><span class="line">	stamp = sl.readLock();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 开始读操作....</span></span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// 释放悲观读锁</span></span><br><span class="line">     sl.unlockRead(stamp);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="comment">// 加写锁</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 进行写操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// 释放写锁</span></span><br><span class="line">	sl.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐Condition"><a href="#⭐Condition" class="headerlink" title="⭐Condition"></a>⭐<b id='Condition'>Condition</b></h3><p>Condition是条件变量，可以用来做异步转同步。</p>
<p>Condition中主要有三个方法：<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>，对应的是Object类的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>。</p>
<ul>
<li><code>await()</code>：进入等待状态并释放锁。</li>
<li><code>signal()</code>：唤醒一个等待线程。</li>
<li><code>signalAll()</code>：唤醒所有等待线程。</li>
</ul>
<p>比如需要等待某一个异步接口返回结果之后才能执行后续的逻辑，就可以在调用接口之前执行<code>await()</code>方法阻塞当前线程，获取到返回值之后执行<code>signal()</code>方法唤醒当前线程。</p>
<blockquote>
<p>异步转同步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">	<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 等待结果返回</span></span><br><span class="line">			condition.await(timeout);</span><br><span class="line">			<span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">			<span class="keyword">if</span> (response != <span class="literal">null</span> || cur - start &gt; timeout) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送异步请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		<span class="type">Response</span> <span class="variable">res</span> <span class="operator">=</span> sendRequest();</span><br><span class="line">     doReceived(res);</span><br><span class="line"> &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结果时调用该方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doRecived</span><span class="params">(Response res)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     response = res;</span><br><span class="line">     <span class="comment">// 获取到返回值后，唤醒线程</span></span><br><span class="line">     condition.signal();</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐Semaphore"><a href="#⭐Semaphore" class="headerlink" title="⭐Semaphore"></a>⭐<b id='Semaphore'>Semaphore</b></h3><p>Semaphore可以让多个线程同时访问某一个资源，可以用来实现简单的限流器。</p>
<ul>
<li><code>acquire()</code>：Semaphore中的计数器+1，当计数器达到阈值，会阻塞当前线程，直到计数器减少。</li>
<li><code>release()</code>：Semaphore计数器-1。</li>
</ul>
<p>使用Semaphore时需要注意线程安全问题，因为Semaphore可以让多个线程进入临界区。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="comment">// 初始化信号量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			semaphore.acquire();</span><br><span class="line">			value++;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			semaphore.release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐CountDownLatch"><a href="#⭐CountDownLatch" class="headerlink" title="⭐CountDownLatch"></a>⭐<b id='CountDownLatch'>CountDownLatch</b></h3><p>CountDownLatch是一个线程同步工具，可以让父线程等待子线程执行的执行结果。</p>
<p>CountDownLatch可以理解为是一个计数器，在初始化时可以指定计数器的值，通常是子线程或者任务的数量，让主线程调用await()方法进入等待状态，子线程执行完毕就调用countDown()方法让计数器减一，当计数器为0时CountDownLatch会唤醒主线程。</p>
<p>CountDownLatch的计数器是不能循环利用的，计数器的值一旦减到0，再次调用await()方法会直接通过。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"><span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">	p = getP();</span><br><span class="line">	latch.countDown();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">	d = getD();</span><br><span class="line">	latch.countDown();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">latch.await();</span><br><span class="line"><span class="type">Diff</span> <span class="variable">diff</span> <span class="operator">=</span> check(p, d);</span><br><span class="line">save(diff);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐CyclicBarrier"><a href="#⭐CyclicBarrier" class="headerlink" title="⭐CyclicBarrier"></a>⭐<b id='CyclicBarrier'>CyclicBarrier</b></h3><p>CyclicBarrier是一个线程同步工具，可以让一组线程之间相互等待。</p>
<p>在初始化时可以指定计数器的值，子线程执行完之后调用await()方法，进入等待状态并让计数器减一。计数器为0时会重置计数器的值，并让最后一个调用await()方法的线程触发回调函数。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector&lt;P&gt; pos;</span><br><span class="line">Vector&lt;D&gt; dos;</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, () -&gt; &#123;</span><br><span class="line"> <span class="comment">// 将回调函数提交到线程池中执行</span></span><br><span class="line">	executor.execute(() -&gt; check())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> pos.remove(<span class="number">0</span>);</span><br><span class="line">	<span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> dos.remove(<span class="number">0</span>);</span><br><span class="line">	<span class="type">Diff</span> <span class="variable">diff</span> <span class="operator">=</span> check(p,d);</span><br><span class="line">	save(diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkAll</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">while</span> (存在未对账的数据)  &#123;</span><br><span class="line">      	<span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> getP();</span><br><span class="line">	        pos.add(p);</span><br><span class="line"> 	    cyclicBarrier.await();</span><br><span class="line">  	&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">while</span> (存在未对账的数据)  &#123;</span><br><span class="line">     	<span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> getD();</span><br><span class="line">	        dos.add(d);</span><br><span class="line"> 	    cyclicBarrier.await();</span><br><span class="line">  	&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐FutureTask"><a href="#⭐FutureTask" class="headerlink" title="⭐FutureTask"></a>⭐<b id='FutureTask'>FutureTask</b></h3><p><strong>FutureTask实现了Runnable接口和Future接口，所以可以把FutureTask作为任务提交给线程池去执行，也可以用来获取任务的执行结果</strong>。</p>
<p>它有两个构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个构造函数的参数是Callable接口，Callable接口中的call()方法是有返回值的，调用FutureTask的get()方法得到的就是call()方法的返回值。</li>
<li>第二个构造函数的参数是Runnable接口和结果引用，调用FutureTask的get()方法得到的就是结果引用。</li>
</ul>
<h3 id="⭐CompletableFuture"><a href="#⭐CompletableFuture" class="headerlink" title="⭐CompletableFuture"></a>⭐<b id='CompletableFuture'>CompletableFuture</b></h3><p>CompletableFuture继承了Future接口和CompletionStage接口。</p>
<p>跟传统的Future相比，CompletableFuture可以更方便的处理任务之间的关联关系。</p>
<p>默认情况下CompletableFuture会使用公共的<a href="#ForkJoinPool">ForkJoinPool</a>线程池，这个线程池默认的线程数是CPU的核心数。</p>
<blockquote>
<p>在开发时尽量使用自定义的线程池，因为如果所有的CompletableFuture都使用同一个线程池，如果有一些任务执行了一些很慢的I/O操作，就会导致线程池中所有的任务都阻塞，会影响整个系统的性能，所以尽量根据不同的业务类型创建不同的线程池。</p>
</blockquote>
<p>主要方法：</p>
<ol>
<li><p>描述串行关系：</p>
<ul>
<li><p><code>thenApply(function)</code>：把前一个任务的执行结果，交给后面的<code>Function</code>处理（有返回值）。</p>
</li>
<li><p><code>thenAccept(consumer)</code>：把前一个任务的执行结果，交给后面的<code>Consume</code>处理（没有返回值）。</p>
</li>
<li><p><code>thenRun(runnable)</code>：忽略前一个任务的结果，执行额外的逻辑（没有返回值）。</p>
</li>
<li><p><code>thenCompose(function)</code>：会把前一个<code>CompletableFuture</code>的结果传递给内部的<code>CompletableFuture</code>，最后返回一个新的<code>CompletableFuture</code>对象。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture</span><br><span class="line"> .supplyAsync(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Integer&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">30</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;第一次运算：&quot;</span> + number);</span><br><span class="line">         <span class="keyword">return</span> number;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).thenCompose(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, CompletionStage&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> CompletionStage&lt;Integer&gt; <span class="title function_">apply</span><span class="params">(Integer param)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> CompletableFuture.supplyAsync(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Integer&gt;() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                 <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> param * <span class="number">2</span>;</span><br><span class="line">                 System.out.println(<span class="string">&quot;第二次运算：&quot;</span> + number);</span><br><span class="line">                 <span class="keyword">return</span> number;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
<li><p>描述AND聚合关系：</p>
<ul>
<li><code>thenCombine(other, function)</code>：两个任务都要有返回值，可以对两个任务的结果做一些额外的处理（有返回值）。</li>
<li><code>thenAcceptBoth(other, consumer)</code>：两个任务都要有返回值，可以对两个任务的结果做一些额外的处理（没有返回值）。</li>
<li><code>runAfterBoth(other, runnable)</code>：不需要前面的任务有返回值，可以执行一些额外的逻辑（没有返回值）。</li>
</ul>
</li>
<li><p>描述OR聚合关系：</p>
<ul>
<li><code>applyToEither(other, function)</code>：两个任务都要有返回值，任意一个任务先结束，就会执行（有返回值）。</li>
<li><code>acceptEither(other, consumer)</code>：两个任务都要有返回值，任意一个任务先结束，就会执行（没有返回值）。</li>
<li><code>runAfterEither(other, runnable)</code>：不需要前面的任务有返回值，任意一个任务先结束，就会执行（没有返回值）。</li>
</ul>
</li>
<li><p>异常处理：</p>
<ul>
<li><code>exceptionally(function)</code>：前面的任务报错时就会执行，类似于catch{}代码块。</li>
<li><code>whenComplete(consumer)</code>：无论是否发生异常都会执行，相当于finally{}代码块，可以配合<code>exceptionally</code>使用（没有返回值）。</li>
<li><code>handle(function)</code>：无论是否发生异常都会执行，相当于finally{}代码块（有返回值）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>方法名带有Async表示会异步执行function、consumer或者runnable。</p>
</blockquote>
<p>CompletableFuture提供4个静态方法来创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认线程池</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplyer&lt;U&gt; supplyer)</span>;</span><br><span class="line"><span class="comment">// 指定线程池</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,Executor executor)</span></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplyer&lt;U&gt; supplyer, Executor executor)</span>;</span><br></pre></td></tr></table></figure>

<p>runAsync()方法接收的是Runnable接口，所以它是没有返回值的。</p>
<p>supplyAsync()方法接收的是Supplyer函数式接口，Supplyer的get()方法是有返回值的。</p>
<blockquote>
<p>用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; f1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;T1:洗⽔壶...&quot;</span>);</span><br><span class="line">	sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;T1:烧开⽔...&quot;</span>);</span><br><span class="line">	sleep(<span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;T2:洗茶壶...&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"> System.out.println(<span class="string">&quot;T2:洗茶杯...&quot;</span>);</span><br><span class="line"> sleep(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"> System.out.println(<span class="string">&quot;T2:拿茶叶...&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;⻰井&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; f3 = f1.thenCombine(f2, (_, tf) -&gt; &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;T1:拿到茶叶:&quot;</span> + tf);</span><br><span class="line"> System.out.println(<span class="string">&quot;T1:泡茶...&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span>	<span class="string">&quot;上茶:&quot;</span>	+	tf;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待任务3执⾏结果</span></span><br><span class="line">System.out.println(f3.join());</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐CompletionService"><a href="#⭐CompletionService" class="headerlink" title="⭐CompletionService"></a>⭐<b id='CompletionService'>CompletionService</b></h3><p>有些时候我们会执行多个异步任务，并且需要获取返回值，比较简单的做法是调用线程池的submit()方法，获取Future对象，再调用Future对象的get()方法获取返回值。但是调用Future对象的get()方法会导致当前线程阻塞，直到任务执行完毕。</p>
<p>如果任务1的执行时间比任务2的执行时间长，如果先调用任务1的Future对象的get()方法，就会导致任务2即使执行完毕后也不能及时处理，需要等任务1执行完毕后才能处理，CompletionService就可以解决这样的问题。</p>
<p>CompletionService内部维护了一个阻塞队列，当任务执行结束后，就把Future对象加入到队列中。队列是先进先出的，这样先执行完的任务就可以先加入到队列中，就可以先进行处理。</p>
<p>CompletionService是一个接口，实现类是ExecutorCompletionService，这个实现类的构造方法有两个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ExecutorCompletionService</span><span class="params">(Executor executor)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ExecutorCompletionService</span><span class="params">(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>创建ExecutorCompletionService需要传入一个线程池和BlockingQueue，如果不指定BlockingQueue默认使用的是无界的LinkedBlockingQueue。</p>
<p>主要方法：</p>
<ul>
<li><code>Future&lt;V&gt; submit(Callable&lt;V&gt; task)</code>：</li>
<li><code>Future&lt;V&gt; submit(Runnable task, V result)</code>：执行</li>
<li><code>Future&lt;V&gt; take()</code>：从队列中获取并移除一个元素，就阻塞当前线程，直到有元素返回。</li>
<li><code>Future&lt;V&gt; pool()</code>：从队列中获取并移除一个元素，如果队列是空的，会返回null。</li>
<li><code>Future&lt;V&gt; pool(timeout, unit)</code>：从队列中获取并移除一个元素，如果队列是空的，会等待一定的时间，超时后返回null。</li>
</ul>
<blockquote>
<p>用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建CompletionService</span></span><br><span class="line">CompletionService&lt;Integer&gt; cs = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor);</span><br><span class="line"><span class="comment">// 异步向电商S1询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS1());</span><br><span class="line"><span class="comment">// 异步向电商S2询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS2());</span><br><span class="line"><span class="comment">// 异步向电商S3询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS3());</span><br><span class="line"><span class="comment">// 将询价结果异步保存到数据库</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">r</span> <span class="operator">=</span> cs.take().get();</span><br><span class="line">	executor.execute( () -&gt; save(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐Fork-Join"><a href="#⭐Fork-Join" class="headerlink" title="⭐Fork/Join"></a>⭐<b id='Fork/Join'>Fork/Join</b></h3><p>Fork/Join是一种分治任务模型，主要分为两个阶段：</p>
<ul>
<li>一个阶段是<strong>任务分解</strong>，把一个大任务分解成多个小任务。</li>
<li>另一个阶段是<strong>结果合并</strong>，合并所有小任务的执行结果，得到最终的结果。</li>
</ul>
<p>Java提供了ForkJoinPool和ForkJoinTask两个类来支持分治任务模型。这两个类的关系类似于线程池和线程的关系。</p>
<h4 id="⭐ForkJoinPool"><a href="#⭐ForkJoinPool" class="headerlink" title="⭐ForkJoinPool"></a>⭐<b id='ForkJoinPool'>ForkJoinPool</b></h4><p>ForkJoinPool是内部有多个任务队列，当我们通过<code>invoke()</code>或者<code>submit()</code>方法提交任务时，ForkJoinPool会把任务提交到一个任务队列中。如果任务在执行过程中还会创建子线程，那么子线程会被提交到父线程所在的任务队列中。</p>
<p>如果某一个队列空了，还会从其它队列中 “窃取” 任务。</p>
<p>任务队列采用的是双端队列，正常执行任务和 “窃取任务” 会从不同的端口消费。</p>
<h4 id="⭐ForkJoinTask"><a href="#⭐ForkJoinTask" class="headerlink" title="⭐ForkJoinTask"></a>⭐<b id='ForkJoinTask'>ForkJoinTask</b></h4><p>ForkJoinTask是一个抽象类，最核心的方法是<code>fork()</code>和<code>join()</code>，其中<code>fork()</code>方法会异步执行一个子任务（执行<code>compute()</code>方法），<code>join()</code>方法会阻塞当前线程等待子任务的执行结果。</p>
<p>ForkJoinTask有两个子类，RecursiveAction和RecursiveTask，它们都是用递归的方式来处理分治任务的。这两个子类也是抽象类，内部定义了<code>compute()</code>抽象方法，需要自己定义子类去拓展。</p>
<blockquote>
<p>RecursiveAction没有返回值。</p>
<p>RecursiveTask有返回值。</p>
<p>调用<code>fork()</code>方法时，会调用我们实现的<code>compute()</code>方法。</p>
</blockquote>
<blockquote>
<p>单词统计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	String[] words = &#123;<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello me&quot;</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">	<span class="comment">// 创建ForkJoinPool</span></span><br><span class="line">	<span class="type">ForkJoinPool</span> <span class="variable">taskPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">10</span>);</span><br><span class="line"> Map&lt;String, Integer&gt; result = taskPool.invoke(<span class="keyword">new</span> <span class="title class_">WordCount</span>(words, <span class="number">0</span>, words.length));</span><br><span class="line"> System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCount</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Map&lt;String, Integer&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> String[] words;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> start, end;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">WordCount</span><span class="params">(String[] words, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.words = words;</span><br><span class="line">     <span class="built_in">this</span>.start = start;</span><br><span class="line">     <span class="built_in">this</span>.end = end;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> Map&lt;String, Integer&gt; <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (end - start == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> count(words[start]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">     <span class="type">WordCount</span> <span class="variable">wc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WordCount</span>(words, start, mid);</span><br><span class="line">     wc1.fork();</span><br><span class="line">     <span class="type">WordCount</span> <span class="variable">wc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WordCount</span>(words, mid, end);</span><br><span class="line">     <span class="keyword">return</span> merge(wc1.join(), wc2.compute());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, Integer&gt; <span class="title function_">merge</span><span class="params">(Map&lt;String, Integer&gt; r1, Map&lt;String, Integer&gt; r2)</span> &#123;</span><br><span class="line">     r1.forEach((key, value) -&gt; &#123;</span><br><span class="line">         r2.merge(key, value, Integer::sum);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">return</span> r2;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, Integer&gt; <span class="title function_">count</span><span class="params">(String line)</span> &#123;</span><br><span class="line">     String[] words = line.split(<span class="string">&quot;\\s&quot;</span>);</span><br><span class="line">     Map&lt;String, Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">         result.merge(word, <span class="number">1</span>, Integer::sum);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/12/08/MySQL/</url>
    <content><![CDATA[<h3 id="查询语句执行流程"><a href="#查询语句执行流程" class="headerlink" title="查询语句执行流程"></a>查询语句执行流程</h3><ol>
<li>首先客户端需要连接到服务端，并获取权限信息。</li>
<li>MySQL会先查询缓存，如果命中缓存就直接返回缓存中的数据。</li>
<li>如果没有命中缓存就会由分析器进行语法分析。以及验证表、字段是否存在。</li>
<li>验证通过后，优化器会对sql进行优化（比如选择索引），并把优化后的结果交给执行器。</li>
<li>执行器会调用存储引擎执行sql语句，并将结果返回给客户端，如果开启了查询缓存，还会把结果添加到缓存中。</li>
</ol>
<blockquote>
<p>MySQL是 “边读边发” 的，一个完整的查询流程是这样的：</p>
<ol>
<li><p>读取一行数据，写到net_buffer中（默认是16k）。</p>
<blockquote>
<p>net_buffer的大小可以通过参数<code>net_buffer_length</code>修改。</p>
</blockquote>
</li>
<li><p>继续读取数据，直到net_buffer写满，然后调用网络接口发送出去。</p>
</li>
<li><p>如果发送成功，就清空net_buffer，然后继续前面的流程。</p>
</li>
</ol>
</blockquote>
<h3 id="更新语句执行流程"><a href="#更新语句执行流程" class="headerlink" title="更新语句执行流程"></a>更新语句执行流程</h3><p>对于一条更新语句：</p>
<ul>
<li>如果对应数据页在内存中，就直接更新内存，然后把操作记录写到[redo log](#redo log)里面，这样就算执行完成了。然后MySQL会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</li>
<li>如果对应的数据页不在内存中，就把操作记录到[change buffer](#change buffer)中，然后再写[redo log](#redo log)。之后如果有查询语句把该数据页加载到内存，就会执行[change buffer](#change buffer)中对应的操作。</li>
</ul>
<h3 id="⭐日志"><a href="#⭐日志" class="headerlink" title="⭐日志"></a>⭐日志</h3><h4 id="⭐RedoLog-重做日志"><a href="#⭐RedoLog-重做日志" class="headerlink" title="⭐RedoLog (重做日志)"></a>⭐<b id='redo log'>RedoLog</b> (重做日志)</h4><p>redo log是InnoDB引擎特有的。</p>
<p>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的记录，然后再更新，整个IO成本就太高了。为了解决这个问题，MySQL的设计者使用redo log来提高更新效率。</p>
<p>具体来说，当有一条记录需要更新的时候，MySQL就会先把记录写到[redo log](#redo log)里面，并更新内存，这样时候更新就算完成了。然后，MySQL会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>redo log的大小是固定的，由两个指针控制日志的写入和擦除。写指针记录的是当前记录的位置，写到末尾就又回到开头循环写。擦除指针是已经被更新到磁盘的位置，擦除记录前会把记录更新到磁盘上。有了redo log，就可以保证就算数据库异常重启，之前提交的记录都不会丢失。</p>
<h4 id="⭐BinLog-归档日志"><a href="#⭐BinLog-归档日志" class="headerlink" title="⭐BinLog(归档日志)"></a>⭐<b id='binlog'>BinLog</b>(归档日志)</h4><p>binlog有三种格式，一种是<a href="#statement">statement</a>格式，一种是<a href="#row">row</a>格式，还有<a href="#mixed">mixed</a>格式。</p>
<p>可以通过参数<code>binlog_format</code>来设置binlog的格式。</p>
<h5 id="⭐Statement格式"><a href="#⭐Statement格式" class="headerlink" title="⭐Statement格式"></a>⭐<b id='statement'>Statement</b>格式</h5><p>statement格式中，<a href="#binlog">binlog</a>里面记录的就是SQL语句的原文，这种格式的优点是binlog需要保存的数据量比较少。但是有可能会导致主从数据不一致，比如delete语句带有limit的情况：</p>
<ol>
<li><p><code>delete from t where a=1 or b=2 limit 1;</code></p>
</li>
<li><p>如果这条delete语句走的是索引a，那就会根据索引a找到第一个满足条件的行，删除的就是id=1这一行。</p>
</li>
<li><p>如果使用的是索引b，那就会根据索引b找到第一条满足的行，删除的可能就是id=2这一行了。</p>
</li>
</ol>
<h5 id="⭐Row格式"><a href="#⭐Row格式" class="headerlink" title="⭐Row格式"></a>⭐<b id='row'>Row</b>格式</h5><p><a href="#binlog">binlog</a>是row格式时，<a href="#binlog">binlog</a>里面记录的是具体的数据内容，所以不会出现数据不一致的情况。</p>
<p>而且row格式恢复数据时很方便，如果要恢复delete语句，只需要把<a href="#binlog">binlog</a>中记录的数据转成insert语句就可以了。如果要恢复update语句，<a href="#binlog">binlog</a>也会记录修改前和修改后的数据。</p>
<p>row格式也是有缺点的，因为row格式记录的是数据内容，所以会占用很大的空间。</p>
<p>比如某一条delete语句删除了10万条数据，如果是<a href="#statement">statement</a>格式的话，只需要把sql语句记录到<a href="#binlog">binlog</a>中就好了。如果是row格式的话，就需要把这10万条记录都记录到<a href="#binlog">binlog</a>中，会占用更多空间。</p>
<h5 id="⭐Mixed格式"><a href="#⭐Mixed格式" class="headerlink" title="⭐Mixed格式"></a>⭐<b id='mixed'>Mixed</b>格式</h5><p>mixed格式其实就是<a href="#row">row</a>格式和<a href="#statement">statement</a>格式的混合版本，因为<a href="#statement">statement</a>格式可能会出现数据不一致，<a href="#row">row</a>格式会占用更大的空间。所以MySQL提出了一个折中的方案。</p>
<p>mixed格式会判断SQL语句是否会引发数据不一致的问题，如果会引发数据不一致就用<a href="#row">row</a>格式存储，否则就用<a href="#statment">statment</a>格式存储。</p>
<h4 id="⭐两阶段提交"><a href="#⭐两阶段提交" class="headerlink" title="⭐两阶段提交"></a>⭐两阶段提交</h4><p>两阶段提交就是将[redo log](#redo log)的写入拆成两个步骤：prepare（预提交）和commit（提交）两个阶段，主要是为了保证两份日志之间的一致性。因为[redo log](#redo log)和<a href="#binlog">binlog</a>是两个独立的日志，不管是先写[redo log](#redo log)还是先写<a href="#binlog">binlog</a>，都有可能出现数据不一致。</p>
<p>对于一条insert语句：</p>
<ul>
<li>如果先写[redo log](#redo log)后写<a href="#binlog">binlog</a>，[redo log](#redo log)写完之后MySQL异常重启，<a href="#binlog">binlog</a>中就会少记录一条insert语句，如果之后用这个<a href="#binlog">binlog</a>恢复数据的话，数据库中就会少一条数据。</li>
<li>如果先写<a href="#binlog">binlog</a>后写[redo log](#redo log)，<a href="#binlog">binlog</a>写完之后MySQL异常重启，因为[redo log](#redo log)还没写，MySQL恢复以后这个事务是无效的。但是<a href="#binlog">binlog</a>已经写完了，之后如果用这个<a href="#binlog">binlog</a>恢复数据的话，就会多一条数据。</li>
</ul>
<p>如果不使用“两阶段提交”，那么数据库当前的状态就有可能和用日志恢复出来的状态不一致。</p>
<p>对于两阶段提交来说，假设[redo log](#redo log)处于预提交状态，MySQL恢复以后会判断对应的<a href="#binlog">binlog</a>记录是否完整，如果是完整的就提交[redo log](#redo log)，否则就回滚事务。</p>
<blockquote>
<p>[redo log](#redo log)和<a href="#binlog">binlog</a>有一个共同的字段，叫XID。MySQL异常重启之后，会先扫描[redo log](#redo log)中的记录。</p>
<ul>
<li><p>如果包含commit的记录，就直接提交。</p>
</li>
<li><p>如果某一条记录只有prepare，没有commit，就通过XID去找对应的<a href="#binlog">binlog</a>，并判断<a href="#binlog">binlog</a>是否完整，如果<a href="#binlog">binlog</a>是完整的就提交。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>一个事务的<a href="#binlog">binlog</a>是有完整格式的：</p>
<ul>
<li><a href="#statement">statement</a>格式的<a href="#binlog">binlog</a>，结尾会有commit。</li>
<li><a href="#row">row</a>格式的<a href="#binlog">binlog</a>，结尾会有XID event。</li>
</ul>
</blockquote>
<h4 id="两个日志的区别"><a href="#两个日志的区别" class="headerlink" title="两个日志的区别"></a>两个日志的区别</h4><ol>
<li>[redo log](#redo log)是InnoDB引擎才有的；<a href="#binlog">binlog</a>是MySQL实现的，所有引擎都可以使用。</li>
<li>[redo log](#redo log)的大小是固定的，是循环写的；<a href="#binlog">binlog</a>是可以追加写入的。“追加写”是指<a href="#binlog">binlog</a>文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<h4 id="⭐Undo-log"><a href="#⭐Undo-log" class="headerlink" title="⭐Undo log"></a>⭐<b id='undolog'>Undo log</b></h4><ul>
<li>undo log是回滚日志，用来记录数据被修改前的信息，它跟[redo log](#redo log)正好相反，[redo log](#redo log)记录的是数据被修改后的信息。</li>
<li>undo log记录的是修改之前的数据信息，假如需要回滚操作的话，可以根据undo log的信息来回滚到没被修改前的状态。</li>
</ul>
<p>比如：当我们执行一条insert语句时，Undo Log就记录一条相反的delete语句。</p>
<h3 id="⭐索引"><a href="#⭐索引" class="headerlink" title="⭐索引"></a>⭐索引</h3><p>索引是在引擎层实现的，不同引擎的索引实现方式是不一样的。InnoDB使用的是B+树模型，每一个索引都对应一个B+树。</p>
<p>根据B+树叶子节点的内容，索引又分为主键索引和非主键索引。</p>
<ul>
<li><p>主键索引的叶子节点存的是数据页。对于主键索引的查询语句，只需要搜索主键对应的B+树。</p>
<blockquote>
<p>如果创建表时没有指定主键，InnoDB会自己生成一个长度为6个字节的rowid作为主键</p>
</blockquote>
</li>
<li><p>非主键索引的叶子节点内容是主键的值。对于非主键索引的查询语句，需要先搜索索引对应的B+树，得到主键值，再到主键索引搜索一次。这个过程叫<b id='回表'>回表</b>。</p>
</li>
</ul>
<h4 id="⭐覆盖索引"><a href="#⭐覆盖索引" class="headerlink" title="⭐覆盖索引"></a>⭐覆盖索引</h4><p>如果索引中包含了查询语句需要查询的所有字段，这种情况可以直接返回结果，不需要回表。</p>
<h4 id="⭐索引下推"><a href="#⭐索引下推" class="headerlink" title="⭐索引下推"></a>⭐索引下推</h4><p>MySQL5.6引入了索引下推机制，可以在遍历普通索引时，对索引中包含的字段先做判断，直接过滤掉不符合条件的记录，减少回表次数。</p>
<p>MySQL5.6之前需要先通过普通索引查询到主键值，然后到主键索引上找出对应的数据行，再判断数据行是否符合条件。</p>
<h4 id="⭐唯一索引"><a href="#⭐唯一索引" class="headerlink" title="⭐唯一索引"></a>⭐唯一索引</h4><p>对于查询语句来说：</p>
<ul>
<li>如果要搜索的是普通索引，在查询到第一个满足条件的数据后，需要继续查找，直到碰到第一个不满足条件的记录为止。</li>
<li>如果要搜索的是唯一索引，由于索引定义了唯一性，查找到第一条满足条件的记录后，就会停止查找。</li>
</ul>
<p>也就是说，唯一索引可以提高查询效率，不过这种效率的提升是非常低的。因为InnoDB是以数据页为单位进行读写的，也就是说，如果需要查询一条记录的时候，会把该记录所在的数据页都读入到内存中。所以普通索引后续的查找和判断都是在内存中进行的，效率会很高。</p>
<p>对于更新/插入语句来说：</p>
<ul>
<li>如果是普通索引，如果要操作的数据页在内存中，就直接更新内存中的数据，然后写日志；如果要操作的数据页不在内存中，就把操作记录在[change buffer](#change buffer)中。</li>
<li>如果是唯一索引，如果要操作的数据页在内存中，就判断是否存在冲突，如果没有冲突就更新内存中的数据，然后写日志；如果要操作的数据页不在内存中，需要先把数据页加载到内存中，再进行操作。</li>
</ul>
<h4 id="⭐change-buffer"><a href="#⭐change-buffer" class="headerlink" title="⭐change buffer"></a>⭐<b id='change buffer'>change buffer</b></h4><p>对于普通索引来说，当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页没有在内存中的话，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。查询这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。这样就能保证数据的正确性。</p>
<p>对于唯一索引来说，需要先判断数据是否违反唯一约束，所以必须先把数据加载到内存之后才能判断。这样就没必要使用change buffer了。</p>
<p>将更新操作记录在change buffer中，可以减少磁盘访问次数，而且数据读入内存是需要占用buffer pool的，所以这种方式还能避免占用内存。</p>
<blockquote>
<p>change buffer是可以持久化的数据，也会被写入到磁盘上。</p>
</blockquote>
<p>将change buffer中的操作应用到数据页，这个过程称之为merge。</p>
<p>除了访问数据页会触发merge以外，系统有后台线程会定期触发merge。在数据库正常关闭的时候，也会触发merge。</p>
<p>所以change buffer更适合写多读少的业务。merge是数据真正更新的时刻，所以在一个数据页merge之前，change buffer记录的变更越多，收益就越大。</p>
<h4 id="⭐最左前缀原则"><a href="#⭐最左前缀原则" class="headerlink" title="⭐最左前缀原则"></a>⭐最左前缀原则</h4><p>最左前缀可以匹配联合索引上的最左N个字段，也可以匹配字符串索引的最左N个字符。</p>
<h4 id="⭐索引失效的情况"><a href="#⭐索引失效的情况" class="headerlink" title="⭐索引失效的情况"></a>⭐索引失效的情况</h4><ul>
<li>对索引字段做函数操作，会导致无法使用索引。</li>
<li>隐式类型转换，会导致无法使用索引，假如字段是varchar类型的，但参数却是整型，就需要做类型转换。</li>
<li>隐式字符集编码转换，会导致无法使用索引。假如表1是utf-8编码，表2是utf-8mb4编码。当表1和表2关联查询的时候会导致无法使用索引。</li>
</ul>
<h4 id="为什么选择B-树？"><a href="#为什么选择B-树？" class="headerlink" title="为什么选择B+树？"></a>为什么选择B+树？</h4><p>磁盘的最小读写单位是扇区，目前比较新的硬盘，一个物理扇区的大小是4K个字节。操作系统一次会读写多个扇区，操作系统的最小读写单位是块 (Block)。当我们要从磁盘上读取一个数据时，操作系统会一次性把整个块都读出来。</p>
<p>B+树的一个关键设计，就是让一个节点的大小等于一个块的大小，节点内部维护一个有序数组。这样就可以让磁盘读取效率最大化。</p>
<p>B+树还有另一个设计，就是把所有节点分为枝干节点和叶子节点。枝干节点只保存key和维持树形结构的指针，并不存储具体的数据，这样枝干节点就能存储更多的索引数据。</p>
<p>B+树还把同一层级的所有节点串成一个有序的双向链表，这样就可以满足范围查询。</p>
<h4 id="优化器是如何选择索引的"><a href="#优化器是如何选择索引的" class="headerlink" title="优化器是如何选择索引的"></a>优化器是如何选择索引的</h4><p>优化器主要会根据<strong>扫描行数</strong>来决定选择哪个索引。</p>
<p>但是在执行语句前，并不能精确的知道满足条件的记录有多少，只能通过索引的区分度来估算，一个索引上不同的值越多，就说明这个索引的区分度越高。</p>
<blockquote>
<p>可以通过<code>show index</code>命令查看索引的区分度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>MySQL是通过统计采样的方法来统计索引的区分度，因为把整张表取出来一行行统计代价太高了。</p>
<p>具体的逻辑是这样的，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p>
<p>因为数据是会持续更新的，索引统计信息也不会固定不变，当变更数据行数超过一定数量的时候，会触发一次索引统计。</p>
<p>可以使用<code>force index</code>的方式强制选择一个索引。</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(index_name)</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐事务"><a href="#⭐事务" class="headerlink" title="⭐事务"></a>⭐事务</h3><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持是在引擎层实现的，并不是所有的引擎都支持事务。MyISAM引擎就不支持事务。</p>
<h4 id="⭐事务的特性"><a href="#⭐事务的特性" class="headerlink" title="⭐事务的特性"></a>⭐事务的特性</h4><ul>
<li><p><b id='原子性'>原子性</b>：是指一个事务操作不可被分割，要么成功，要么失败。 </p>
<blockquote>
<p>事务的原子性是通过<a href="#undolog">undo log</a>来实现的。</p>
</blockquote>
</li>
<li><p><b id='隔离性'>隔离性</b>：是指一个事务内部的操作对其他运行中的事务是隔离的，并发执行的多个事务之间也是互不干扰的。</p>
<blockquote>
<p>事务的隔离性是通过<a href="#MVCC">MVCC</a>实现的。</p>
</blockquote>
</li>
<li><p><b id='持久性'>持久性</b>：是指一个事务一旦提交完成，后续的其他操作和故障都不会对事物的结果产生影响。</p>
<blockquote>
<p>事务的持久性是通过[redo log](#redo log)实现的。</p>
</blockquote>
</li>
<li><p><b id='一致性'>一致性</b>：是指事务不管成功还是失败，必须保证数据的正确性。</p>
<blockquote>
<p>比如表中有一个字段有唯一约束，如果事务提交之后导致这一列有相同的数据，这就破坏了数据的正确性。</p>
<p>事务的原子性、隔离性、持久性都是用来保证一致性的。</p>
</blockquote>
</li>
</ul>
<h4 id="⭐隔离级别"><a href="#⭐隔离级别" class="headerlink" title="⭐隔离级别"></a>⭐隔离级别</h4><p>当数据库上有多个事务同时执行的时候，就有可能出现<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<ul>
<li><p><b id='读未提交'>读未提交（read uncommitted）</b>：一个事务可以读取到另一个事务未提交的数据。会产生脏读。</p>
<blockquote>
<p>实现方式：直接返回内存中最新的数据。</p>
</blockquote>
</li>
<li><p><b id='读提交'>读提交（read committed）</b>：一个事务只能读取到其它事务已经提交的数据。可以解决脏读的问题。</p>
<blockquote>
<p>因为读提交隔离级别下，事务中的每一条sql语句都会生成一个最新的一致性视图（Read View），对于同一个事务执行两次相同的select语句，如果两次select语句之间有其它事务提交，可能会看到不一样的结果，会产生不可重复读的问题。</p>
</blockquote>
</li>
<li><p><b id='可重复读'>可重复读（repeatable read）</b>：一个事务在执行过程中看到的数据，总是和启动时看到的数据是一致的。</p>
<blockquote>
<p>可重复读隔离级别是事务开始时创建一个一致性视图（Read View），所以可以解决不可重复读的问题。</p>
</blockquote>
</li>
<li><p><b id='串行化'>串行化（serializable ）</b>：对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突时，后访问的事务会进入阻塞状态，这种隔离级别会导致数据库效率降低。</p>
<blockquote>
<p>实现方式：直接通过加锁的方式避免并行访问。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>读提交</strong>和<strong>可重复读</strong>隔离级别都是通过<a href="#MVCC">MVCC</a>实现的，主要区别是：</p>
<ul>
<li>在可重复读隔离级别下，事务开始时会创建一个一致性视图（Read View），事务中所有sql语句都是基于这个视图执行的。</li>
<li>在读提交隔离级别下，事务中的每一条sql语句都会生成一个新的一致性视图（Read View）。</li>
</ul>
</blockquote>
<h4 id="⭐MVCC"><a href="#⭐MVCC" class="headerlink" title="⭐MVCC"></a>⭐<b id='MVCC'>MVCC</b></h4><p>MVCC主要用来实现<strong>读提交</strong>和<strong>可重复读</strong>这两种隔离级别，它可以让同一条记录在系统中可以存在多个版本。</p>
<p>具体的实现逻辑是这样的，InnoDB里面每个事务都有一个唯一的事务ID。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p>
<p>事务更新数据的时候，都会生成一个新的数据版本，并且把当前事务的ID赋值给这个数据版本的事务ID。也就是说，表中的一行记录，有多个版本，每个版本有自己的事务ID。</p>
<ul>
<li>在实现上，InnoDB为每个事务构造了一个数组，用来保存这个事务启动时，所有已经启动但是还没有提交的事务ID。</li>
<li>数组中事务ID的最小值记为低水位，事务ID最大值记为高水位。</li>
<li>小于低水位的事务ID代表已提交的事务，对当前事务可见。</li>
<li>大于高水位的事务ID代表还未启动的事务，对当前事务不可见。</li>
<li>如果在高水位和低水位之间的事务那就包括两种情况：<ol>
<li>如果事务ID在数组中，表示这个版本是由未提交的事务生成的，不可见。</li>
<li>如果事务ID不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
</li>
</ul>
<p>假设连续启动三个事务：事务A、B、C的版本号分别是100、101、102。这三个事务都会访问x字段；事务A会查询x的值，事务B和事务C会更新x的值。</p>
<p>这三个事务开始之前，x=1，x对应的事务ID是99。</p>
<p>事务A的视图数组就是[100]，事务B的视图数组就是[100, 101]，事务C的视图数组就是[100, 101, 102]</p>
<p>对于查询语句来说：</p>
<p>事务C执行x+1，这个时候x的值就是2，最新版本是102，99就变成历史版本了。</p>
<p>事务B执行x+1，这个时候x的值就是3，最新版本是101，102就变成历史版本了。</p>
<ul>
<li><p>最后事务A查询x的时候</p>
<ul>
<li><p>在<strong>可重复读</strong>的隔离级别下，事务A查询语句的流程是这样的：</p>
<ol>
<li><p>当前x=3，事务ID=101，比高水位大，不可见。</p>
</li>
<li><p>然后再去找上一个版本，x=2，事务ID=102，比高水位大，不可见。</p>
</li>
<li><p>再往前找，x=1，事务ID=90，比低水位小，可见。所以事务A查询到的x的值就是1</p>
</li>
</ol>
</li>
<li><p>在<strong>读提交</strong>隔离级别下：</p>
<ol>
<li>如果事务B提交了，事务A查询到的x=3；</li>
<li>如果事务B没提交，事务C提交了，事务A查询到的x=2；</li>
<li>如果都没提交，事务A查询到的x=1。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>对于更新语句来说：</p>
<p>更新数据都是要先读后写的，这个读，是<a href="#%E5%BD%93%E5%89%8D%E8%AF%BB">当前读</a>，因为必须要保证读到的当前最新的值。</p>
<p>所以事务B更新数据的时候，就不能以事务启动时的数据为基础上更新，必须在事务C的更新结果的基础上进行，否则事务C的更新就丢失了。</p>
<p>所以事务B执行后x=3。</p>
<blockquote>
<p>如果把事务A的查询语句加上<code>lock in share mode</code>或者<code>for update</code>，也可以读到事务ID=101的版本，x=3。</p>
<p>如果事务C更新完之后，并没有立刻提交事务，事务B就会进入阻塞状态。</p>
</blockquote>
<p><b id='当前读'>当前读</b>：</p>
<p>加锁的select语句、update、insert、delete语句都是当前读。当前读查询的是数据的最新版本，执行时还要保证其它事务不能修改当前记录，会对读取的记录加锁。</p>
<p><b id='快照读'>快照读</b>：</p>
<p>不加锁的select语句就是快照读。快照读查询的是数据的可见版本，所以查询到的数据有可能不是最新的。</p>
<h3 id="⭐锁"><a href="#⭐锁" class="headerlink" title="⭐锁"></a>⭐锁</h3><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>全局锁就是对整个数据库加锁，通常是对数据库做备份时才会用到。命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush <span class="keyword">table</span> <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure>



<h4 id="⭐表级锁（元数据锁）"><a href="#⭐表级锁（元数据锁）" class="headerlink" title="⭐表级锁（元数据锁）"></a>⭐表级锁（元数据锁）</h4><p>表级锁有两种：表锁、元数据锁。</p>
<p><strong>表锁</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 对t1加读锁，t2加写锁</span></span><br><span class="line">lock tables t1 read, t2 write</span><br></pre></td></tr></table></figure>

<p>表锁除了会限制其它线程的读写外，也会导致当前线程只能访问被加锁的表，</p>
<blockquote>
<p>如果对t1加读锁，对t2加写锁，会导致当前线程只能执行读t1和读写t2的操作，不允许访问其它表。</p>
</blockquote>
<p><strong>元数据锁（metadata lock）</strong>：</p>
<p>元数据锁是MySQL 5.5版本引入的，当对一个表做增删改查操作的时候，会自动加元数据读锁。如果要对表结构做变更的时候，会自动加元数据写锁。</p>
<ul>
<li>元数据读锁之间不互斥</li>
<li>元数据读锁和元数据写锁之间是互斥的。</li>
</ul>
<h4 id="⭐行锁"><a href="#⭐行锁" class="headerlink" title="⭐行锁"></a>⭐行锁</h4><p>行锁是在引擎层实现的，MyISAM是不支持行锁的。</p>
<p><strong>InnoDB中的行锁是通过索引实现的，如果SQL语句的条件字段没有索引，就会进行全表扫描，扫描过的行都会被加上行锁，对应的主键索引也会加上行锁。这种情况就相当于是表锁了</strong>。</p>
<p>需要注意的是，在一个事务中，行锁是在需要的时候加上的，但并不是不需要了就会立刻释放，而是要等到事务结束后才释放。</p>
<p>如果事务中会给多行数据加锁，要把可能造成锁冲突的语句尽量往后放，这样就可以减少事务之间的锁等待，可以提升并发度。</p>
<blockquote>
<ul>
<li>假设有一个交易系统，顾客A要在商家B购买商品，假如这个业务涉及到以下操作：<ol>
<li>从顾客A账户上扣除商品价格。</li>
<li>给商家B账户上增加商品价格。</li>
<li>记录一条交易日志。</li>
</ol>
</li>
<li>为了保证原子性，需要把这三个操作放到同一个事务中。</li>
<li>如果同一时刻顾客C也要购买商品，那么这两个事务冲突的部分就是，更新商家的账户余额。</li>
<li>根据两阶段锁协议，行锁是在事务提交的时候才释放，所以如果把更新商家余额的语句安排在最后面，那么商家账户余额这一行的锁时间就最少，这样就可以降低事务之间的锁等待，提升了并发度。</li>
</ul>
</blockquote>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>两个事务都持有对方需要的行锁，并且都等待对方释放行锁，就会产生死锁。</p>
<p>MySQL有两种处理死锁的策略：</p>
<ul>
<li><p>第一种策略是事务超时退出，默认是50秒，可以通过<code>innodb_lock_wait_timeout</code>调整。</p>
<blockquote>
<p>这种策略如果发生死锁，需要等待50秒之后才会超时退出，就会导致其它事务等待锁释放的事务也阻塞比较长的时间。</p>
<p>如果把超时时间设置的比较短，又很容易出现误伤。</p>
</blockquote>
</li>
<li><p>第二种策略是死锁检测，默认是开启的。死锁检测发现死锁后，会主动回滚某一个事务，让其他事务继续执行。</p>
<blockquote>
<p>死锁检测的逻辑是：每当一个事务进入锁等待状态的时候，就会检查当事务需要依赖的行锁是否被其它事务锁住。</p>
</blockquote>
</li>
</ul>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a><b id='幻读'>幻读</b></h3><p><strong>幻读是指同一个事务在前后两次执行相同的查询语句，后一次查询看到了前一次查询没有看到的数据</strong>。</p>
<blockquote>
<p>在可重复读隔离级别下，普通的select语句是<a href="#%E5%BF%AB%E7%85%A7%E8%AF%BB">快照读</a>，不会看到别的事务插入的数据，幻读只会在<a href="#%E5%BD%93%E5%89%8D%E8%AF%BB">当前读</a>才会出现。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SessionA: <span class="keyword">begin</span>;</span><br><span class="line">SessionA: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> key <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">SessionA: <span class="keyword">update</span> t <span class="keyword">set</span> key <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> key <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">SessionB: <span class="keyword">insert</span> <span class="keyword">into</span> t(id,key) <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">SessionA: <span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>幻读会破坏数据的一致性，假设线程A要把数据库中所有key=10的记录改成key=100，首先线程A执行update语句会对key=10的记录加写锁，线程A执行update语句的过程中，线程B新插入了一条key=10的记录。</p>
<p>等事务A提交之后，<a href="#binlog">binlog</a>中sql的顺序就是：</p>
<ol>
<li>线程B插入一条key=10的记录。</li>
<li>线程A将key=10的记录修改为key=100。</li>
</ol>
<p>如果把这个<a href="#binlog">binlog</a>发送给从库去执行，或者用这个<a href="#binlog">binlog</a>来恢复数据，就会出现数据不一致了。</p>
<p>其实问题产生的原因就是在给key=10的记录加锁时，新数据还不存在，不存在也就加不上锁。</p>
<p><strong>如何解决幻读</strong>：</p>
<p><strong>幻读产生的原因是，行锁只能锁住数据库中已经存在的记录，但是插入数据这个动作，需要更新的是记录之间的“间隙”，因此InnoDB引入了<a href="#%E9%97%B4%E9%9A%99%E9%94%81">间隙锁</a>来解决幻读的问题</strong>。</p>
<h4 id="⭐间隙锁"><a href="#⭐间隙锁" class="headerlink" title="⭐间隙锁"></a>⭐间隙锁</h4><p>间隙锁是在<a href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">可重复读</a>隔离级别下才有的，它跟其它锁都不太一样，间隙锁的含义是保护这个间隙不会被插入新的数据，所以间隙锁之间是不冲突的，间隙锁只会和 “<strong>往间隙锁要保护的间隙中插入新的记录</strong>” 这个操作存在冲突关系。</p>
<p>间隙锁通常是和行锁一起使用的，假设表中只有key=5和10两条记录，现在要修改key=5这条记录，就会对key=5这条记录加上一个行锁和两个间隙锁，锁范围就会变成 [0, 5]。也就是说间隙锁会导致锁的粒度变大，这其实是会影响并发度的。</p>
<h3 id="刷脏页"><a href="#刷脏页" class="headerlink" title="刷脏页"></a>刷脏页</h3><p>当内存中的数据页和磁盘数据页内容不一致的时候，这个内存页称之为“脏页”，内存数据写入到磁盘后，称之为“干净页”。</p>
<p>通常有四种情况会导致MySQL刷脏页：</p>
<p>第一种情况是，当[redo log](#redo log)写满了，这个时候系统就会阻塞所有更新操作，把[redo log](#redo log)中的操作记录应用到磁盘上，直到[redo log](#redo log)有足够的空闲区域。</p>
<p>第二种情况是，系统内存不足，因为MySQL的更新操作需要先把数据加载到内存中，如果内存放不下新的数据页，就会把最久没有使用过的数据页<a href="#%E6%B7%98%E6%B1%B0">淘汰</a>掉。如果淘汰的数据页是“脏页”，就会先将脏页写到磁盘上。如果这个脏页旁边的数据页也是脏页，也会把这个脏页一起刷掉，而且这个逻辑可能还会一直蔓延。<strong>如果一次查询需要淘汰的脏页太多，就会导致MySQL响应时间变长</strong>。</p>
<p>第三种情况是，MySQL认为系统比较空闲的时候，也会刷脏页。</p>
<p>第四种情况是，当MySQL正常关闭的时候，会把所有的脏页都刷新到磁盘上。</p>
<h3 id="⭐读写分离"><a href="#⭐读写分离" class="headerlink" title="⭐读写分离"></a>⭐读写分离</h3><h4 id="主从模式基本原理"><a href="#主从模式基本原理" class="headerlink" title="主从模式基本原理"></a>主从模式基本原理</h4><p>主库和从库之间会维持一个长连接，主库内部有一个线程，专门用来服务从库这个长连接的。</p>
<ol>
<li><p>首先在从库上执行<code>change master</code>命令，设置主库的IP、用户名、密码、<a href="#binlog">binlog</a>文件名、日志偏移量。</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> master_port<span class="operator">=</span>xxx master_user<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> master_password<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> master_log_file<span class="operator">=</span><span class="string">&#x27;binlog.0001&#x27;</span> master_log_pos<span class="operator">=</span><span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>然后在从库上执行<code>start slave</code>命令，这个时候从库会启动两个线程，一个负责和主库建立连接，另一个负责读取和解析中转日志。</p>
</li>
<li><p>主库校验完用户名和密码之后，就会按照传过来的<a href="#binlog">binlog</a>偏移量，从本地读取日志并发送给从库。</p>
</li>
<li><p>从库收到<a href="#binlog">binlog</a>后，会写到本地的中转日志。</p>
</li>
<li><p>从库中负责读取中转日志的线程，就会解析出日志里面的命令并执行。</p>
</li>
</ol>
<h4 id="双主模式"><a href="#双主模式" class="headerlink" title="双主模式"></a>双主模式</h4><p>双主模式就是两个节点互为主从关系，双主模式会有循环复制的问题。就是节点A执行了一条更新语句，会把生成的binlog发送给节点B，节点B执行完binlog中的内容后也会生成一条binlog再发送给节点A。这就会导致节点A和节点B会不断的循环执行这条更新语句。</p>
<p>解决办法是：</p>
<ol>
<li>要规定两个节点的server id必须不一样。</li>
<li>一个节点接收到binlog执行之后，生成的binlog的server id与原binlog的server id相同。</li>
<li>每个节点收到binlog后，先判断server id跟自己的是否相同，如果相同则表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
<h4 id="⭐主从切换"><a href="#⭐主从切换" class="headerlink" title="⭐主从切换"></a>⭐主从切换</h4><p>主要有两种方案：<a href="#%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%82%B9%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2">基于位点的主从切换</a>，<a href="#%E5%9F%BA%E4%BA%8EGTID%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2">基于GTID的主从切换</a>。</p>
<p><b id='基于位点的主从切换'>基于位点的主从切换</b>：</p>
<p>假设有A、B、C，D四个节点，其中A节点和B节点互为主从，C节点和D节点是A节点的从节点。也就是双主多从架构。</p>
<p>如果A节点宕机，就需要让C节点和D节点重新指向B节点。</p>
<ol>
<li><p>首先切换主库需要在从库上执行<code>change master</code>命令，这个命令需要指定<a href="#binlog">binlog</a>的偏移量。</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> master_port<span class="operator">=</span>xxx master_user<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> master_password<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> master_log_file<span class="operator">=</span><span class="string">&#x27;binlog.0001&#x27;</span> master_log_pos<span class="operator">=</span><span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>这个偏移量可以在B节点上执行<code>show master status</code>得到当前最新的<a href="#binlog">binlog</a>文件名和偏移量。</p>
</li>
</ol>
<p><b id='基于GTID的主从切换'>基于GTID的主从切换</b>：</p>
<p>首先需要在启动MySQL服务的时候，加上<code>gtid_mode=on</code>和<code>enforce_gtid_consistency=on</code>这两个参数。</p>
<p>在GTID模式下，每个事务都和一个GTID一一对应，这个GTID由MySQL实例的server_id加事务ID组成（GTID=server_id:transaction_id）</p>
<p>MySQL服务会维护一个GTID集合，用来记录这个实例执行过的所有事务，同步数据时会自动跳过已经执行过的事务。</p>
<p>在GTID模式下切换主库，只需要把<code>change master</code>命令中的<code>MASTER_LOG_FILE</code>和<code>MASTER_LOG_POS</code>参数替换为<code>master_auto_position=1</code>就可以了。</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> master_port<span class="operator">=</span>xxx master_user<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> master_password<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> master_auto_position<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="⭐主从延迟"><a href="#⭐主从延迟" class="headerlink" title="⭐主从延迟"></a>⭐主从延迟</h4><p>其实所有主从架构都有主从延迟的问题，如果从节点同步数据的速度低于主节点生成数据的速度，就会出现延迟。常见的原因有：网络延迟、或者从库服务器性能比较低，都有可能出现过期读的问题。</p>
<p>MySQL中过期读的解决方案主要有：<a href="#%E5%BC%BA%E5%88%B6%E8%B5%B0%E4%B8%BB%E5%BA%93">强制走主库</a>、<a href="#sleep">sleep</a>、<a href="#%E5%88%A4%E6%96%AD%E4%B8%BB%E5%A4%87%E6%97%A0%E5%BB%B6%E8%BF%9F">判断主备无延迟</a>、<a href="#semi-sync">semi-sync方案</a>、<a href="#%E7%AD%89%E5%BE%85%E4%B8%BB%E5%BA%93%E4%BD%8D%E7%82%B9">等待主库位点</a>、<a href="#%E7%AD%89%E5%BE%85GTID">等待GTID</a>。</p>
<p><b id='强制走主库'>强制走主库</b>：</p>
<p>就是对查询请求分类，对于可以接受过期读的场景就在从库上查询，对于无法接受过期读的场景就在主库上查询。</p>
<p>但是对于数据实时性特别高的项目，可能大部分查询都不能是过期读，这样就只能放弃读写分离了。</p>
<p><b id='sleep'>sleep方案</b>：</p>
<p>就是主库更新之后，查询从库的时候先slepp一下，不过这种方案没办法保证一定不会出现过期读，而且效率太低。</p>
<p><b id='判断主备无延迟'>判断主备无延迟</b>：</p>
<p>在从库执行<code>show slave status</code>命令，返回结果里面会显示<code>second_behind_master</code>字段，这个字段表示当前备库延迟了多少秒。</p>
<blockquote>
<p><code>second_behind_master</code>的计算方法是这样的：</p>
<ol>
<li>首先每个事务的binlog都有一个时间字段，记录的是binlog的生成时间。</li>
<li>从库会读取binlog的生成时间，与系统时间做比较，就可以得到主从库延迟了多久。</li>
</ol>
</blockquote>
<p>每次执行查询请求之前，先执行<code>show slave status</code>命令，判断<code>second_behind_master</code>是否为0，如果为0就在从库上查询，否则就在主库上查询。</p>
<p><b id='semi-sync'>semi-sync方案</b>：</p>
<p>semi-sync是半同步复制，它的逻辑是这样的：</p>
<ol>
<li>首先事务提交的时候，主库会把binlog发送给从库。</li>
<li>从库收到binlog以后，给主库发送一个确认信息，表示收到了。</li>
<li>主库收到确认信息以后，才会给客户端返回“事务完成”的确认。</li>
</ol>
<p>也就是说，如果开启了semi-sync，就表示所有给客户端返回成功的事务，从库都已经收到了。这样就可以避免过期读。</p>
<blockquote>
<p>semi-sync开启方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span>安装插件</span><br><span class="line">install plugin rpl_semi_sync_master SONAME <span class="string">&#x27;semisync_master.so&#x27;</span>; </span><br><span class="line"># <span class="number">2.</span>开启半同步</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> rpl_semi_sync_master_enabled <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是在一主多从的场景下，主库只要等到一个从库的确认消息，就会给客户端响应成功。如果查询请求落到了没有收到binlog的从库上，还是会有过期读的问题。</p>
<p><b id='等待主库位点'>等待主库位点</b>：</p>
<ol>
<li><p>主库更新完数据后，马上执行<code>show master status</code>命令，得到当前主库最新的binlog文件和偏移量（file和position的值）。</p>
</li>
<li><p>然后在从库上执行<code>select master_pos_wait(file, pos)</code>命令，将查询主库得到的binlog文件和偏移量传递进去。</p>
<blockquote>
<p><code>select master_pos_wait(file, pos, [timeout])</code>命令会返回一个数字，表示从指定的binlog位置与当前最新的binlog位置，执行了多少事务。如果没有执行到指定的binlog位置，就返回0，超时返回-1。</p>
</blockquote>
</li>
<li><p>如果返回值是大于等于0的数字，就说明从库已经执行过这个binlog了。就可以在从库上查询，否则就到主库上查询。</p>
</li>
</ol>
<p><b id='等待GTID'>等待GTID</b>：</p>
<ol>
<li><p>主库更新完数据后，马上执行<code>show master status</code>命令，得到最新的GTID（executed_gtid_set）。</p>
</li>
<li><p>然后在从库上执行<code>select wait_for_executed_gtid_set(gtid, 1)</code>，并且把主库的GTID传递进去。</p>
<blockquote>
<p><code>select wait_for_executed_gtid_set(gtid, 1)</code>这条命令逻辑是：等这个数据库执行完GTID对应的事务之后，返回0，超时返回1。</p>
</blockquote>
</li>
<li><p>如果返回值是0，就可以在从库上查询。</p>
</li>
</ol>
<blockquote>
<p>开启GTID：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="variable">@GLOBAL</span>.ENFORCE_GTID_CONSISTENCY <span class="operator">=</span> <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@GLOBAL</span>.GTID_MODE <span class="operator">=</span> OFF_PERMISSIVE;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@GLOBAL</span>.GTID_MODE <span class="operator">=</span> ON_PERMISSIVE;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@GLOBAL</span>.GTID_MODE <span class="operator">=</span> <span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="⭐全表扫描的影响"><a href="#⭐全表扫描的影响" class="headerlink" title="⭐全表扫描的影响"></a>⭐全表扫描的影响</h3><p>InnoDB内存中的数据页是通过Buffer Pool管理的，Buffer Pool可以起到加速查询的作用，具体的加速效果，主要依赖于<strong>内存命中率</strong>。</p>
<blockquote>
<p>Buffer Pool的大小可以通过参数<code>innodb_buffer_pool_size</code>修改，一般可以设置为物理内存的60%~80%.</p>
</blockquote>
<p>可以通过<code>show engine innodb status</code>查看当前系统的内存命中率。</p>
<blockquote>
<p>其中<code>Buffer pool hit rate 990 / 1000</code>显示的就是内存命中率（990 / 1000表示内存命中率为99%）</p>
</blockquote>
<p>Buffer Pool是通过LRU算法来管理内存的，这个算法的核心就是淘汰最久没有使用的数据。</p>
<blockquote>
<p>LRU算法通常是用链表实现的，链表的头部代表最常使用的数据，链表的尾部代表最不经常使用的数据。在删除数据的时候，会从链表的尾部开始删除。</p>
</blockquote>
<p>如果使用传统的LRU算法，假设我们要全表扫描一个历史表，就会导致Buffer Pool中的数据页全部被淘汰掉。这个时候Buffer Pool的内存命中率就会急剧下降，磁盘压力也会增加，SQL语句的响应会变慢。</p>
<p>所以InnoDB对LRU算法做了改进：</p>
<p>InnoDB按照5:3的比例把整个LRU链表分成了young区域和old区域（链表头部是young区域，链表尾部是old区域）</p>
<ol>
<li><p>如果要访问处于young区域的数据页，就会把该数据页移到链表头部。</p>
</li>
<li><p>如果要访问一个不在链表中的数据页，就会淘汰掉链表尾部的数据页，但是新插入的数据页是存在old区域的头部位置。</p>
</li>
<li><p>处于old区域的数据页，每次访问的时候都要判断：</p>
<ul>
<li><p>如果这个数据页在LRU链表中存活时间超过1秒，就把它移动到链表头部。</p>
</li>
<li><p>如果这个数据页在链表中存活时间小于1秒，位置就保持不变。</p>
<blockquote>
<p>数据页的存活时间可以通过参数<code>innodb_old_blocks_time</code>调整，默认是1000，单位是毫秒。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>改进后的LRU算法应对大量冷数据扫描时的逻辑是这样的：</p>
<ol>
<li>扫描过程中，需要插入新的数据页，都会被放到old区域。</li>
<li>一个数据页中会有多条记录，也就是说这个数据页会被访问多次，但是数据页内部的记录是有序的，所以数据页从上到下访问第一条记录到最后一条记录之间的时间间隔不会超过1秒，所以这个数据页不会进入到young区域，很快就会被淘汰出去。</li>
</ol>
<p>改进后的LRU算法可以把大部分比较热的数据继续保留在内存中，从而保证内存命中率。</p>
<h3 id="Join有哪些问题"><a href="#Join有哪些问题" class="headerlink" title="Join有哪些问题"></a>Join有哪些问题</h3><p>join的执行流程是这样的：</p>
<ol>
<li>首先从驱动表（最左边的表）读取一行数据。</li>
<li>然后从数据行中取出关联字段，到被驱动表中去查询符合条件的记录。</li>
<li>重复前面的步骤，直到驱动表循环结束。</li>
</ol>
<p>在这个过程中，<strong>对被驱动表的访问次数主要取决于驱动表的扫描行数，所以应该让小表作为驱动表</strong>。</p>
<blockquote>
<p>这里的<strong>小表</strong>按照各自的过滤条件，过滤完成之后，实际参与join关联的数据量。数据量小的就是小表。</p>
</blockquote>
<p>其次，如果被驱动表的关联字段没有索引，join算法会先把驱动表中的数据暂存到join_buffer中，然后对被驱动表做全表扫描，和join_buffer中的数据做比对，join的流程就会变成这样：</p>
<ol>
<li><p>首先把驱动表的数据存到join_buffer中，直到join_buffer存满。</p>
<blockquote>
<p>join_buffer默认是256k，可以通过参数<code>join_buffer_size</code>修改。</p>
</blockquote>
</li>
<li><p>对被驱动表做全表扫描，把每一行数据都跟join_buffer中的数据做对比，判断是否满足条件</p>
</li>
<li><p>清空join_buffer</p>
</li>
<li><p>重复执行前面的步骤，直到驱动表循环结束。</p>
</li>
</ol>
<p>在这个过程中，<strong>对被驱动表的扫描次数取决于驱动表需要写几次join_buffer，如果join_buffer能够放下驱动表的所有数据，只需要扫描一次被驱动表就可以了。所以对于join操作比较多的数据库，可以增加join_buffer的大小，还应该在关联字段上建立索引</strong>。</p>
<blockquote>
<p>如果没有join_buffer，就会导致驱动表中的每一条数据都会被驱动表做一次全表扫描，假设驱动表有100条数据，从表有1万条数据，就会对被驱动表做100次全表扫描，总扫描行数就是100万行。</p>
</blockquote>
<h3 id="分区表有哪些问题"><a href="#分区表有哪些问题" class="headerlink" title="分区表有哪些问题"></a>分区表有哪些问题</h3><blockquote>
<p>Range分区语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">`ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">KEY (`ftime`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"><span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"><span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"><span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> LESS THAN MAXVALUE ENGINE <span class="operator">=</span> InnoDB);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>MySQL有三种分区：Range分区、Hash分区、List分区。</p>
<p>分区表的优点是可以方便的清理历史数据，如果是按照时间分区的分区表，可以直接删除掉整个分区，从而删除历史数据。</p>
<blockquote>
<p><code>alter table t drop partition ...</code></p>
</blockquote>
<p>需要注意的是，如果需要跨多个分区查询数据，性能会比较慢，这种情况需要重新考虑分区的维度。</p>
<p>另外分区表通常都很大，DDL会非常耗时，尽量避免修改表结构。</p>
<h3 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h3><p>explain的结果集包含如下信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<p>⭐<strong>id</strong>：用来表示select语句的顺序。</p>
<ol>
<li>id越大的越先执行。</li>
<li>如果id相同，从上往下依次执行。</li>
</ol>
<p>⭐<strong>select_type</strong>：</p>
<ul>
<li><strong>simple</strong>：简单的select查询，没有union或者子查询。</li>
<li><strong>primary</strong>：最外层的select查询。</li>
<li><strong>union</strong>：union中的第二个或随后的select查询，不依赖于外部查询的结果集</li>
<li><strong>dependent union</strong>：union中的第二个或随后的select查询，依赖于外部查询的结果集</li>
<li><strong>subquery</strong>：子查询中的第一个select查询，不依赖与外部查询的结果集</li>
<li><strong>dependent subquery：</strong> 子查询中的第一个select查询，依赖于外部查询的结果集</li>
<li><strong>derived</strong>：用于from子句中有子查询的情况，mysql会递归执行这些子查询，此结果集放在临时表中</li>
</ul>
<p>⭐<strong>table</strong>：表示输出行所引用的表名</p>
<p>⭐<strong>type</strong>：效率从上到下依次排序。</p>
<ul>
<li><p><strong>system：</strong> 表仅有一行，是const类型的一个特例。</p>
</li>
<li><p><strong>const：</strong> 确定只有一行匹配的时候，mysql优化器会在查询前读取它并且只读取一次，速度非常快。</p>
</li>
<li><p><strong>eq_ref：</strong> 对于每个来自于前面的表的行组合，从该表中读取一行，常用在一个索引是unique key或者primary key。</p>
</li>
<li><p><strong>ref：</strong> 对于来自前面的表的行组合，所有有匹配索引值的行都从这张表中读取,如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。</p>
<blockquote>
<p>ref可以用于使用=或&lt;=&gt;操作符的带索引的列</p>
</blockquote>
</li>
<li><p><strong>ref_or_null：</strong> 类似ref，但是添加了可以专门搜索null值的行。</p>
</li>
<li><p><strong>index_merge：</strong> 该访问类型使用了索引合并优化方法，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素</p>
<blockquote>
<p>查询条件都有单列索引，如果出现index_merge，并且这类SQL后期使用较频繁，可以考虑把单列索引换为组合索引，这样效率更高</p>
</blockquote>
</li>
<li><p><strong>range：</strong> 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。</p>
<blockquote>
<p>当查询条件有索引，并且使用=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN或者IN操作符，才会使用range</p>
</blockquote>
</li>
<li><p><strong>index：</strong> 在进行统计时非常常见，这种类型实际上会扫描索引树。（比如count、sum、avg之类的函数）</p>
</li>
<li><p><strong>all：</strong> 全表扫描</p>
<blockquote>
<p>通常可以通过对查询条件字段添加索引的方式避免全表扫描。</p>
</blockquote>
</li>
</ul>
<p>⭐<strong>possible_keys</strong>：mysql可以使用这个索引去辅助查找记录。若为空则表示没有可以使用的索引，可以通过检查where语句看是否可以引用某些列或者新建索引来提高性能。</p>
<p>⭐<strong>key</strong>：key列显示的是当前表实际使用的索引，如果没有选择索引，则此列为null。</p>
<blockquote>
<p>要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用<strong>FORCE INDEX</strong>、<strong>USE INDEX</strong>或者<strong>IGNORE INDEX</strong>。</p>
</blockquote>
<p>⭐<strong>key_len</strong>：表示MySQL决定使用的键长度。如果KEY键是NULL，则长度为NULL。<strong>在不损失精确性的情况下，长度越短越好</strong>。</p>
<blockquote>
<p>key len的长度还和字符集有关,latin1一个字符占用1个字节,gbk一个字符占用2个字节,utf8一个字符占用3个字节。</p>
</blockquote>
<p>⭐<strong>ref</strong>：用来显示使用哪个列或常数与key一起从表中选择相应的行。它显示的列的名字（或const），此列多数时候为null</p>
<p>⭐<strong>rows</strong>：显示的是mysql解析器认为执行此SQL时必须扫描的行数。此数值为一个预估值，不是具体值，通常比实际值小</p>
<p>⭐<strong>filtered</strong>：mysql 5.7 新的加参数，指的是返回结果的行数所占需要读到的行（rows的值）的比例 对于使用join时，前一个表的结果集大小直接影响了循环的行数。</p>
<p>⭐<strong>Extra</strong>：extra表示不在其他列并且也很重要的额外信息。</p>
<ul>
<li><p><strong>using index：</strong> 该值表示这个SQL语句使用了覆盖索引，效率很高。</p>
</li>
<li><p><strong>using where：</strong> 表示存储引擎搜到记录后进行了后过滤，如果查询未能使用索引，using where的作用只是提醒我们mysql要用where条件过滤结果集。</p>
</li>
<li><p><strong>using temporary</strong>：表示mysql需要使用临时表来存储结果集，常见于排序和分组查询。</p>
</li>
<li><p><strong>using filesort</strong>：是指mysql无法利用索引直接完成排序（排序的字段不是索引字段），此时会用到缓冲空间来进行排序。</p>
</li>
<li><p><strong>using join buffer</strong>：在获取连接条件时没有用到索引，并且需要连接缓冲区来存储中间结果。（性能可以通过添加索引或者修改连接字段改进）</p>
<blockquote>
<p>Block Nested Loop是指Block Nested-Loop Join算法：将外层循环的行/结果集存入join buffer, 内层循环的每一行与整个buffer中的记录做比较，从而减少内层循环的次数.</p>
</blockquote>
</li>
<li><p><strong>impossible where：</strong> 表示where条件导致没有返回的行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/12/08/Redis/</url>
    <content><![CDATA[<h3 id="⭐哈希冲突"><a href="#⭐哈希冲突" class="headerlink" title="⭐哈希冲突"></a>⭐哈希冲突</h3><p>哈希冲突是指，两个key的哈希值和哈希桶计算对应关系的时候，正好落在了同一个哈希桶中。这是哈希表没法避免的问题。</p>
<p><strong>Redis解决哈希冲突的方式是链表，就是同一个哈希桶中的多个元素用一个链表来保存</strong>。</p>
<p>但是如果哈希冲突越来越多，就会导致某些哈希桶上的链表特别长，就导致在这些哈希桶上查找数据变得很慢。Redis的解决方案是<a href="#rehash">rehash</a>。</p>
<p>⭐<b id='rehash'>rehash</b>：rehash操作就是为了增加现有哈希桶的数量，让元素能在更多的哈希桶之间分散保存。</p>
<p>为了让rehash更加高效，Redis使用了两个全局哈希表，默认使用的是哈希表1，哈希表2不会被分配空间。Redis的rehash主要分三个步骤：</p>
<ol>
<li>给哈希表2分配更大的空间。</li>
<li>把哈希表1中的数据重新映射并拷贝到哈希表2中。</li>
<li>最后释放哈希表1的空间。</li>
</ol>
<p>这个过程会涉及到大量的数据拷贝，如果一次性把哈希表1的数据都拷贝完，会造成Redis线程的阻塞，无法服务其他请求。为了避免这个问题Redis采用了<a href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash">渐进式rehash</a>。</p>
<p><b id='渐进式rehash'>渐进式rehash</b>：就是在拷贝数据时，Redis每收到一个请求，就把这个请求操作的哈希桶中所有元素拷贝到哈希表2中。这样就可以把rehash过程分摊到多次请求中。</p>
<p>如果是查询操作，Redis会现在哈希表1里面查找，如果没找到就在哈希表2里面找。</p>
<p>如果是新增操作，Redis只会把数据新增到哈希表2中，这样就可以保证哈希表1的数据只减不增，最终所有数据都会被拷贝到哈希表2中。</p>
<h3 id="⭐Redis中的数据结构"><a href="#⭐Redis中的数据结构" class="headerlink" title="⭐Redis中的数据结构"></a>⭐Redis中的数据结构</h3><p>Redis中数据类型一共有5种：<strong>String</strong>、<strong>List</strong>、<strong>Hash</strong>、<strong>Set</strong>、<strong>Sorted Set</strong>。</p>
<p>底层的数据结构一共有6种：<a href="#%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2">简单动态字符串(SDS)</a>、<strong>双向链表</strong>、<a href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8">压缩列表</a>、<strong>哈希表</strong>、<a href="#%E8%B7%B3%E8%A1%A8">跳表</a>、<strong>数组</strong>。</p>
<p><b id='String'>String</b>：String类型的底层实现只用了一种，<a href="#%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2">简单动态字符串</a>。</p>
<p><b id='List'>List</b>：List类型有两种底层实现，双向链表和<a href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8">压缩列表</a>。</p>
<p><b id='Hash'>Hash</b>：Hash类型有两种底层实现，<a href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8">压缩列表</a>和哈希表。</p>
<p><b id='Sorted Set'>Sorted Set</b>：Sorted Set类型有两种底层实现，<a href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8">压缩列表</a>和<a href="#%E8%B7%B3%E8%A1%A8">跳表</a>。</p>
<p><b id='Set'>Set</b>：Set类型有两种底层实现，哈希表和数组。</p>
<p>⭐<b id="简单动态字符串">简单动态字符串（Simple Dynamic String）</b>：</p>
<p><strong>简单动态字符串</strong>主要有三部分组成：</p>
<ul>
<li><strong>buf</strong>：字节数组，用来保存实际的数据。会在数组结尾处加上一个 “\0” ，用来表示数组的末尾。会占用1个额外的字节。</li>
<li><strong>len</strong>：占用4个字节，表示buf的长度。</li>
<li><strong>alloc</strong>：也占用4个字节，用来表示buf实际分配的长度，一般大于len。</li>
</ul>
<p>在SDS中，只有buf保存实际的数据，len和alloc都是SDS结构的额外开销。</p>
<p>⭐<b id="压缩列表">压缩列表</b>：</p>
<p>压缩列表跟数组很像，但是比数组更节省内存，因为数组中每个元素的大小都是相同的，就需要为每个元素都分配最大元素占用的内存空间，如果大部分元素都不需要这么大的内存空间，就会浪费很多内存（因为数组需要提前知道每个元素的大小才能计算出下一个元素的位置）。</p>
<p>压缩列表就是在数组的基础上对每个元素的大小进行压缩。</p>
<p>压缩列表会维护一个表头，这个表头包含三个属性：列表长度（zlbytes）、列表尾部的偏移量（zltail）、列表中元素的个数（zllen）。</p>
<p>压缩列表会为每个元素都维护一些元数据：前一个entry的长度（pre_len）、自己的长度（len）、保存的数据类型（encoding）、content（实际保存的数据）。</p>
<p>⭐<b id='跳表'>跳表</b>：</p>
<p><strong>跳表是在链表的基础上，增加了多级索引，通过索引位置的跳转，可以快速定位到数据</strong>。</p>
<blockquote>
<p>假设链表中十个元素。如果要在链表中查找8这个元素，就只能从头开始遍历，需要查找8次，效率比较低。复杂度是O(N)。</p>
<p>可以通过增加索引的方式来提升查找速度：从第一个元素开始，每两个元素选出来一个索引。这些索引再通过指针指向原来的链表。</p>
<p>比如在，1和2中选择1作为索引，从3和4中选择3作为索引，5和6中选择5作为索引，这样就只需要遍历1、3、5、7、8就可以查找到8了，只需要5次查询。</p>
<p>如果还想更快点，可以在一级索引的基础上增加二级索引：从一级索引中每两个元素建立一个索引，这些索引再指向一级索引。</p>
<p>跳表的时间复杂度是O(logN)</p>
</blockquote>
<h3 id="⭐AOF日志"><a href="#⭐AOF日志" class="headerlink" title="⭐AOF日志"></a>⭐AOF日志</h3><p>AOF日志里面记录的是Redis收到的每一条写命令，这些命令是以文本形式保存的。Redis采用的是<a href="#%E5%85%88%E5%86%99%E5%86%85%E5%AD%98%E5%90%8E%E5%86%99%E6%97%A5%E5%BF%97">先写内存后写日志</a>的方式。</p>
<p>因为AOF日志是以文件的形式保存的，写命令越多，AOF文件就越大。AOF日志大小超过限制就会触发<a href="#AOF%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6">AOF重写机制</a>。</p>
<p>AOF日志过大带来的问题：</p>
<ol>
<li>占用更多磁盘空间</li>
<li>大文件会导致写效率变低。</li>
<li>会导致恢复数据变得很慢。</li>
</ol>
<p>AOF是默认关闭的，可以通过<code>appendonly</code>参数开启。RDB和AOF同时开启的情况下，会优先使用AOF恢复数据。</p>
<p>⭐<b id='先写内存后写日志'>先写内存后写日志</b>：</p>
<p>先写内存后写日志这种方式的好处是：可以避免语法检查的额外开销，而且AOF是在命令执行之后才记录日志的，所以不会对当前操作的性能有影响。但是会对下一条操作有影响，因为往AOF记录日志是主线程进行的，磁盘压力比较大导致写日志速度比较慢，就会导致后续的操作阻塞。而且如果一个命令刚执行完，还没来得及记录日志就宕机了，那这个命令对应的数据就会丢失。</p>
<p>AOF提供了三个选项，可以通过<code>appendfsync</code>参数控制AOF写日志的时机：</p>
<ul>
<li><strong>Always</strong>：同步写回，每个写请求都会对应一次写日志的操作，会影响Redis性能，最多会丢失一条命令的数据。</li>
<li><strong>Everysec</strong>：每秒写回，Redis会先把写请求记录到AOF内存缓冲区，每隔一秒就把缓冲区的内容写到磁盘上，可能会丢失1秒的数据。</li>
<li><strong>No</strong>：由操作系统来控制写回，Redis会先把请求记录到AOF内存缓冲区，由操作系统来决定什么时候把缓冲区的内容写到磁盘上（通常是系统比较空闲的时候）。</li>
</ul>
<p>⭐<strong>AOF重写机制触发规则</strong>：</p>
<ol>
<li>可以通过<code>bgrewriteaof</code>命令手动触发AOF重写。</li>
<li>也可以通过调整Redis参数来控制AOF触发时机：需要同时满足<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-precentage</code>两个参数<ul>
<li><code>auto-aof-rewrite-min-size</code>：表示触发AOF重写时，文件的最小大小，默认为64MB。</li>
<li><code>auto-aof-rewrite-precentage</code>：当前AOF文件与上一次AOF文件重写后的大小的比值，默认是100%。也就是说如果当前AOF日志是10MB，上一次AOF文件重写之后是20MB，那么当前AOF文件需要增长到40MB才满足AOF重写机制。</li>
</ul>
</li>
</ol>
<p>⭐<b id='AOF重写机制'>AOF重写机制</b>：</p>
<p>AOF重写就是把Redis中当前所有数据转换成写命令，然后再记录到AOF日志中。</p>
<p>因为当前数据库中的一条数据可能会对应AOF日志中多个命令，比如原本是name=张三，然后被改成name=李四。name=李四这条数据在AOF日志中就有两条命令。重写时只需要保存name=李四这一条命令就可以了。这样就可以减少AOF日志的大小。</p>
<p>重写是通过后台进程（bgrewriteaof）来完成的，所以不会影响主线程处理请求的性能。</p>
<p>重写过程大概是这样的：</p>
<ol>
<li>首先主线程会创建一个后台进程，然后把内存中的数据拷贝一份给这个后台进程。然后后台进程再把数据转换成写命令记录到新的日志中。</li>
<li>重写过程中，主线程如果接收到新的写命令，Redis会把命令记录同时记录到旧的AOF日志和AOF缓冲区中。</li>
<li>等重写完成后，再把新收到的命令记录到新的AOF日志中。</li>
<li>然后就可以用新日志替换旧日志了。</li>
</ol>
<h3 id="⭐RDB内存快照"><a href="#⭐RDB内存快照" class="headerlink" title="⭐RDB内存快照"></a>⭐<span id='RDB内存快照'>RDB内存快照</span></h3><p>内存快照就是把，数据库中某一时刻所有数据的状态保存到磁盘上。</p>
<p>RDB记录的是某一时刻的数据，可以直接把RDB文件读到内存，恢复数据的效率很高。</p>
<p>Redis提供了两个命令生成RDB文件，<code>save</code>和<code>bgsave</code>：</p>
<ul>
<li><strong>save</strong>：在主线程执行，会阻塞主线程。</li>
<li><strong>bgsave</strong>：会创建一个后台进程，专门用来写RDB文件，可以避免主线程被阻塞。Redis默认用的是<strong>bgsave</strong>。</li>
</ul>
<p>在生成RDB文件时，如果主线程接收到了写命令，那这条写命令对应的数据就会被复制一份，生成一个副本。后台进程会把这个副本一起写进RDB文件中，这样就可以保证快照的完整性。</p>
<p>⭐<b id='内存快照的频率'>内存快照的频率</b>：</p>
<p>如果频率太高：每次生成内存快照都会把全量数据写到磁盘上，会给磁盘带来很大压力。而且后台进程是主线程创建出来的，创建的过程本身是会阻塞主线程的，如果快照生成频率过高，就会频繁创建进程，就会很频繁的阻塞主线程。</p>
<p>如果频率太低：两次快照生成时间间隔较长，如果服务宕机，就会丢失很多数据。</p>
<h3 id="⭐混合模式"><a href="#⭐混合模式" class="headerlink" title="⭐混合模式"></a>⭐混合模式</h3><p>⭐<strong>Redis4.0版本新增了混合使用AOF和RDB的机制，就是在两次快照之间，用AOF日志记录这期间的所有命令，等下一次快照执行完再清空AOF日志</strong>。（可以通过<code>aof-use-rdb-preamble</code>参数开启）</p>
<p>这样可以降低<a href="#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7%E7%9A%84%E9%A2%91%E7%8E%87">内存快照的频率</a>，而且AOF日志也只需要记录两次快照之间的操作，不会出现文件过大的情况。</p>
<p>在混合模式下，AOF重写时，后台进程会先把内存中的数据以RDB的格式写入到AOF文件中，再把AOF缓冲区中的命令以AOF的格式写到文件中。</p>
<p>这样新的AOF文件就会包含RDB格式的数据和AOF格式的数据，在恢复数据时，会先加载RDB格式的数据，然后再执行AOF格式的操作命令。</p>
<h3 id="⭐主从集群"><a href="#⭐主从集群" class="headerlink" title="⭐主从集群"></a>⭐主从集群</h3><p>Redis提供了主从模式。在从库上执行<code>replicaof 127.0.0.1(主库ip) 6379(主库端口)</code>。</p>
<p>通常情况下主库负责写操作，然后再把写操作同步给从库。从库只负责读操作。</p>
<p>Redis2.6版本之后，从库默认是只读的，可以通过<code>slave-read-only</code>参数修改。</p>
<p>⭐<b id='主从同步原理'>主从同步原理</b>：</p>
<ol>
<li><p>主从库建立连接后，从库会给主库发送<code>psync</code>命令，表示要进行数据同步。<code>psync</code>命令包含<strong>ID</strong>和<strong>offset</strong>两个参数。</p>
<blockquote>
<p><strong>ID</strong>：每个Redis实例启动时都会自动生成一个随机ID。主库和从库第一次同步数据时，从库不知道主库的ID，所以此时ID的值为”?”。</p>
<p><strong>offset</strong>：复制进度。第一次同步数据时，offset为-1。</p>
</blockquote>
</li>
<li><p>主库收到<code>psync</code>命令后，如果是第一次同步，主库会用<code>FULLRESYNC</code>命令给从库返回响应。</p>
<blockquote>
<p><strong>FULLRESYNC</strong>：表示全量同步，这个命令包含两个参数：<strong>主库ID</strong>和<strong>复制进度offset</strong>。</p>
</blockquote>
</li>
<li><p>从库收到响应后会把这两个参数记录下来。</p>
</li>
<li><p>主库将数据同步给从库，这个过程需要依赖<a href="#RDB%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7"><strong>内存快照</strong></a>生成的RDB文件。主库会先执行<code>bgsave</code>命令生成RDB文件，然后再把文件发送给从库。</p>
<blockquote>
<p>Redis可以先把RDB文件写到磁盘上，再发送给从库。也可以直接通过socket把RDB文件发送给从库（无需落盘）。</p>
<p>可以通过参数<code>repl-diskless-sync</code>开启无盘传输。默认是关闭的。</p>
</blockquote>
</li>
<li><p>从库接收到RDB文件后，会先清空当前数据库，然后加载RDB文件。</p>
</li>
<li><p>主库发送RDB文件的过程中，如果又接收到了新的写命令，就会把这些命令记录到<strong>replication buffer</strong>中。</p>
</li>
<li><p>最后主库再把<strong>replication buffer</strong>中的命令发送给从库。</p>
</li>
</ol>
<p>执行全量数据同步，对于主库来说主要有两个操作：<strong>生成RDB文件</strong>和<strong>传输RDB文件</strong>。生成RDB文件需要创建后台进程，这个过程会阻塞主线程。而且传输RDB文件也会占用网络带宽。如果从库的数量比较多，就会对主库性能产生影响。可以通过主从级联模式缓解数据同步时主库的压力。</p>
<p>⭐<b id='主从级联模式'>主从级联模式</b>：</p>
<p>可以选择一个配置比较高的从库，让其他从库和这个从库建立主从关系。这样就可以把一部分数据同步的压力分摊到从库上。</p>
<p>⭐<b id='主从连接中断'>主从连接中断</b>：</p>
<p>在Redis2.8版本之前，如果主从库连接中断，再次连接后主从库就会进行一次全量数据同步。</p>
<p>Redis2.8版本之后，主库会采用<a href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5">增量同步</a>的方式。</p>
<p>⭐<b id='增量同步'>增量同步</b>：主库只会把连接中断期间收到的命令同步给从库。</p>
<ol>
<li><p>主从库断开连接后，主库会把期间收到的写命令写到<strong>repl_backlog_buffer</strong>中。</p>
<blockquote>
<p><strong>repl_backlog_buffer</strong>：是一个环形缓冲区，主库会记录自己写到的位置（master_repl_offset），从库会记录自己读到的位置（slave_repl_offset）。</p>
</blockquote>
</li>
<li><p>主从库恢复连接之后，从库会发送<code>psync</code>命令，并且把当前<strong>repl_backlog_buffer</strong>的偏移量发送给主库。</p>
</li>
<li><p>主库会判断自己的偏移量与从库偏移量之间的差距。如果差距超过了缓冲区的大小，就说明缓冲区中没有被读取的操作被覆盖过，这种情况就需要重新执行全量数据同步了。</p>
<blockquote>
<p>可以通过<code>repl_backlog_size</code>这个参数，调整缓冲区的大小，来减少全量数据同步的次数。</p>
</blockquote>
</li>
</ol>
<p>⭐<strong>主从数据不一致</strong>？</p>
<p>因为<strong>主从库之间的数据同步是异步进行的</strong>，主库执行完写命令之后，并不会等从库同步完数据后再给客户端返回结果。而且从库需要先处理完当前收到的请求，才会执行主库发送的写命令。如果从库正在执行<code>keys *</code>之类的耗时比较长的命令，就有可能导致客户端读到旧数据。</p>
<p>解决办法：</p>
<p>可以开发一个服务来监控主从库之间的数据同步进度，可以通过<code>INFO replication</code>命令获取主库写数据的进度（master_repl_offset）和从库复制数据的进度（slave_repl_offset），然后比较主从库数据同步的差值，如果差值比较大，就可以把读请求发送到主库上执行。</p>
<h3 id="⭐哨兵集群"><a href="#⭐哨兵集群" class="headerlink" title="⭐哨兵集群"></a>⭐哨兵集群</h3><p>哨兵实际上就是一个特殊的Redis实例，它主要负责：<a href="#%E7%9B%91%E6%8E%A7"><strong>监控</strong></a>、<a href="#%E9%80%89%E6%8B%A9%E4%B8%BB%E5%BA%93"><strong>选择主库</strong></a>和<a href="#%E9%80%9A%E7%9F%A5"><strong>通知</strong></a>。</p>
<p>哨兵集群之间的相互发现需要依赖于Redis的发布/订阅机制（pub/sub）。主库上有一个<code>__sentinel__:hello</code>的频道，哨兵和主库建立连接之后，就会在这个频道上发布自己的连接信息（IP和端口），同时也会订阅这个频道，来获取其它哨兵的连接信息。</p>
<p><strong>哨兵如何获取从库的IP和端口</strong>？</p>
<p>哨兵会向主库发送<code>INFO</code>命令来获取从库的信息，主库在接收到INFO命令之后，会把从库列表发送给哨兵，哨兵就会根据从库列表中的连接信息，和每一个从库建立连接，对这些从库进行监控。</p>
<p>⭐<b id='监控'>监控</b>：</p>
<p>哨兵会周期性的给所有节点发送<code>PING</code>命令，如果哨兵没有在规定时间收到响应，哨兵就会把这个节点标记为下线状态。</p>
<p>如果被标记为下线状态的节点是主库，哨兵就会开启切换主库的流程。</p>
<p>可以通过参数<code>down-after-milliseconds</code>调整哨兵监控周期。</p>
<p>但是哨兵是会有误判的（比如网络压力较大导致哨兵没有及时收到响应），如果被误判的是从库对集群的影响不会太大。如果被误判的是主库就会开始切换主库的流程，选择主库的过程开销就比较大了。可以通过部署多个哨兵一起来判断，降低误判概率。</p>
<p>在哨兵集群中，当某个哨兵与主库连接中断后，就会通知其它哨兵节点主库已下线，其它哨兵会根据自己和主库的连接情况投出赞成票（Y）或反对票（Ｎ）。当赞成票的数量达到<code>quorum</code>参数后，主库就会被标记为下线状态。</p>
<p>⭐<b id='选择主库'>选择主库</b>：</p>
<p>在选择主库的过程中，读请求可以在从库上正常执行，写请求会失败。</p>
<p>选择主库的过程可以分为<strong>筛选</strong>和<strong>打分</strong>两个阶段。</p>
<ul>
<li><p>筛选阶段：主要是判断节点的网络连接状态，如果断开连接的次数比较多，哨兵就会认为这个从库的网络状态不是很好，就会把这个节点筛选掉。</p>
</li>
<li><p>打分阶段：打分分为三轮，只要在任何一轮有从库得到了最高分，这个从库就会被选为主库。</p>
<ol>
<li><p>根据优先级来打分，可以通过<code>slave-priority</code>参数设置优先级。可以给配置比较高的节点分配更高的优先级。</p>
</li>
<li><p>根据数据同步进度来打分，在主从库数据同步时，从库会记录当前数据同步的进度，哨兵会比较所有从库的数据同步进度，谁的数据多谁就会成为主库。</p>
</li>
<li><p>根据节点ID来打分，ID号小的会成为主库。</p>
</li>
</ol>
</li>
</ul>
<p>在哨兵集群中，发现主库下线的哨兵会主动向其它哨兵发送命令，希望由自己来执行主从切换，其它哨兵会进行投票。这个过程也叫Leader选举。</p>
<p>想要成为Leader哨兵，需要满足两个条件：</p>
<ol>
<li>拿到半数以上的赞成票。</li>
<li>拿到的票数必须大于等于<code>quorum</code>参数。</li>
</ol>
<p>如果选举失败，哨兵集群会等待一段时间，再重新选举。</p>
<p>需要注意的是：如果哨兵集群只有2个节点，必须要拿到2票才能成为Leader，如果其中有一个哨兵挂掉了，就没办法切换主库了。所以通常至少要配置3个哨兵节点。</p>
<p>⭐<b id='通知'>通知</b>：</p>
<p>新的主库选出来之后，哨兵会把新主库的连接信息发送给所有从库，让它们执行<code>replicaof</code>命令与新主库建立连接并同步数据。</p>
<p>哨兵还会把新主库的连接信息发送给客户端，客户端可以通过订阅<code>switch-master</code>频道来获取主从切换的事件。</p>
<p>客户端也可以主动获取新的主从地址，所以在哨兵模式下，客户端不能直接写死主从库的地址了，需要使用<code>sentinel get-master-addr-by-name</code>命令获取新地址。</p>
<h3 id="⭐切片集群"><a href="#⭐切片集群" class="headerlink" title="⭐切片集群"></a>⭐切片集群</h3><p><strong>切片集群就是把数据拆分成多份，每一份都分别用一个实例来保存，Redis3.0版本提供了Redis Cluster切片集群方案</strong>。</p>
<p>Redis Cluster通过哈希槽来处理数据与Redis节点的<a href="#%E5%93%88%E5%B8%8C%E6%A7%BD%E6%98%A0%E5%B0%84">映射</a>关系，一个切片集群一共有16384个哈希槽，这些哈希槽可以理解为数据分区，每一个键值对都会根据它的key，被映射到一个哈希槽中。</p>
<p>客户端与集群建立连接之后，集群就会把哈希槽的分配信息发送给客户端，客户端会把哈希槽信息缓存在本地，当客户端请求键值对时，会先计算数据对应的哈希槽，然后就可以根据哈希槽向对应的节点发送请求了。</p>
<p>如果需要新增节点或者删除节点，就需要重新分配哈希槽。哈希槽对应的数据也需要迁移。在集群内部，节点之间可以相互通信来获得最新的哈希槽的映射关系。</p>
<p>这种情况下，客户端维护的哈希槽信息就是错误的了，Redis Cluster提供了一种<a href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%9C%BA%E5%88%B6">重定向机制</a>。</p>
<p>⭐<strong>故障处理机制</strong>：</p>
<p>通常情况下，集群中每个节点都会配置为主从模式，当某一个主节点没有和其它节点完成<code>PING</code>通信，就会被标记为主观下线，然后通知其它节点，其他节点会根据自己与该节点的连接情况进行投票，投票通过后该主节点就会被标记为客观下线。然后开始主从切换，等原来的主节点恢复以后，会自动成为新主节点的从节点。</p>
<p>如果主节点没有从节点，主节点挂了的话，整个集群就会处于不可用的状态。</p>
<p>⭐<b id='哈希槽映射'>哈希槽映射</b>：</p>
<p>首先根据键值对的key，通过<code>CRC16算法</code>计算出一个16位的值。然后再用这个值和16384取模，就可以得到一个0~16383范围内的数字。这个数字就代表这个键值对对应的哈希槽。</p>
<p>默认情况下切片集群会自动把16384个哈希槽平均分布在集群所有节点上，集群中的每个节点内部都会保存哈希槽和Redis节点的对应关系。</p>
<p>⭐<b id='重定向机制'>重定向机制</b>：</p>
<p>就是客户端给一个节点发送读写操作时，如果这个节点上没有对应的数据，这个节点就会给客户端返回<code>MOVED</code>命令，这个命令会包含键值对所在的节点信息。客户端也会更新本地缓存的哈希槽信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET hello:key</span><br><span class="line">(error) MOVED 13320（哈希槽） 172.16.19.5:6379（节点信息）</span><br></pre></td></tr></table></figure>



<p>还有一种情况是，哈希槽重新映射之后，数据还没有迁移完成，客户端就会收到一条<code>ASK</code>命令，这个命令会包含数据所在的节点信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET hello:key</span><br><span class="line">(error) ASK 13320 172.16.19.5:6379</span><br></pre></td></tr></table></figure>

<p>客户端需要再向新节点发送<code>ASKING</code>命令，这个命令表示让新节点处理客户端的请求。</p>
<h3 id="⭐Redis内存优化"><a href="#⭐Redis内存优化" class="headerlink" title="⭐Redis内存优化"></a>⭐Redis内存优化</h3><p>实际上Redis中的每一个键值对都对应一个RedisObject对象，这个对象主要用来记录一些元数据，比如：最后一次访问事件，被访问的次数等。</p>
<p>也就是说Redis中的键值对越多，对应的RedisObject对象就越多，这些元数据就会占用越多的内存空间。这种情况下，可以通过Hash集合来减少Redis中的键值对。</p>
<p>⭐<strong>基于Hash类型的二级编码</strong>：</p>
<p>就是把一个String类型的数据中的key拆分成两部分，前一部分作为Redis中的key，后一部分Hash集合的key，Hash集合的value就是要保存的数据。这样就可以减少数据库中键值对的数量，就可以减少元数据占用的内存空间。</p>
<p>而且String类型底层数据结构是<a href="#%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2">简单动态字符串</a>，Hash类型的底层数据结构是<a href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8">压缩列表</a>，也相对更省空间。</p>
<p>这种方式虽然可以节省空间，但是就没有办法针对每某一个key单独设置过期时间了，虽然可以通过业务层单独维护每个元素的过期删除逻辑，但是会比较复杂。</p>
<p>Hash类型底层其实有两种数据结构的实现：</p>
<p>它会根据Redis中的两个参数动态选择底层的数据结构，一个是Hash集合中最大元素个数（hash-max-ziplist-entries），另一个是单个元素的最大长度（hash-max-ziplist-value）。</p>
<p>如果Hash集合中的元素个数，或者单个元素的大小超过这两个参数，Hash类型的底层实现就会变为哈希表，并且不会再变回来了。节省空间的效果也就没那么好了。</p>
<p>所以需要通过调整字符串的拆分长度，让数据均匀地分布在多个Hash集合中。</p>
<h3 id="⭐数据淘汰机制"><a href="#⭐数据淘汰机制" class="headerlink" title="⭐数据淘汰机制"></a>⭐数据淘汰机制</h3><p>Redis 4.0版本之前提供了5种淘汰策略，4.0之后又新加了2种，可以通过<code>maxmemory-policy</code>参数配置。淘汰策略可以分为两类：</p>
<p><strong>在设置了过期时间的数据中进行淘汰</strong>：</p>
<ul>
<li>volatile-ttl：会针对设置了过期时间的数据，根据过期时间的先后顺序进行删除，越早过期就越先删除。</li>
<li>volatile-random：在设置了过期时间的数据中，随即删除。</li>
<li>volatile-lru：会使用LRU算法删除设置了过期时间的数据，优先删除最近最少使用的key。</li>
<li>volatile-lfu：会使用LFU算法删除设置了过期时间的数据，优先删除最少使用的key。(Redis 4.0版本新增的)</li>
</ul>
<p><strong>在所有数据中进行淘汰</strong>：</p>
<ul>
<li>allkeys-random：会从所有数据中，随机删除数据。</li>
<li>allkeys-lru：使用LRU算法在所有数据中删除数据，优先删除最近最少使用的key。</li>
<li>allkeys-lfu：使用LFU算法在所有数据中删除数据，优先删除最少使用的key。(Redis 4.0版本新增的)</li>
</ul>
<p>默认情况下，如果内存满了，并不会淘汰数据，再有写请求进来的时候，Redis会直接抛异常。</p>
<p>从算法角度来说：</p>
<p>其实Redis4.0以后提供的LFU算法比LRU更实用一些。因为如果某一个Key是一天访问一次，正好这个key刚刚在一秒前被访问过，那么LRU就不会淘汰这个Key，反而会去淘汰一个每分钟都会被访问，但是最近1秒没有被访问过的key。LFU算法就不会有这个问题。</p>
<p>TTL算法比较简单粗暴，它会优先删除最早过期的Key，但是这个key有可能正在被大量访问，所以这种算法会有一些风险。</p>
<p>从key的范围来说：</p>
<p>allkeys可以保证就算忘记设置过期时间，也可以保证key被删掉。如果被删掉的key访问频率很高，有可能会造成<a href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">缓存击穿</a>，volatile会更稳妥一些。</p>
<h4 id="⭐LRU算法原理"><a href="#⭐LRU算法原理" class="headerlink" title="⭐LRU算法原理"></a>⭐LRU算法原理</h4><p>LRU算法的核心是淘汰最久没有使用的数据。</p>
<p>具体来说就是，<strong>LRU会把所有数据组成一个链表，链表的头部代表最常使用的数据，链表的尾部代表最不经常使用的数据。在删除数据的时候，会从链表的尾部开始删除</strong>。</p>
<p>如果要写入一个新数据，但是链表已经没有空余位置了，LRU算法会做两件事：</p>
<ol>
<li>新数据是刚被访问的，所以会放到链表头部。</li>
<li>再把链表尾部的数据删除。</li>
</ol>
<p>不过LRU算法需要用链表来管理数据，会带来额外的开销。而且如果有大量的数据访问，就会有很多链表移动操作，会降低Redis的性能。</p>
<p>所以Redis对LRU算法做了优化，Redis会记录每个数据每个数据最近一次访问的时间戳（RedisObject中的lru属性）。</p>
<ol>
<li><p>在第一次淘汰数据的时候，会随机选出一批数据，作为候选集合，然后找出集合中lru最小的数据淘汰出去。</p>
</li>
<li><p>下一次淘汰数据的时候，会再挑选一批数据进入到候选集合中，这里进入候选集合的标准是必须小于候选集合中最小的lru。然后再把集合lru最小的数据淘汰出去。</p>
</li>
</ol>
<p>这样就可以解决链表移动导致的性能问题。</p>
<p>这里的候选集合是一个链表，数据会按照lru排序，表头是lru最大的，表尾是lru最小的，如果链表满了就会把表头的数据移出去。</p>
<p>可以通过参数<code>maxmemory-samples</code>来控制挑选数据的个数，默认是5。</p>
<p>建议：</p>
<ul>
<li>如果业务场景有冷热数据区分的话，优先使用allkeys-lru策略。这样可以把经常访问的热数据留在缓存中。</li>
<li>如果业务中数据访问的频率差不多，没有冷热数据区分，建议用allkeys-random策略。随机淘汰就行。</li>
<li>如果业务中有一些不需要被删除的数据，可以使用volatile-lru策略。然后设置这些数据永不过期。这样这些数据就一直不会被删除了。</li>
</ul>
<h4 id="⭐LFU算法原理"><a href="#⭐LFU算法原理" class="headerlink" title="⭐LFU算法原理"></a>⭐LFU算法原理</h4><p>LFU是在LRU算法的基础上，为每个数据增加一个计数器，用来统计这个数据的访问次数。</p>
<p>淘汰数据的时候，会随机选出一批数据，作为候选集合，然后根据根据集合中数据的访问次数进行筛选，会把访问次数最低的数据淘汰出去。如果两个数据的访问次数一样，会把访问时间更久的数据淘汰出去。</p>
<p>这个计数器的大小只有8位，最大值是255。</p>
<p>所以并不是数据每访问一次，就给对应的计数器+1，而是每当一个数据被访问一次，先用计数器当前的值 * 配置参数<code>lfu_log_factor</code> + 1 然后再取倒数，然后判断这个倒数是否大于一个取值范围在0~1之间的随机数，如果大于的话，计数器就+1。（n的倒数是n分之1）</p>
<p>这样设计的好处是可以避免计数器很快就达到255。</p>
<p>可以通过增加<code>lfu_log_factor</code>的值来减少计数器的增加速度。</p>
<p>有些数据可能刚开始被大量访问之后就不会再被访问了，LFU算法还有一个衰退机制。</p>
<p>衰退机制就是，LFU算法会计算当前时间和数据最近一次被访问的时间的差值，然后把这个差值换算成分钟，然后再把这个差值除以<code>lfu_decay_time</code>参数，得到的结果就是计数器要衰减的值。</p>
<h3 id="⭐过期策略"><a href="#⭐过期策略" class="headerlink" title="⭐过期策略"></a>⭐<b id='过期策略'>过期策略</b></h3><p>Redis的过期策略有被动删除和主动删除两种，这两种策略会一起配合使用。</p>
<ul>
<li><p><b id='被动删除'>被动删除</b>：</p>
<ul>
<li><p>当收到查询请求时，判断请求的key是否过期，过期了就直接删除。</p>
</li>
<li><p>这个策略的好处是可以降低CPU资源的消耗，缺点是会导致内存中有大量已经过期的key还留在内存中。</p>
</li>
</ul>
</li>
<li><p><b id='主动删除'>主动删除</b>：</p>
<ul>
<li>默认是100ms，就随机抽取一些设置了过期时间的key，检查是否过期，过期了就直接删除。</li>
<li>可以通过<code>hz</code>参数调整检查频率。</li>
<li>主动删除是在Redis主线程中执行的，如果有大量的key在同一时间过期，会导致Redis响应时间变长。</li>
</ul>
</li>
</ul>
<h3 id="⭐事务机制"><a href="#⭐事务机制" class="headerlink" title="⭐事务机制"></a>⭐事务机制</h3><p>Redis提供了四个命令来完成事务：MULTI（开启事务）、EXEC（提交事务）、DISCARD（回滚事务）、WATCH（监听数据是否变更）。</p>
<p><strong>客户端需要用MULTI命令开启一个事务，然后把需要执行的操作发送给Redis，Redis收到这些命令之后并不会立即执行，而是会把这些命令暂存到一个命令队列中。最后客户端发送EXEC命令之后，Redis才会执行命令队列中的内容</strong>。</p>
<p><strong>DISCARD可以用来回滚事务</strong>。</p>
<p><strong>WATCH命令可以用来监控某些数据是否被修改了，如果被修改了就可以选择放弃事务</strong>。</p>
<h3 id="⭐缓存不一致"><a href="#⭐缓存不一致" class="headerlink" title="⭐缓存不一致"></a>⭐缓存不一致</h3><p>其实不管是先更新数据库还是先更新缓存，或者先更新数据库再删除缓存，只要没办法保证第二个操作成功，就会导致数据不一致。</p>
<p>更好的方式是，新增一个服务监听binlog，然后把发生变化的数据更新到缓存中。</p>
<p>如果不考虑新增服务，<strong>最好的策略是先更新数据库，再删除缓存</strong>。这种策略在多线程环境下也可能出现数据不一致，但是概率非常低，需要满足3个条件才有可能发生：</p>
<ol>
<li>缓存刚好失效</li>
<li>同时出现读请求+写请求</li>
<li>更新数据库比查询数据库时间短</li>
</ol>
<p>A和B两个线程，线程A是查询请求，线程B是更新请求，缓存中的数据也刚好过期了：</p>
<ol>
<li>线程A查询缓存发现数据不存在，</li>
<li>线程A读取数据库，得到X=1</li>
<li>线程B更新数据库，把X更新为2</li>
<li>线程B删除缓存</li>
<li>线程A将X=1写入缓存</li>
</ol>
<p>如果一定要求强一致性，常见的方案是：两阶段提交、三阶段提交、Paxos、Raft这类分布式事务，但它们的性能都很差，而且实现起来也很复杂，这就违背了我们引入缓存的目的。之所以要引入缓存是为了解决<strong>性能</strong>问题，只要数据库和缓存完成操作之前，有其他请求进来，都可能查到中间状态的数据，如果非要追求强一致性，那就要求更新操作完成之前不能有其它请求进来，这个可以通过<a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a>来实现。但是又会牺牲系统的可用性，并且分布式锁也有很多问题要解决。</p>
<p>所以，既然决定使用缓存，就必须容忍「一致性」问题，否则不建议使用缓存。</p>
<h3 id="⭐缓存雪崩"><a href="#⭐缓存雪崩" class="headerlink" title="⭐缓存雪崩"></a>⭐缓存雪崩</h3><p><strong>缓存雪崩是指短时间内大量缓存失效的情况，就会导致原本可以在Redis中处理的请求全都发送到数据库，导致数据库压力很大</strong>。</p>
<p>产生缓存雪崩的原因通常是大量的key在同一时间过期。（缓存雪崩是热key大规模的过期失效，缓存击穿是单个热key过期失效）</p>
<p>解决办法：</p>
<ol>
<li><p>针对不同的key设置不同的过期时间，可以在Redis中存数据的时候，把每个Key的失效时间加一个随机值。</p>
</li>
<li><p>或者在内存中定义一个二级缓存(Map)，提前把数据从数据库加载到内存中，缓存失效就直接走内存查询。</p>
</li>
</ol>
<h3 id="⭐缓存击穿"><a href="#⭐缓存击穿" class="headerlink" title="⭐缓存击穿"></a>⭐<span id='缓存击穿'>缓存击穿</span></h3><p><strong>缓存击穿是指，某个非常频繁被访问的key突然过期，就会导致访问这个key的大量请求，就都发送到了后端数据库，导致数据库压力很大</strong>。</p>
<p>解决办法：</p>
<ol>
<li><p>设置热点Key永不过期，并且选择volatile系列的数据淘汰算法。</p>
</li>
<li><p>也可以通过加锁来限制回表的并发。</p>
<ul>
<li><p>可以使用Redission来获取一个基于Redis的分布式锁，查询数据库之前先获取锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissionClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.isEmpty(data)) &#123;	<span class="comment">// 如果数据为空就通过Redission尝试获取分布式锁</span></span><br><span class="line">		<span class="type">RLock</span> <span class="variable">locker</span> <span class="operator">=</span> redissionClient.getLock(<span class="string">&quot;locker&quot;</span>);</span><br><span class="line">		<span class="comment">// 尝试获取分布式锁，获取不到会阻塞</span></span><br><span class="line">		<span class="keyword">if</span> (locker.tryLock()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取到锁后，再次判断数据是否为空，因为其它线程可能已经把数据写回缓存了</span></span><br><span class="line">				data = redisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (StringUtils.isEmpty(data)) &#123;</span><br><span class="line">                    <span class="comment">// 从数据库获取数据</span></span><br><span class="line">					data = queryForMySQL();</span><br><span class="line">					redisTemplate.opsForValue().set(<span class="string">&quot;key&quot;</span>, data);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// 释放锁</span></span><br><span class="line">				locker.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不过也不一定非要使用分布式锁，因为这样会导致只有一个线程可以获取数据，其它线程都会阻塞。可以考虑使用进程内的锁，这样每一个节点都可以有一个线程回表查询数据，可以提升一些并发度，也不会对数据库有太大影响。</p>
</li>
</ul>
</li>
</ol>
<h3 id="⭐缓存穿透"><a href="#⭐缓存穿透" class="headerlink" title="⭐缓存穿透"></a>⭐缓存穿透</h3><p><strong>缓存穿透是指缓存中查不到的数据不一定是数据没有缓存，有可能是原始数据压根就不存在</strong>。</p>
<p>缓存穿透有两种解决办法：</p>
<ul>
<li>第一种办法是，对于不存在的数据，也同样设置一个特殊的value。比如当查询数据库时发现数据为空，就设置-1保存到缓存中，这样下次请求就可以命中缓存了。如果每次请求的key都是随机数，就会导致缓存中有大量无效的key。</li>
<li>第二种办法：<a href="#BloomFilter">布隆过滤器</a>。</li>
</ul>
<p>如果业务规则比较明确的话，可以直接判断请求参数是否合法。</p>
<p>其实这两种方法可以一起用，把布隆过滤器作为前置过滤，对于少量的误判再保存特殊值到缓存。</p>
<h3 id="⭐布隆过滤器-BloomFilter"><a href="#⭐布隆过滤器-BloomFilter" class="headerlink" title="⭐布隆过滤器(BloomFilter)"></a>⭐<span id="布隆过滤器">布隆过滤器</span>(BloomFilter)</h3><p>布隆过滤器是一种概率性的数据结构，由一个数组和一系列随机映射函数组成，可以用来快速判断某个数据是否存在。</p>
<p>它的原理是：</p>
<ol>
<li><p>当我们想标记某个数据的时候，布隆过滤器首先会使用多个哈希函数，分别计算这个数据的哈希值，可以得到多个哈希值。</p>
</li>
<li><p>然后把这些哈希值和数组长度取模，可以得到每个哈希值在数组中对应的位置。</p>
</li>
<li><p>然后把数组中的位置设置为1。</p>
</li>
<li><p>判断某个数据是否存在的时候，就检查这个数据在数组中对应的多个位置，只要有一个位置是0，就说明数据肯定不存在。</p>
</li>
</ol>
<p>布隆过滤器不支持删除，因为多个数据通过哈希函数换算出来的下标可能是一样的，删除某一个key的数据可能会导致其他数据一起被删除。</p>
<p>布隆过滤器还有一个问题就是会误判，因为它本身是一个数组，数组的长度是有限制的，可能会有多个值换算出来的点是同一个位置。所以数组的长度越大，误判的概率就会越低。</p>
<p>可以使用Google的Guava工具包提供的BloomFilter类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> BloomFilter&lt;Integer&gt; bloomFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstract</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 创建布隆过滤器，元素数量10000，期望误判率1%</span></span><br><span class="line">	bloomFilter = BloomFilter.create(Funnels.integerFunnel(), <span class="number">10000</span>, <span class="number">0.01</span>);</span><br><span class="line">	<span class="comment">// 填充布隆过滤器</span></span><br><span class="line">	IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10000</span>).forEach(bloomFilter::put);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">query</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="comment">// 通过布隆过滤器判断</span></span><br><span class="line">	<span class="keyword">if</span> (bloomFilter.mightContain(id)) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span> + id;</span><br><span class="line">		<span class="comment">// 查询缓存</span></span><br><span class="line">		data = redisTemplate.opsForValue().get(key);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isEmpty(data)) &#123;</span><br><span class="line">			data = queryForMySQL(id);</span><br><span class="line">            <span class="comment">// 双重判断，如果数据库中也没有数据，就设置特殊值到Redis中</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(data)) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, <span class="string">&quot;NODATA&quot;</span>, <span class="number">60</span>, TimeUnit.SECOND);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				redisTemplate.opsForValue().set(key, data, <span class="number">30</span>, TimeUnit.MINUTE);                </span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="⭐热key问题"><a href="#⭐热key问题" class="headerlink" title="⭐热key问题"></a>⭐热key问题</h3><ul>
<li>热key的问题就是，突然大量的请求去访问redis上某些特定的key，这样可能会造成流量过于集中，导致这台redis服务宕机引发雪崩。</li>
<li>解决方案：<ol>
<li>提前把热key打散到不同的服务器，降低压力。</li>
<li>加入二级缓存，提前把热key数据从数据库加载到内存中，如果redis宕机，就直接内存查询。</li>
</ol>
</li>
</ul>
<h3 id="⭐排查Redis性能问题"><a href="#⭐排查Redis性能问题" class="headerlink" title="⭐排查Redis性能问题"></a>⭐排查Redis性能问题</h3><p>如果发现业务响应时间变长，首先需要定位到究竟是哪个环节慢，比较高效的做法是集成<strong>链路追踪</strong>，在服务访问外部资源的地方，记录下时间。</p>
<p>假如发现操作Redis耗时变长了，就只需要关注Redis这条链路上。</p>
<p>操作Redis耗时变长的原因主要有2个：</p>
<ol>
<li>业务服务和Redis之间网络存在问题，比如网速太慢，存在延迟、丢包等问题。</li>
<li>Redis本身出现问题，需要进一步排查是具体原因。</li>
</ol>
<p>通常第一种情况发生的概率比较小，如果网络出现问题，这台服务器上的所有服务都会发生网络延迟的情况。</p>
<p>可以通过基准测试判断Redis是不是真的变慢了：</p>
<p><code>redis-cli -h 127.0.0.1 -p 6379 --intrinsic-latency 60</code>这个命令可以测试出60秒内最大响应延迟。</p>
<p><strong>查看慢日志</strong>：</p>
<p>Redis提供了慢日志，用来记录哪些命令执行耗时比较久。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 执行时间超过5毫秒，记录为慢日志</span><br><span class="line">CONFIG SET slowlog-log-slower-than 5000</span><br><span class="line"># 只保留最近500条慢日志</span><br><span class="line">CONFIG SET slowlog-max-len 500</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以通过<code>SLOWLOG get 5</code>命令查看具体的慢日志，分析哪些命令比较耗时。</p>
<p>如果有SET / DEL这种简单的命令出现在慢日志中，就有可能是bigkey导致的。</p>
<p>可以通过<code>redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01</code>命令扫描出bigkey的分布情况。</p>
<p>如果写入的value非常大，Redis在分配内存的时候就会比较耗时，删除这个key也会比较耗时。所以应该避免写入bigkey。</p>
<p>如果使用的是Redis4.0以上的版本，可以用UNLINK命令代替DEL。</p>
<blockquote>
<p>UNLINK命令可以把释放内存的操作放到后台线程去执行。</p>
</blockquote>
<p><strong>集中过期</strong>：</p>
<p>如果是在某个时间点突然出现一波延时，可以排查一下是否存在大量key集中过期的情况。</p>
<p>Redis的过期策略是<a href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5">主动删除</a>+被动删除，主动删除是在主线程中执行的，Redis必须要把所有key都删除掉才能正常处理请求，如果要删除的key有很多、或者要删除的key很大，耗时就会很长。Redis的响应时间也会变长。</p>
<p>解决办法是给过期时间增加一个随机数，把集中过期的时间点打散。</p>
<p><strong>内存达到上限</strong>：</p>
<p>当Redis使用的内存达到上限之后，每次写入新数据的时间会变长，这是因为Redis内存用完了之后，会触发淘汰策略，删除掉一部分数据之后，才能把新数据写进来。</p>
<p>淘汰数据消耗的时间主要取决于配置的淘汰策略，一般比较常用的是 allkeys-lru / volatile-lru，如果存储的key比较大，淘汰数据的耗时也会比较久。</p>
<p>解决办法：</p>
<ol>
<li>把淘汰策略改为随机淘汰，随机淘汰比LRU算法快很多，不过随机淘汰可能会把很热的key淘汰掉也会有一些别的问题。</li>
<li>避免存储大key。</li>
<li>增加服务器内存。</li>
</ol>
<h3 id="⭐应用场景"><a href="#⭐应用场景" class="headerlink" title="⭐应用场景"></a>⭐应用场景</h3><h4 id="⭐分布式锁"><a href="#⭐分布式锁" class="headerlink" title="⭐分布式锁"></a>⭐分布式锁</h4><p>加锁时，用Redis的<code>setnx key value</code>命令，这个命令的逻辑是这样的：当key不存在时，则设置key和value，并返回1，如果key已经存在了，直接返回0.</p>
<p>如果客户端加完锁之后就掉线了，那其它节点就再也获取不到锁了，所以还要通过<code>set expire</code>命令设置过期时间。</p>
<p>需要注意的是，如果客户端执行完<code>setnx</code>命令之后，还没来得及设置过期时间就掉线了，同样会产生死锁，所以需要Redis 2.6.12版本之后拓展了SET命令的参数：<code>SET lock 1 EX 10 NX</code>。</p>
<p><strong>锁释放错误</strong>：</p>
<p>如果代码执行时间超过了锁过期时间，就会导致锁提前释放，然后被其它节点持有，代码执行完后释放锁，这个时候释放的是其它节点的锁。</p>
<blockquote>
<ol>
<li>节点A加锁成功，开始执行代码</li>
<li>节点A代码执行时间超过了锁的过期时间，锁被自动释放</li>
<li>节点B加锁成功，开始执行代码</li>
<li>节点A代码执行完毕，释放锁（释放的是节点B的锁）</li>
</ol>
</blockquote>
<p>解决办法是：加锁时将锁对应的value设置为当前节点的ID，释放锁时判断这把锁是否是自己加的。</p>
<p>Redission就有自动续期的方案来避免锁过期，逻辑是是启动一个守护线程定时检测锁的失效时间，如果锁快过期了，代码还没执行完，就自动对锁进行续期。</p>
<p><strong>主从切换问题</strong>：</p>
<p>因为Redis主从同步数据是异步的，有可能出现这样的情况：</p>
<ol>
<li>节点A在主库上执行SET命令加锁成功</li>
<li>主库还没来得及把SET命令同步给从库，就异常下线了</li>
<li>从库被选举为新的主库，这个锁在新的主库上就丢了</li>
</ol>
<p>Redis的作者提供了一个解决方案：Redlock。Redlock方案有2个前提：</p>
<ol>
<li>不需要部署从库和哨兵，只部署主库。</li>
<li>主库需要部署多个，官方推荐至少是5个（这些主库之间没有任何关系）。</li>
</ol>
<p>加锁的流程是这样的：</p>
<ol>
<li>客户端先获取当前时间戳T1</li>
<li>客户端依次向这5个Redis实例发起加锁请求，并且每个请求都设置超时时间，如果加锁失败就向下一个Redis实例申请加锁。</li>
<li>如果客户端在半数以上的Redis实例上加锁成功，则再次获取时间戳T2，如果T2 - T1 &lt; 锁过期时间，则认为加锁成功，否则加锁失败。</li>
<li>如果加锁失败，需要向所有节点发起释放锁的请求。</li>
</ol>
<h4 id="⭐zset深度分页"><a href="#⭐zset深度分页" class="headerlink" title="⭐zset深度分页"></a>⭐zset深度分页</h4><ol>
<li>将数据库中的主键保存到Zset集合中，假设需要按照创建时间排序，就把创建时间转换为时间戳作为zscore用于排序。</li>
<li>分页查询时通过<code>zrange key start stop</code>命令获取目标记录的主键，然后根据主键回表。</li>
<li>新增数据时使用<code>Zadd</code>命令将主键加入缓存。</li>
<li>删除数据时使用<code>zrem</code>命令删除缓存。</li>
</ol>
<h3 id="⭐Redis-6-0新特性"><a href="#⭐Redis-6-0新特性" class="headerlink" title="⭐Redis 6.0新特性"></a>⭐Redis 6.0新特性</h3><h4 id="⭐多线程模型"><a href="#⭐多线程模型" class="headerlink" title="⭐多线程模型"></a>⭐多线程模型</h4><p>Redis 6.0版本采用了多个IO线程来处理网络请求，但是对于读写命令，Redis还是采用单线程来处理。</p>
<p>具体的流程是这样的：</p>
<ol>
<li>首先客户端和主线程建立Socket连接后，Redis会把Socket放到一个等待队列中。</li>
<li>然后通过轮询的方式把Socket连接分配给IO线程，主线程会进入等待状态。</li>
<li>等IO线程解析完请求后，主线程会以单线程的方式执行这些命令。</li>
<li>主线程执行完命令后，会把结果写入到缓冲区。</li>
<li>最后IO线程会把结果返回给客户端。</li>
</ol>
<p>多线程机制默认是关闭的，可以在redis.conf配置文件中配置：</p>
<ul>
<li><code>io-threads-do-reads</code>：设置为yes表示开启多线程。</li>
<li><code>io-threads</code>：设置线程数量，线程数量要小于CPU核心数。官方给的建议是6个线程。</li>
</ul>
<h4 id="⭐客户端缓存"><a href="#⭐客户端缓存" class="headerlink" title="⭐客户端缓存"></a>⭐客户端缓存</h4><p>客户端缓存就是Redis客户端可以把，读取到的数据缓存在本地，这样就相当于每个客户端都多了一个本地缓存，数据没有发生变化时直接读取本地缓存就能拿到数据，可以节省网络带宽，降低Redis的请求压力。</p>
<p>如果数据被修改或者是失效了，Redis提供了两种方式来通知客户端做缓存失效：</p>
<p><strong>普通模式</strong>：Redis会记录客户端读取过的key，并监控key是否发生变化。如果key发生变化，Redis就会给客户端发送<code>invalidate</code>消息，让客户端做缓存失效。</p>
<p>如果一个key被连续修改两次，Redis只会通知客户端一次，只有客户端再次读取这个key之后，Redis才会再发送缓存失效消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLIENT TRACKING ON|OFF</span><br></pre></td></tr></table></figure>



<p><strong>广播模式</strong>：客户端可以注册要缓存的key的前缀，当这些前缀的key被修改时，Redis就会把缓存失效的消息发送给客户端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLIENT TRACKING ON BCAST PREFIX keyPrefix</span><br></pre></td></tr></table></figure>



<h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>Redis 6.0版本支持创建不同用户来访问Redis。可以使用<code>ACL SETUSER</code>命令创建用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACL SETUSER zhangsan on &gt; 123456</span><br></pre></td></tr></table></figure>



<p>6.0版本还增加了以用户为单位的命令访问权限：</p>
<ul>
<li>+：给用户添加可执行的命令。</li>
<li>-：减少用户可执行的命令。</li>
<li>+@：把一类命令分配给用户执行。</li>
<li>-@：把一类命令禁止用户执行。</li>
<li>+@all：允许用户执行所有命令。</li>
<li>-@all：禁止用户执行所有命令。</li>
</ul>
<p>假设要让用户zhangsan只能调用String类型的命令，不能调用Hash类型的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACL SETUSER zhangsan +@string -@hash</span><br></pre></td></tr></table></figure>



<p>Redis 6.0版本还支持以key位粒度设置访问权限。可以用波浪号 ”~“和key的前缀对key进行权限控制。</p>
<p>假设用户zhangsan只能对以 ”user“为前缀的key进行操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACL SETUSER zhangsan ~user* +@all</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2022/12/08/JVM/</url>
    <content><![CDATA[<h3 id="⭐Java代码运行原理"><a href="#⭐Java代码运行原理" class="headerlink" title="⭐Java代码运行原理"></a>⭐Java代码运行原理</h3><p>首先需要把java文件编译成class文件，然后把编译后的class文件加载到Java虚拟机中。</p>
<blockquote>
<p>加载后的Java类会被存放在<a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a>中</p>
</blockquote>
<p>但是Java字节码是无法直接执行的，所以需要Java虚拟机把字节码翻译成机器码。</p>
<p>Java虚拟机有两种翻译模式：</p>
<ol>
<li>第一种是<strong>解释执行：就是翻译一条执行一条</strong>。</li>
<li>第二种是<strong>即时编译：就是把一个方法中包含的所有字节码都翻译成机器码之后再执行</strong>。</li>
</ol>
<p>解释执行的优势在于不需要等待编译，程序的启动速度更快。</p>
<p>即时编译的优势在于编译完成后实际运行速度更快。</p>
<p>**HotSpot默认采用的是混合模式，它会先解释执行字节码，然后把其中反复执行的<a href="#%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81">热点代码</a>以方法为单位再进行<a href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91">即时编译</a>**。</p>
<p>⭐<strong>为什么不把Java代码全部编译成机器码</strong>？</p>
<p>为了避免重复编译，即时编译后生成的机器码会保存在<a href="#CodeCache">CodeCache</a>中，会占用额外的内存空间。如果把很多调用次数很少的代码，也用即时编译生成机器码，就会导致编译时间变长，而且也需要更多内存空间保存这些机器码。</p>
<p><b id='CodeCache'>CodeCache</b>：是一块堆外内存，经过即时编译后的机器码会存放在这里。</p>
<p>CodeCache的大小是固定的，如果CodeCache满了，JVM就会判断每一个即时编译后的方法的方法调用计数器和循环回边计数器是否低于阈值，如果低于阈值就会清理掉这个方法的机器码。</p>
<blockquote>
<p>可以通过JVM参数<code>-XX:ReservedCodeCacheSize</code>控制CodeCache的大小。</p>
</blockquote>
<h3 id="⭐即时编译"><a href="#⭐即时编译" class="headerlink" title="⭐即时编译"></a>⭐<span id='即时编译'>即时编译</span></h3><p>Java虚拟机内置了多个即时编译器：<strong>C1</strong>、<strong>C2</strong>。</p>
<ul>
<li><p><b id='C1'>C1</b>：也叫做<strong>Client编译器，面向的是对启动速度有要求的客户端应用</strong>，优化手段比较简单，编译时间比较短。</p>
<blockquote>
<p>对应的JVM参数是<code>-client</code>。</p>
</blockquote>
</li>
<li><p><b id='C2'>C2</b>：也叫做<strong>Server编译器，面对的是对执行效率有要求的服务端应用</strong>，优化手段相对复杂，编译时间比较长，但是生成的代码执行效率高（用C++实现的）。</p>
<blockquote>
<p>对应的JVM参数是<code>-server</code>。</p>
</blockquote>
</li>
</ul>
<p><strong>从JDK7版本开始，HotSpot默认采用分层编译模式</strong>：**<a href="#%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81">热点代码</a>首先会被C1编译，然后热点中的热点会进一步被C2编译**。</p>
<p>即时编译的过程是在额外编译线程中进行的，HotSpot会根据CPU核心数来设置编译线程的数量，并按照1:2的比例分配给C1和C2。</p>
<p>字节码的解释执行和即时编译可以同时进行，即时编译完成后的机器码会在下次调用该方法时替换原本的解释执行。</p>
<p>分层编译会把Java虚拟机的执行状态分为五个层次：C1代码（C1生成的机器码），C2代码（C2生成的机器码）</p>
<ol>
<li>第一层是，解释执行。</li>
<li>第二层是，执行不带<a href="#profiling">profiling</a>的C1代码。</li>
<li>第三层是，执行只带方法调用次数和循环回边次数<a href="#profiling">profiling</a>的C1代码。</li>
<li>第四层是，执行带所有<a href="#profiling">profiling</a>的C1代码。</li>
<li>第五层是，执行C2代码。</li>
</ol>
<p>其中第2层和第5层是终止状态，当一个方法被这两层编译后，如果编译后的机器码没有失效，Java虚拟机不会再对该方法发出编译请求。</p>
<p>通常情况下，热点方法会被第4层的C1编译，然后再被第5层的C2编译，但是如果方法比较简单（比如getter/setter），Java虚拟机就会认为这个方法编译后的C1代码和C2代码执行效率相同。就会直接选择第2层的C1编译。</p>
<p>Java8默认开启了分层编译。不管开启还是关闭分层编译，<code>-client</code>和<code>-server</code>都是无效的。关闭分层编译的情况下，默认使用的是C2。</p>
<p>如果希望使用C1，可以在打开分层编译的情况下，使用<code>-XX:TieredStopAtLevel=1</code>，这样在解释执行之后会直接由2层的C1进行编译。</p>
<p>⭐<b id='profiling'>profiling</b>：收集能够反映程序执行状态的数据的过程。这些数据被称为profile。</p>
<p>比如方法调用次数、循环回边次数、分支跳转次数、类型强制转换指令，类型判断指令（instanceof）。</p>
<p>⭐<b id='热点代码'>热点代码</b>：</p>
<ol>
<li>被多次调用的方法</li>
<li>方法内部包含循环次数较多的循环体</li>
</ol>
<p>Java虚拟机为每个方法都准备了两个计数器：<strong>方法调用计数器</strong>和<strong>循环回边计数器</strong>。</p>
<p><strong>方法调用计数器</strong>：</p>
<p><strong>用来统计方法的调用次数，在C1中默认阈值是1500次，在C2中默认阈值是10000次</strong>。</p>
<p>方法调用计数器统计的不是方法被调用的绝对次数，而是执行频率。也就是说在一段时间内，如果方法的调用次数未达到阈值，计数器就会减少为原来的一半，这个过程叫<strong>热度衰减</strong>，这段时间叫<strong>半衰周期</strong>。</p>
<p>比如阈值是10000，半衰周期是1个小时，如果在1个小时内，某一个方法被调用了8000次，虚拟机就会认为它不是热点代码，就会把调用次数减少为4000。</p>
<p>可以通过JVM参数调整计数器阈值、热度衰减以及半衰周期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数器阈值</span></span><br><span class="line">-XX:CompileThreshold</span><br><span class="line"><span class="comment">// 关闭热度衰减</span></span><br><span class="line">-XX:-UseCounterDecay</span><br><span class="line"><span class="comment">// 设置半衰周期时间（秒）</span></span><br><span class="line">-XX:CounterHalfLifeTime</span><br></pre></td></tr></table></figure>



<p><b id='循环回边计数器'>循环回边计数器</b>：</p>
<p><strong>用来统计方法中循环体的循环次数</strong>。在C1中默认阈值是13500次，在C2中默认阈值是10700次。</p>
<p>之所以要维护两个计数器，是因为Java虚拟机还存在一种以循环为单位的即时编译，叫做OSR编译，循环回边计数器就是用来触发这种类型的编译的。</p>
<p>⭐<b id='OSR编译'>OSR编译</b>：是一种可以在程序执行过程中，动态替换方法栈帧的技术，可以让程序在解释执行和即时编译后的代码之间切换。</p>
<h3 id="⭐Java内存模型"><a href="#⭐Java内存模型" class="headerlink" title="⭐Java内存模型"></a>⭐Java内存模型</h3><h4 id="⭐Java内存区域"><a href="#⭐Java内存区域" class="headerlink" title="⭐Java内存区域"></a>⭐Java内存区域</h4><p>Java虚拟机会在内存中划分出<a href="#%E5%A0%86">堆</a>、<a href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java虚拟机栈</a>、<a href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88">本地方法栈</a>、<a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8">程序计数器</a>、<a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a>。</p>
<p>⭐<b id='堆'>堆</b>：堆是虚拟机内存中最大的一块空间，是线程共享的，大部分对象都会被分配到堆中。</p>
<p>堆是垃圾收集器管理的区域，Java虚拟机中的垃圾回收器又是基于分代回收的理论设计的，所以堆又被划分为<a href="#%E6%96%B0%E7%94%9F%E4%BB%A3">新生代</a>和<a href="#%E8%80%81%E5%B9%B4%E4%BB%A3">老年代</a>，新生代又被划分为<a href="#Eden%E5%8C%BA">Eden区</a>和两个<a href="#Survivor%E5%8C%BA">Survivor区</a>。</p>
<p>⭐<b id='Java虚拟机栈'>Java虚拟机栈</b>：Java虚拟机栈是线程私有的。</p>
<p>每当调用一个Java方法，Java虚拟机就会在当前线程的Java方法栈中生成一个<a href="#%E6%A0%88%E5%B8%A7">栈帧</a>，用来存放方法参数和方法内部定义的局部变量。不管方法是正常返回还是异常返回，Java虚拟机都会弹出当前栈帧。</p>
<p>当创建一个线程时，会在Java虚拟机栈中申请一个线程栈，用来保存<a href="#%E6%A0%88%E5%B8%A7">栈帧</a>。</p>
<blockquote>
<p><a href="#%E6%A0%88%E5%B8%A7">栈帧</a>的大小是编译时就计算好的</p>
</blockquote>
<p>⭐<b id='本地方法栈'>本地方法栈</b>：本地方法栈也是线程私有的，作用跟Java虚拟机栈类似，主要用来管理本地（Native）方法（C++实现的方法）。</p>
<p>⭐<b id='程序计数器'>程序计数器</b>：主要用来完成分支、循环、跳转、异常处理、线程恢复等功能。</p>
<p>为了保证线程切换后能够恢复到正确的执行位置，每个线程都有一个独立的程序计数器，所以程序计数器是线程私有的。</p>
<blockquote>
<p>如果正在执行的是一个Java方法，程序计数器中保存的是字节码指令的地址。</p>
<p>如果正在执行的是一个本地（Native）方法，程序计数器中的内容为空。</p>
</blockquote>
<p>⭐<b id='方法区'>方法区</b>：方法区是线程共享的，主要用来存放类信息（字段、方法、接口、父类）、常量，静态变量、<a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0">运行时常量池</a>等。</p>
<blockquote>
<p>如果方法区无法满足新的内存分配需求时，会直接OOM。</p>
</blockquote>
<p><b id='运行时常量池'>运行时常量池</b>：class文件中会保存一份常量池表，用来保存编译器生成的各种字面量和<a href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8">符号引用</a>，这个常量池表最终会被放到运行时常量池中。</p>
<h4 id="⭐happens-before规则"><a href="#⭐happens-before规则" class="headerlink" title="⭐happens-before规则"></a>⭐happens-before规则</h4><p>由于即时编译器的优化可能会把原本的代码执行顺序打乱，在多线程环境下就有可能导致程序运行结果无法预测。</p>
<p>所以JDK 5定义了 Java 内存模型。其中最为重要的一个概念便是 happens-before 关系。</p>
<p><b id='happens-before'>happens-before</b> 规则是用来描述两个操作的内存可见性的，如果操作A happens-before 操作B，那么A的结果对B可见。</p>
<ol>
<li><p><strong>在同一个线程中，前一行代码 happens-before 后一行代码</strong>（前一行代码的执行结果对后一行代码可见）。</p>
<blockquote>
<p>前一行代码并不一定在后一行代码之前执行。如果后一行代码不需要依赖于前一行代码，这两行代码就有可能被重排序。</p>
</blockquote>
</li>
<li><p><strong>解锁操作 happens-before 之后对这把锁的加锁操作</strong></p>
<blockquote>
<p>前一个线程解锁之后，下一个加锁的线程可以看到前一个线程的执行结果，在解锁时，Java虚拟机会强制刷新CPU缓存，让当前线程对内存做的修改对其它线程可见。这就是为什么锁可以解决并发问题。</p>
</blockquote>
</li>
<li><p><strong>对volatile字段的写操作 happens-before 之后对同一个字段的读操作</strong>。</p>
<blockquote>
<p>用<a href="#volatile">volatile</a>来修饰的变量，对这个变量的读写操作都不能使用CPU缓存，必须从内存中读写。</p>
<p>happens-before还具有传递性，就是说对于<a href="#volatile">volatile</a>字段的写操作之前的写操作，也是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">v</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">		x = <span class="number">10</span>;</span><br><span class="line">		v = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == <span class="literal">true</span>) &#123;</span><br><span class="line">			System.out.print(x);	<span class="comment">// x的值对v是可见的，所以这里x的值是10</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>线程A执行<code>writer()</code>方法，线程B执行<code>reader()</code>方法。</p>
</li>
<li><p>如果线程B看到的v是true，那么线程A设置的x=10，对线程B就是可见的。</p>
</li>
<li><p>因为<code>x = 10</code> happens-before <code>v = true</code>，所以<code>x = 10</code> happens-before <code>v == true</code>。</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>父线程启动子线程之前的操作 happens-before 子线程的所有操作</strong>。</p>
<blockquote>
<p>如果线程A调用线程B的<code>start()</code>方法，那么线程B能看到线程A调用<code>start()</code>方法之前的所有操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">			<span class="comment">// 主线程启动子线程之前的所有操作，子线程都能看到。</span></span><br><span class="line">			System.out.print(x);	<span class="comment">// 这里x的值是11</span></span><br><span class="line">		&#125;);</span><br><span class="line">		x = <span class="number">11</span>;</span><br><span class="line">		<span class="comment">// 启动子线程</span></span><br><span class="line">		b.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><strong>线程中的所有操作 happens-before <code>join()</code>方法的返回</strong>。</p>
<blockquote>
<p>如果线程A调用线程B的<code>join()</code>方法，那么线程A可以看到线程B中的所有操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">			x = <span class="number">11</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">		t.start();</span><br><span class="line">	    <span class="comment">// 子线程的所有操作，在主线程调用join()方法之后可见</span></span><br><span class="line">		t.join();</span><br><span class="line">		System.out.print(x);	<span class="comment">// 这里x的值是11</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>线程对其他线程的中断操作happens-before被中断线程收到的中断事件。</p>
</li>
<li><p>构造器中的最后一个操作happens-before第一个操作。</p>
</li>
</ol>
<p>happens-before关系还具有传递性。如果操作A happens-before 操作B，而操作B happens-before 操作C，那么操作A happens-before 操作C。</p>
<h4 id="⭐Java内存模型的底层实现"><a href="#⭐Java内存模型的底层实现" class="headerlink" title="⭐Java内存模型的底层实现"></a>⭐Java内存模型的底层实现</h4><p>Java 内存模型是通过内存屏障（memory barrier）来禁止重排序的。</p>
<p>编译器会根据 happens-before 关系，向正在编译的目标方法中插入内存屏障（字节码指令）。</p>
<p>即时编译器会把内存屏障翻译成CPU指令。关闭即时编译器的话，解释执行也会把内存屏障字节码指令翻译成CPU指令。</p>
<ul>
<li><p>对于编译器来说，这些内存屏障会限制即时编译器的重排序。</p>
<ul>
<li>对于volatile字段，编译器会在该字段的读写操作前后插入内存屏障，来禁止重排序。</li>
</ul>
</li>
<li><p>对于处理器来说，这些内存屏障将会触发CPU缓存的刷新操作。</p>
</li>
</ul>
<h3 id="⭐类加载机制"><a href="#⭐类加载机制" class="headerlink" title="⭐类加载机制"></a>⭐类加载机制</h3><p>从class文件到内存中的类，需要经过<a href="#%E5%8A%A0%E8%BD%BD">加载</a>、<a href="#%E9%AA%8C%E8%AF%81">验证</a>、<a href="#%E5%87%86%E5%A4%87">准备</a>、<a href="#%E8%A7%A3%E6%9E%90">解析</a>、<a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>五个步骤。</p>
<p>⭐<b id='加载'>加载</b>：</p>
<p>加载是指查找字节流，并创建类的过程。</p>
<p>基础类是Java虚拟机预先定义好的，数组类是由Java虚拟机直接生成的，对于其他类，Java虚拟机需要依赖类加载器完成加载过程。</p>
<p>类加载器有三种：<strong>启动类加载器</strong>、<strong>拓展类加载器</strong>、<strong>应用类加载器</strong>。</p>
<ul>
<li><strong>启动类加载器</strong>：是虚拟机的一部分，是由C++实现的，没有对应的Java对象。主要负责加载JDK目录中lib文件夹中的jar包。以及<code>-Xbootclasspath</code>参数指定的路径中的jar包。</li>
<li><strong>拓展类加载器</strong>：拓展类加载器的父加载器是启动类加载器，主要负责加载JDK目录中lib\ext文件夹中的jar包，以及系统变量<code>java.ext.dirs</code>指定的类。</li>
<li><strong>应用类加载器</strong>：应用类加载器的父加载器是拓展类加载器，主要负责加载应用程序路径下的类。</li>
</ul>
<p>在Java虚拟机中，<strong>类的唯一性是由类加载器和类的全名确定的，就算是同一个class文件，由两个不同的类加载器加载，也会得到两个不同的类</strong>。为了避免同一个类被重复加载，Java虚拟机用双亲委派机制来解决这个问题。</p>
<p>JDK9版本引入了模块系统，把拓展类加载器改为平台类加载器。只有少数的几个核心模块，比如java.base是由启动类加载器加载的，其它模块都是平台类加载器加载的。</p>
<p><strong>⭐双亲委派机制</strong>：</p>
<p>如果一个类加载器收到了加载类的请求，它会先将其委托给父加载器，父加载器继续向上委托，直到启动类加载器。只有父加载器无法加载该类的时候，子加载器才会自己去加载。</p>
<p>类加载器之间并没有继承关系，是通过组合来实现委派的。</p>
<p><strong>双亲委派机制是为了保证同一个类只被加载一次</strong>。</p>
<p>假设没有双亲委派机制，如果在代码中创建了Object类的对象，那么应用类加载器加载这个类的时候就会去加载Object类（会在解析阶段触发Object类的加载），但是Object类已经被启动类加载器加载过了，因为类的唯一性是通过类加载器和全类名确定的，这就会导致应用中有两个Object类。</p>
<p>⭐<b id='验证'>验证</b></p>
<p>验证阶段的目的是，确保被加载进来的类满足Java虚拟机的约束条件。</p>
<blockquote>
<p>通常Java编译器生成的class文件必然满足Java虚拟机的约束条件，</p>
</blockquote>
<p>⭐<b id='准备'>准备</b>：</p>
<p>准备阶段的目的是，为静态变量分配内存并设置初始值，以及创建当前类的<a href="#%E6%96%B9%E6%B3%95%E8%A1%A8">方法表</a>。</p>
<p>⭐<b id='解析'>解析</b>：</p>
<p>解析阶段的目的，是把<a href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8">符号引用</a>解析成实际引用。</p>
<p>如果符号引用指向一个未被加载的类，那么将会触发这个类的<strong>加载</strong>（不会触发这个类的验证、准备、解析、初始化）。</p>
<p>对于一个方法的符号引用可以分为接口符号引用和非接口符号引用：</p>
<ul>
<li><p>对于接口符号引用，Java虚拟机首先会在目标接口中查找方法名和<a href="#%E6%96%B9%E6%B3%95%E6%8F%8F%E8%BF%B0%E7%AC%A6">方法描述符</a>都相同的方法。</p>
<ul>
<li><p>如果没有找到，就在Object类中找。</p>
</li>
<li><p>如果还是没有找到，就在目标接口的父接口中寻找。</p>
</li>
</ul>
</li>
<li><p>对于非接口符号引用，Java虚拟机首先会在目标类中查找方法名和<a href="#%E6%96%B9%E6%B3%95%E6%8F%8F%E8%BF%B0%E7%AC%A6">方法描述符</a>都相同的方法。</p>
<ul>
<li><p>如果没有找到，就在父类中寻找，直到Object类。</p>
</li>
<li><p>如果还是没有找到，就在实现的接口中找。</p>
</li>
</ul>
</li>
</ul>
<p><b id='符号引用'>符号引用</b>：</p>
<p>在编译阶段，一个类被加载到Java虚拟机之前，这个类无法知道其他类、方法、字段对应的具体地址。所以需要引用这些对象的时候，Java编译器会生成一个符号引用。符号引用存储在class文件常量池中。</p>
<p>一个方法的符号引用包含：<strong>目标方法所在类的名字、目标方法的名字、接收参数类型、返回值类型</strong>。</p>
<p>⭐<b id='初始化'>初始化</b>：</p>
<p>初始化阶段会执行<code>&lt;clinit&gt;</code>方法。</p>
<p>编译器会在编译阶段，把赋值操作、静态代码块中的代码，收集在一起组成<code>&lt;clinit&gt;</code>方法。</p>
<blockquote>
<p>子类初始化时会首先调用父类的 <code>&lt;clinit&gt;</code>方法，然后再执行子类的 <code>&lt;clinit&gt;</code> 方法。</p>
<p>JVM会通过加锁的方式保证<code>&lt;clinit&gt;</code>方法只会执行一次。</p>
</blockquote>
<h3 id="方法调用原理"><a href="#方法调用原理" class="headerlink" title="方法调用原理"></a>方法调用原理</h3><p>Java虚拟机会根据类名、方法名、<a href="#%E6%96%B9%E6%B3%95%E6%8F%8F%E8%BF%B0%E7%AC%A6">方法描述符</a>来识别方法。</p>
<p>Java虚拟机中有5个调用方法的指令：</p>
<ol>
<li>invokestatic：用于调用静态方法。</li>
<li>invokespecial：用于调用私有方法、构造器、使用super关键字调用父类实例方法或构造器、所实现接口的默认方法。</li>
<li>invokevirtual：用于调用非私有方法。</li>
<li>invokeinterface：用于调用接口方法。</li>
<li>invokedynamic：用于调用动态方法。</li>
</ol>
<p>对于静态方法和私有方法，Java虚拟机可以直接识别具体的目标方法。</p>
<p>对于非私有方法和接口方法，因为方法有可能被重写，所以Java虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。 如果方法被标记为final，就可以直接确定目标方法。</p>
<p>在编译过程中，Java虚拟机并不知道目标方法的内存地址，所以Java编译器会用<a href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8">符号引用</a>来表示目标方法。</p>
<p>经过<a href="#%E8%A7%A3%E6%9E%90">解析阶段</a>之后，这些符号引用会被解析成实际引用。</p>
<ul>
<li>对于可以静态绑定的方法来说，实际引用指向的是一个指向目标方法的指针。</li>
<li>对于需要动态绑定的方法来说，实际引用指向的是一个<a href="#%E6%96%B9%E6%B3%95%E8%A1%A8">方法表</a>的索引。在执行过程中，Java虚拟机会获取调用者的实际类型，并获取该类型中的<a href="#%E6%96%B9%E6%B3%95%E8%A1%A8">方法表</a>，然后根据引用指向的索引值获得目标方法。</li>
</ul>
<p>所以动态绑定会更加耗时。不过为了减少动态绑定额外开销，即时编译有两种优化手段：<a href="#%E5%86%85%E8%81%94%E7%BC%93%E5%AD%98">内联缓存</a>和<a href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94">方法内联</a>。</p>
<p><b id='方法描述符'>方法描述符</b>：由方法的参数类型和返回类型组成。</p>
<p><b id='静态绑定'>静态绑定</b>：Java虚拟机在<a href="#%E8%A7%A3%E6%9E%90">解析</a>阶段就能识别目标方法。</p>
<p><b id='动态绑定'>动态绑定</b>：Java虚拟机需要在运行过程中根据调用者的动态类型来识别目标方法。</p>
<p>⭐<b id='方法表'>方法表</b>：</p>
<p>方法表本质上是一个数组，每个元素指向当前类或者父类中非私有的方法。这些方法可能是具体的、可执行的方法，也可能是抽象方法。</p>
<p>方法表有两个特性：</p>
<ol>
<li>第一，子类方法表包含父类方法表中所有方法。</li>
<li>第二，子类重写的方法，在方法表中的索引值，与父类方法表中的索引值相同。</li>
</ol>
<p><b id='内联缓存'>内联缓存</b>：</p>
<p>内联缓存是一种加快动态绑定的技术，它可以缓存调用虚方法的调用者的动态类型，以及该类型对应的目标方法。</p>
<p>之后在调用方法时，如果发现类型已缓存，就可以直接调用目标方法。如果没有缓存，就使用<a href="#%E6%96%B9%E6%B3%95%E8%A1%A8">方法表</a>来动态绑定目标方法。</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>在编译过程中，Java编译器会对Lambda表达式进行解语法糖，生成一个方法来保存Lambda表达式的内容。这个方法的参数列表包含：Lambda表达式的参数和捕获的外部变量。</p>
<p>第一次执行时，Java虚拟机会生成一个适配器类，这个适配器实现了对应的函数式接口。</p>
<ul>
<li><p>对于没有捕获外部变量的Lambda表达式，可以认为它与上下文是无关的，只需要创建一次适配器类的实例。</p>
</li>
<li><p>对于捕获了外部变量的Lambda表达式，为了避免变量发生变化，每次执行Lambda表达式时都会创建一个新的适配器实例。</p>
</li>
</ul>
<p>对于没有捕获外部变量的Lambda表达式，第一次调用时会有额外创建适配器类的开销，之后的调用会复用同一个适配器实例，跟普通方法的调用的效率一样。</p>
<p>对于捕获了外部变量的Lambda表达式，如果Lambda表达式中的内容可以被<a href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94">内联</a>，会借助<a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a>将新建适配器实例这个操作优化为空操作。</p>
<p>所以使用Lambda表达式的时候，尽量不要捕获外部变量。</p>
<h3 id="⭐方法内联"><a href="#⭐方法内联" class="headerlink" title="⭐方法内联"></a>⭐<b id='方法内联'>方法内联</b></h3><p>方法内联是指，在编译过程中遇到方法调用时，将目标方法纳入到当前方法体的编译范围中，可以消除方法调用的额外开销。</p>
<p>比如调用get/set方法时，需要保存当前方法的执行位置、创建get/set方法的栈帧、访问字段，弹出栈桢、最后再恢复到原来方法的执行位置。如果内联了get/set方法之后，就只需要访问字段就好了。</p>
<p>在<a href="#C2">C2</a>编译器中，方法内联是在解析字节码的过程中完成的，每当碰到方法调用字节码时，编译器会判断是否需要内联目标方法，如果需要内联就会开始解析目标方法的字节码，并复制到当前方法中。</p>
<p>通常情况下，方法内联越多，字节码的执行效率就越高，但是对于编译器来说，内联越多，编译时间就越长，生成的机器码就越长。在Java虚拟机中，即时编译后生成的机器码会存在CodeCache中，但是这个区域的大小是有限制的。也就是说，生成的机器码越长，越容易填满CodeCache，如果CodeCache满了就会暂时关闭即时编译。</p>
<blockquote>
<p>可以通过JVM参数<code>-XX:ReservedCodeCacheSize</code>控制CodeCache的大小。</p>
</blockquote>
<p>所以方法内联是有条件的：</p>
<ol>
<li><p>JDK内部方法中，带有<code>@ForceInline</code>注解的方法会被强制内联，带有<code>@DontInline</code>注解的方法不会被内联。</p>
</li>
<li><p>如果目标方法编译后生成的机器码大小超过2000，则无法内联。</p>
<blockquote>
<p>可以通过<code>-XX:InlineSmallCode</code>调整</p>
</blockquote>
</li>
<li><p>递归方法不会被内联。</p>
</li>
<li><p>调用层级超过9层的的方法调用。</p>
<blockquote>
<p>如果方法a调用方法b，方法b调用方法c，那么方法b就是方法a的1层调用，方法c就是方法a的2层调用。</p>
<p>可以通过<code>-XX:MaxInlineLevel</code>调整。</p>
</blockquote>
</li>
<li><p>如果目标方法的调用次数小于250次，不会被内联。</p>
<blockquote>
<p>可以通过JVM参数<code>-XX:MinInliningThreshold</code>调整</p>
</blockquote>
</li>
<li><p>如果目标方法的字节码小于6，就直接内联。</p>
<blockquote>
<p>可以通过JVM参数<code>-XX:MaxTrivialSize</code>调整</p>
</blockquote>
</li>
</ol>
<h3 id="异常处理原理"><a href="#异常处理原理" class="headerlink" title="异常处理原理"></a>异常处理原理</h3><p>在编译生成字节码的时候，编译器会为每个方法添加一个异常表。异常表中的一个元素代表一个异常处理器，异常处理器由from指针、to指针、target指针和捕获的异常类型组成。</p>
<p>其中from指针和to指针代表异常处理器的监控范围，就是try代码块覆盖的范围。target指针指向的是异常处理器的起始位置，就是catch代码块的起始位置。</p>
<p>当程序触发异常时，Java虚拟机会从上到下遍历异常表中所有元素，当触发异常的字节码索引值在某个异常处理器的from指针和to指针范围内，Java虚拟机就会判断抛出的异常与该异常处理器要捕获的异常类型是否匹配。如果匹配，Java虚拟机就会执行target指针指向的字节码。</p>
<p>如果异常表中没有匹配的异常处理器，就会弹出当前方法对应的Java栈帧。然后遍历调用者的异常表，最坏的情况下，Java虚拟机需要遍历当前线程Java栈上所有方法的异常表。</p>
<p>finally代码块的实现原理就是，复制finally代码块的内容分别放在try-catch代码块的出口处。</p>
<h3 id="⭐反射实现原理"><a href="#⭐反射实现原理" class="headerlink" title="⭐反射实现原理"></a>⭐反射实现原理</h3><h4 id="Method-invoke"><a href="#Method-invoke" class="headerlink" title="Method#invoke"></a><span id='反射调用原理'>Method#invoke</span></h4><p><code>invoke()</code>方法实际上会委派给<code>MethodAccessor</code>接口来处理，这个接口有两个实现类<code>DelegatingMethodAccessorImpl</code>（委派实现）和<code>NativeMethodAccessorImpl</code>（本地实现）。</p>
<p>我们调用method对象的<code>invoke()</code>方法时，会先调用委派实现（DelegatingMethodAccessorImpl）的<code>invoke()</code>方法，然后通过委派实现再调用本地实现（NativeMethodAccessorImpl）的<code>invoke()</code>方法，最终抵达目标方法。</p>
<p>之所以要采用委派实现作为中间层，是因为还有一种动态生成字节码的实现方式（动态实现）。</p>
<p>动态实现是用Java实现的，性能会比较好，但是初始化时需要比较多的时间。</p>
<p>本地实现是C++实现的，调用时需要经过JNI，所以性能比较差，但是启动速度会比较快。</p>
<p>所以Java虚拟机设置了一个阈值，默认是15，当某个反射调用的调用次数超过15次时，就会开始动态生成字节码（MethodAccessorGenerator），并且把委派实现类中的委派对象切换到动态实现（调用DelegatingMethodAccessorImpl中的<code>setDelegate(MethodAccessorImpl methodAccessor)</code>方法）。</p>
<p>可以通过<code>-Dsun.reflect.inflationThreshold</code>参数来调整触发动态实现的次数。</p>
<p>也可以通过<code>-Dsun.reflect.noInflation=true</code>关闭本地实现，这样一开始就会直接采用动态实现。</p>
<h4 id="反射的开销"><a href="#反射的开销" class="headerlink" title="反射的开销"></a>反射的开销</h4><p>Class.forName 需要调用本地方法，Class.getMethod 会遍历该类的公有方法，如果没有匹配到，它还将遍历父类的公有方法。</p>
<p>所以这些方法都会比较耗时，可以通过缓存Class.forName和Class.getMethod的结果来避免反复调用的开销。</p>
<h3 id="⭐垃圾回收"><a href="#⭐垃圾回收" class="headerlink" title="⭐垃圾回收"></a>⭐垃圾回收</h3><h4 id="⭐如何判断一个对象是否死亡"><a href="#⭐如何判断一个对象是否死亡" class="headerlink" title="⭐如何判断一个对象是否死亡"></a>⭐如何判断一个对象是否死亡</h4><p>Java虚拟机使用的是<strong>可达性分析算法</strong>，这个算法是将一系列的[GC Roots](#GC Roots)作为初始的存活对象集合（live set），然后从这个集合开始，探索能够被这些对象引用到的对象，并将其加入到该集合。最终没有被探索到的对象就是已经死亡的，是可以回收的。</p>
<p>可达性分析算法可以解决<a href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95">引用计数法</a>的循环引用问题。因为就算A和B相互引用，只要从[GC Roots](#GC Roots)出发无法探索到A和B，可达性分析算法就不会把它们加入到存活的对象集合中（live set）。</p>
<blockquote>
<p><b id='引用计数法'>引用计数法</b>：是为每个对象添加一个引用计数器，用来统计指向该对象的引用数量。</p>
<p>具体逻辑是这样的：如果一个引用被赋值为某一个对象，那么该对象的引用计数器就会+1，如果这个引用又被赋值为其它对象，那么这个对象的引用计数器就会-1。</p>
<p>引用计数法需要拦截所有引用更新的操作，并且增减目标对象的引用计数器，还需要额外的空间存储计数器。</p>
<p>引用计数器还有一个严重的BUG，就是无法处理循环引用的对象。</p>
<p>假设对象A和B相互引用，除此之外没有其他引用指向A和B，这种情况下A和B实际已经死亡了，但是因为它们的引用计数器都不为0，就会导致这两个对象占据的内存空间不可回收，从而造成内存泄露。</p>
</blockquote>
<p>不过可达性分析算法也是有问题的，在多线程环境下，假设对象A没有被赋值给任何引用，所以没有被加入到存活的对象集合（live set）中，然后有一个线程把对象A赋值给某一个引用，这就会导致垃圾回收器会回收仍然被引用的对象。Java虚拟机是通过<a href="#Stop-the-world">Stop-the-world</a>来解决这个问题的。</p>
<p>⭐<b id='GC Roots'>GC Roots</b>：可以理解为堆中对象的引用。</p>
<ol>
<li>栈帧中的方法参数和局部变量</li>
<li>引用类型的静态变量</li>
<li>运行中的Java线程</li>
</ol>
<p>⭐<b id='Stop-the-world'>Stop-the-world</b>：就是阻塞其它非垃圾回收线程，直到完成垃圾回收。</p>
<p>Java虚拟机中的Stop-the-world是通过是通过<a href="#%E5%AE%89%E5%85%A8%E7%82%B9">安全点</a>（safepoint）机制来实现的，当Java虚拟机收到Stop-the-world请求，它就会等待所有线程都到达安全点之后，再让GC线程工作。</p>
<p>⭐<b id='安全点'>安全点（safepoint）</b>：</p>
<p>安全点实际上是一个稳定的状态，在这个状态下，Java虚拟机的堆栈内存不会发生变化，这样GC线程就可以安全地回收垃圾了。</p>
<p>具体的逻辑是这样的：Java虚拟机收到安全点请求的时候会设置一个标志位，Java线程在进入安全点时需要检查这个标志位，如果标志位被设置，当前线程需要停止，如果没有被设置，就继续执行。这样抵达安全点检测的线程就会进入停止状态。</p>
<p>安全点检测有三种情况：</p>
<ul>
<li><p>阻塞状态下的线程处于安全点。</p>
</li>
<li><p>对于解释执行来说，每条字节码的结尾都是安全点。所以Java虚拟机收到安全点请求时，每执行一条字节码就会进行一次安全点检测。</p>
</li>
<li><p>对于即时编译来说，即时编译后的机器码直接运行在底层硬件上，所以在生成机器码的时候，即时编译器需要插入安全点检测的指令。Java虚拟机的做法是在<strong>方法出口</strong>（return指令之前）和<strong>循环回边</strong>处（执行下一次循环之前）插入安全点检测。</p>
</li>
</ul>
<p>⭐<strong>为什么不在每个机器码都插入安全点检测</strong>？</p>
<p>执行安全点检测相当于一次内存访问的操作，所以它本身也是有开销的。</p>
<p>如果安全点的数量太少就会导致垃圾回收时间变长，因为Java虚拟机需要等所有线程都进入安全点之后才能进行垃圾回收。</p>
<h4 id="⭐垃圾回收算法"><a href="#⭐垃圾回收算法" class="headerlink" title="⭐垃圾回收算法"></a>⭐垃圾回收算法</h4><p><b id='标记-清除'>⭐标记-清除</b>：就是把死亡对象占据的内存空间标记为空闲内存，并记录在一个空闲列表中，当需要新建对象时，就把空闲列表中标记的空闲内存分配给新的对象。</p>
<p>这种方式有两个缺点：</p>
<p>一是会造成内存碎片，Java虚拟机堆中的对象必须是连续分布的，就有可能出现总空闲内存足够，但是无法分配的情况。</p>
<p>二是分配效率很低，Java虚拟机需要挨个访问空闲列表中的每一项，找到能够放下新对象的空闲内存。</p>
<p><b id='标记-压缩'>⭐标记-压缩</b>：就是把存活的对象聚集到内存的起始区域，可以留下一段连续的内存空间，这种做法可以解决内存碎片化的问题，代价是压缩算法的性能开销。</p>
<p><b id='标记-复制'>⭐标记-复制</b>：就是把内存分为两份，分别用两个指针from和to来维护，并且只用from指针指向的区域来分配内存，当发生垃圾回收时，就把from区域中存活的对象复制到to指针指向的区域，并且交换from和to指针的内容。</p>
<p>这种回收方式也可以解决内存碎片化的问题，它的缺点是堆空间使用效率非常低，只有一半的内存是可用的。</p>
<h4 id="⭐Java虚拟机的堆划分"><a href="#⭐Java虚拟机的堆划分" class="headerlink" title="⭐Java虚拟机的堆划分"></a>⭐Java虚拟机的堆划分</h4><p>Java虚拟机将堆划分为<strong>新生代</strong>和<strong>老年代</strong>，其中，新生代又被划分为Eden区和两个大小相同的Survivor区。</p>
<p>新生代用来存储新建的对象，当对象存活时间比较长时，就将其移动到老年代。</p>
<p>Java虚拟机会给新生代和老年代使用不同的回收算法：</p>
<ul>
<li><p>对于新生代，大部分的Java对象只存活一小段时间，虚拟机就会采用耗时较短的垃圾回收算法。</p>
</li>
<li><p>对于老年代，大部分垃圾已经在新生代中被回收了，处于老年代中的对象大概率会继续存活，真正触发老年代回收，通常是堆空间已经耗尽了，这时候Java虚拟机就会做一次全堆扫描（[Full GC](#Full GC)）。</p>
</li>
</ul>
<p>默认情况下，Java虚拟机会根据生成对象的速率，以及Survivor区的使用情况动态调整Eden区和Survivor区的比例。</p>
<p>也可以通过JVM参数<code>-XX:SurvivorRatio</code>来固定Eden区和Survivor的比例。需要注意的是，其中一个Survivor区是空的，Survivor分配的空间越大堆空间使用率就越低。</p>
<p>通常来说，当我们调用new指令时，虚拟机就会在Eden区分配一块储存新对象的空间。由于堆空间是线程共享的，所以划分空间是需要进行线程同步的，不然就有可能出现两个对象占用同一块内存的问题。</p>
<blockquote>
<p>如果创建的对象超过了年轻代最大对象阈值，会被直接创建在老年代。</p>
</blockquote>
<p>Java虚拟机的解决方案是<a href="#TLAB">TLAB</a>。如果新建的对象超过了TLAB剩余的内存空间，当前线程就会向虚拟机申请新的TLAB，如果新的TLAB还是放不下新建的对象，则在Eden区直接创建对象。</p>
<p>如果Eden区的空间耗尽了，Java虚拟机就会触发一次[Minor GC](#Minor GC)，来回收新生代中的垃圾。存活下来的对象会被移动到Survivor区。</p>
<p>新生代中的两个Survivor区，分别用from和to指针指向，from指向的区域是空的。发生[Minor GC](#Minor GC)时，Eden区和from指向的Survivor区中存活的对象会被复制到to指针指向的Survivor区，然后交换from和to指针，保证下次[Minor GC](#Minor GC)时，to指向的Survivor还是空的。</p>
<p>Java虚拟机会记录Survivor区中的对象被复制了多少次，如果一个对象被复制的次数超过15次，这个对象就会被移动到<strong>老年代</strong>。可以通过JVM参数<code>-XX:MaxTenuringThreshould</code>来调整。</p>
<p>如果单个Survivor区被占用超过50%，其中复制次数较多的对象也会被移动到<strong>老年代</strong>。</p>
<p>⭐<b id='TLAB'>TLAB（Thread Local Allocation Buffer）</b>：实际上就是在Eden区中为每个线程分配一块独立的内存空间，这样可以减少线程同步，提高内存分配的效率。每个线程需要维护两个指针，第一个指针指向内存开始位置，第二个指向末尾位置。然后通过<a href="#%E6%8C%87%E9%92%88%E5%8A%A0%E6%B3%95">指针加法</a>判断是否分配成功。</p>
<p>可以通过JVM参数<code>-XX:UseTLAB</code>禁用。</p>
<p>⭐<b id='指针加法'>指针加法</b>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((起始指针 + 请求的字节数) &lt;= 末尾指针) &#123;</span><br><span class="line">	起始指针 = 起始指针 + 请求的字节数;	<span class="comment">// 分配成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 分配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>⭐<b id='Minor GC'>Minor GC</b>：是新生代GC，只有Eden区耗尽时才会触发，采用的是<a href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6">标记-复制</a>算法。正常情况下，Eden区中的对象大部分都是已经死亡的对象，需要复制的数据很少，所以这种算法的效率很高。</p>
<p>Minor GC有一个问题，就是老年代的对象可能会引用新生代的对象。也就是说，在标记存活对象的时候，需要扫描老年代中的对象，如果老年代中的对象持有新生代对象的引用，这个引用就会作为[GC Roots](#GC Roots)。</p>
<p>这样一来Minor GC和[Full GC](#Full GC)就没有区别了。Java虚拟机的解决方案是<a href="#%E5%8D%A1%E8%A1%A8">卡表</a>（Card Table）。</p>
<p>⭐<b id='Full GC'>Full GC</b>：是老年代GC，调用System.gc()方法时可能会触发、老年代空间不足、<a href="#%E6%96%B9%E6%B3%95%E5%8C%BA">方法区</a>空间不足都会触发。</p>
<p>⭐<b id='卡表'>卡表</b>：就是把整个堆划分为一张张卡，每张卡的大小是512字节。然后再维护一张卡表，来保存每个卡的标志位。这个标志位代表对应的卡是否可能存在指向新生代对象的引用。如果可能存在引用，就认为这张卡是脏的。</p>
<p>这样在进行[Minor GC](#Minor GC)时，就不用扫描整个老年代，只需要在卡表中寻找脏卡就可以了，然后把脏卡中的对象作为[Minor GC](#Minor GC)的[GC Roots](#GC Roots)进行垃圾回收。扫描完脏卡之后，虚拟机就会将所有脏卡的标志位清零。</p>
<p>Java虚拟机是通过写屏障来维护卡表状态的，虚拟机会拦截所有引用类型变量的写操作，然后更新对应卡表的标志位。这个操作在解释执行中比较容易实现，但是在即时编译生成机器码的时候，需要插入写屏障。</p>
<p>出于性能考虑，写屏障不会判断更新后的引用是否指向新生代中的对象，而是一律当成新生代对象的引用。虽然写屏障会带来一些额外开销，但是可以提高[Minor GC](#Minor GC)的效率，还是值得的。</p>
<p>这里的写屏障实际上就是一条更新卡表标志位的指令。</p>
<h4 id="⭐垃圾回收器"><a href="#⭐垃圾回收器" class="headerlink" title="⭐垃圾回收器"></a>⭐垃圾回收器</h4><p>针对新生代的垃圾回收器有三个：<strong>Serial</strong>、<strong>Parallel Scavenge</strong>和<strong>Paralel New</strong>。</p>
<p>这三个采用的都是<a href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6"><strong>标记-复制</strong></a>算法。</p>
<p>Serial是单线程的，Parallel New是Serial的多线程版本，Parallel Scavenge和Parallel New类似，但是吞吐率更好，不能和CMS一起用。</p>
<p>针对老年代的垃圾回收器也有三个：<strong>Serial Old</strong>、<strong>Parallel Old</strong>和<strong>CMS</strong>。</p>
<p>Serial Old和Parallel Old采用的是<a href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9"><strong>标记-压缩</strong></a>算法。Parallel Old是Serial Old的多线程版本。</p>
<p>CMS采用的是<a href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4"><strong>标记-清除</strong></a>算法，它可以在程序运行期间进行垃圾回收。只有少数的几个操作需要<a href="#Stop-the-world"><strong>Stop-the-world</strong></a>。JDK9版本Java虚拟机使用<strong>G1</strong>来替代CMS。</p>
<p><strong>G1（Grabage First）</strong>：是一个横跨新生代和老年代的垃圾回收器，在G1中，直接把堆分成多个区域，每个区域都可以作为Eden区、Survivor区或者老年代。它采用的是<a href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9">标记-压缩</a>算法，而且可以在程序运行期间进行垃圾回收。G1可以单独对某一个区进行垃圾回收，所以它会优先回收死亡对象较多的区域。</p>
<h3 id="⭐synchronized实现原理"><a href="#⭐synchronized实现原理" class="headerlink" title="⭐synchronized实现原理"></a>⭐<b id='synchronized'>synchronized实现原理</b></h3><p>synchronized可以用来声明一个代码块，也可以直接标记整个方法。</p>
<p>如果用synchronized声明代码块，编译器会在代码块的开头和结尾加上monitorenter和monitorexit指令。</p>
<p>如果用synchronized标记方法，编译器会在方法的入口和出口加上monitorenter和monitorexit指令。</p>
<p>执行monitorenter指令的时候，如果锁对象的计数器为0，就说明当前锁对象没有被其他线程持有，Java虚拟机就会把锁对象的持有线程设置为当前线程，并把计数器+1。如果目标锁对象的计数器不为0，Java虚拟机还会判断锁对象的持有线程是否是当前线程，如果是，就再把计数器+1，否则就进入阻塞状态。所以synchronized是<a href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81">可重入锁</a>。</p>
<p>执行monitorexit指令的时候，Java虚拟机就会把锁对象的计数器减一，计数器为0就表示锁被释放掉了。编译器还会在异常执行路径（catch代码块）上插入monitorexit指令，确保发生异常时，锁也会被释放。</p>
<p>JDK6对synchronized做了优化，增加了从<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>到<a href="#synchronized-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">轻量级锁</a>再到<a href="#synchronized-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">重量级锁</a>的过度（这个过程是不可逆的）。</p>
<p>⭐<b id='synchronized-偏向锁'>偏向锁</b>：从始至终只有一个线程请求某一把锁。</p>
<p>加锁时，如果锁对象支持<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>，Java虚拟机会通过<a href="#CAS">CAS</a>操作，把当前线程的地址保存在锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>中，并且把<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>后三位设置成101。</p>
<p>解锁时，Java虚拟机会判断锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>中：**<a href="#epoch">epoch</a>值是否和锁对象中的<a href="#epoch">epoch</a>值相同<strong>、</strong>后三位是否为101<strong>、</strong>是否包含当前线程的地址**。</p>
<ul>
<li><p>如果这三个条件都满足，说明当前线程持有该偏向锁。</p>
</li>
<li><p>如果有条件不满足，就需要撤销偏向锁并升级为<a href="#synchronized-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">轻量级锁</a>。</p>
<blockquote>
<p>如果某一个类中的锁对象撤销次数达到阈值，默认是20次，Java虚拟机就会让这个类的<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>失效。</p>
<p>可以通过<code>-XX:BiasedLockingBulkRebiasThreshold</code>参数调整。</p>
</blockquote>
</li>
</ul>
<p>⭐<b id='synchronized-轻量级锁'>轻量级锁</b>：当<a href="#'synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>被多个线程访问时，就会升级为轻量级锁。</p>
<p>加锁时，JVM会在当前线程的栈帧中分配一块空间，用来保存锁记录（Lock Record），并且把锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>复制到锁记录中。</p>
<p>然后通过<a href="#CAS">CAS</a>操作，把锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>替换为刚才分配的锁记录的地址。（相当于判断加锁期间是否有其它线程获取锁）</p>
<ul>
<li>如果更新成功，就说明加锁成功。</li>
<li>如果更新失败，就说明有其它线程获取当前锁，Java虚拟机就会把这把锁升级为<a href="#synchronized-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">重量级锁</a>，并阻塞当前线程。</li>
</ul>
<p>解锁时，会通过<a href="#CAS">CAS</a>操作，比较锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>是否是锁记录的地址。</p>
<ul>
<li>如果是，就把<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>替换为锁记录中的值，也就是锁对象原本的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>。这样就成功释放锁了。</li>
<li>如果不是，说明锁已经升级为<a href="#synchronized-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">重量级锁</a>了。会进入<a href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">重量级锁</a>的解锁过程。</li>
</ul>
<p>⭐<b id='synchronized-重量级锁'>重量级锁</b>：是最基础的锁，这种锁会阻塞所有加锁失败的线程，并在释放锁的时候再唤醒这些线程。线程的阻塞和唤醒需要操作系统来完成，开销会非常大。</p>
<p>为了避免线程的阻塞和唤醒操作，Java虚拟机会在线程进入阻塞状态之前和被唤醒后竞争不到锁的时候，进入自旋状态。在自旋过程中，如果锁被释放了，那么线程就无需进入阻塞状态，可以直接获取锁。</p>
<p>自旋状态的线程仍然处于运行状态，只不过运行的是没有意义的指令。如果自旋的时间很长，就会浪费大量的CPU资源。</p>
<p>Java虚拟机的解决方案是适应性自旋，会根据以前自旋等待时是否能够获得锁，来动态调整自旋时间。如果以前只有很小的概率能通过自旋等待获得锁，那么虚拟机可能直接让线程进入阻塞状态。</p>
<p>自旋机制还会导致不公平的锁机制，处于阻塞状态的线程没办法立刻竞争锁，处于自旋状态的线程就有很大概率优先获得锁。</p>
<p><b id='epoch'>epoch</b>：</p>
<p>Java虚拟机会在每个类中都维护一个epoch值，这个epoch值可以理解为是<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>的版本号。</p>
<blockquote>
<p>在设置<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>的时候，Java虚拟机会把epoch值复制到锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>中。</p>
</blockquote>
<p>当某个类的<a href="#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>失效时，Java虚拟机就会把这个类的epoch值加1，表示之前的<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>已经失效了，新设置的<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>需要复制新的epoch值。</p>
<p>为了保证已经持有<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>的线程不会丢锁，虚拟机还需要通过<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>中保存的线程地址，找到持有这个<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>的线程，并把这些锁对象的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>中的epoch值加1。</p>
<p>如果某一个类中的<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>失效次数超过另一个阈值，默认是40次，Java虚拟机就会认为这个类不适合<a href="#synchronized-%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a>了。之后的加锁过程直接为该类的锁对象设置成<a href="#synchronized-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">轻量级锁</a>。</p>
<p>可以通过<code>-XX:BiasedLockingBulkRevokeThreshold</code>参数调整。</p>
<p><b id=''>如何区分锁等级</b>？</p>
<p>Java虚拟机会根据锁对象的对象头中的<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>的后两位，来判断对象的锁状态：00代表轻量级锁，01代表无锁或偏向锁，10代表重量级锁。</p>
<h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>在Java虚拟机中，每个对象都有一个对象头（object header），对象头由<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>（mark word）和类型指针（class pointer）组成。<a href="#%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5">标记字段</a>和类型指针各占64位（8字节），也就是说，每个Java对象在内存中都有16字节的额外开销。</p>
<p>以Integer为例，它内部维护了一个int类型的成员变量，占4个字节，再加上对象头的16个字节，就是20个字节，相当于int类型的5倍，这也是Java引入基本类型的原因之一。</p>
<p><b id='标记字段'>标记字段（Mark Word）</b>：用来存储对象的运行时数据，比如HashCode、GC信息、锁信息。类型指针是指向该对象的类信息。</p>
<blockquote>
<p>标记字段中的最后两位用来表示该对象的锁状态。</p>
<p>00 代表轻量级锁，01 代表无锁（或偏向锁），10 代表重量级锁，11 则跟垃圾回收算法的标记有关。</p>
</blockquote>
<h4 id="压缩指针"><a href="#压缩指针" class="headerlink" title="压缩指针"></a>压缩指针</h4><p>为了减少对象的内存使用量，Java虚拟机引入了压缩指针的概念（JVM参数 <code>-XX:+UseCompressedOops</code>，默认开启），将对象头的大小从16字节降低至12字节。</p>
<h3 id="⭐逃逸分析"><a href="#⭐逃逸分析" class="headerlink" title="⭐逃逸分析"></a>⭐逃逸分析</h3><p>逃逸分析是一种可以减少内存分配和回收压力的技术。Java虚拟机可以通过逃逸分析，判断对象是否发生逃逸。</p>
<blockquote>
<p>如果对象被存入堆中，或者对象被多处代码引用，就说明对象是逃逸的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span> &#123;	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();	<span class="comment">// 将对象return出去，会发生逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object obj;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	obj = <span class="keyword">new</span> <span class="title class_">Object</span>();	<span class="comment">// 将对象赋值为成员属性，会发生逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	test2(obj);	<span class="comment">// 将对象作为参数传递给其它方法，会发生逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>即时编译可以根据逃逸分析的结果进行<a href="#%E9%94%81%E6%B6%88%E9%99%A4">锁消除</a>、<a href="#%E9%94%81%E7%B2%97%E5%8C%96">锁粗化</a>、<a href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2">标量替换</a>的优化。</p>
<p>⭐<b id='锁消除'>锁消除</b>：</p>
<p>如果锁对象不逃逸，那么对于该对象的加锁和解锁是没有意义的，因为其它线程并不能获取该锁对象，也不可能对其进行加锁和解锁操作。这种情况下，即时编译就会消除对该对象的加锁和解锁操作。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">new</span> <span class="title class_">Object</span>()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码会被完全优化掉，因为其它线程无法获取到该锁对象。</p>
</blockquote>
<p>⭐<b id='锁粗化'>锁粗化</b>：</p>
<p>如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作。</p>
<blockquote>
<p>比如对于一段连续调用<code>StringBuffer.append()</code>方法的代码，只需要在第一次append方法时加锁，最后一次append方法结束后解锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferTest</span> &#123;</span><br><span class="line"> <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">()</span>&#123;</span><br><span class="line">     sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">     sb.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">     sb.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>⭐<b id='标量替换'>标量替换</b>：</p>
<p>标量替换可以理解为把原本对对象字段的访问，替换为一个个局部变量的访问。</p>
<p>实际上就是把要访问的目标对象内部的字段提取到当前方法的局部变量中，这样就可以减少对象的分配次数，从而提高垃圾回收的效率。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repeat</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();	<span class="comment">// 经过标量替换后该分配无意义，可以被优化掉</span></span><br><span class="line">	user.username = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">	user.password = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repeat</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span>;	<span class="comment">// 标量替换</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;xxx&quot;</span>;	<span class="comment">// 标量替换</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b id='栈上分配'>栈上分配</b>：</p>
<p>Java虚拟机中的对象是在堆上分配的，但是堆空间是线程共享的，Java虚拟机需要定期对堆空间进行垃圾回收。</p>
<p>其实对于不会发生逃逸的对象，Java虚拟机可以直接分配到栈上，这样就可以通过弹出当前方法栈帧时自动回收该对象占据的空间，就可以减少垃圾回收器需要回收的对象数量，可以提高垃圾回收的效率。</p>
<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>Java程序中的泛型在虚拟机中会被擦除。</p>
<p>没有限定继承类的泛型参数，经过泛型擦除后会变成Object类。</p>
<p>限定了继承类的泛型参数，经过泛型擦除后，泛型参数会变成限定的继承类。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">foo</span><span class="params">(T t)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过泛型擦除后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T <span class="title function_">foo</span><span class="params">(T)</span>;</span><br><span class="line">descriptor: (Ljava/lang/Number;)Ljava/lang/Number;</span><br><span class="line">flags: (<span class="number">0x0000</span>)</span><br><span class="line">Code:</span><br><span class="line"> stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">    <span class="number">0</span>: aload_1</span><br><span class="line">    <span class="number">1</span>: areturn</span><br><span class="line">Signature: (TT;)TT;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h3><p><b id='循环无关代码外提'>循环无关代码外提</b>：</p>
<p>在循环中，对于一些值不变的表达式，在能够不改变程序语义的情况下，把这些代码提出循环外，就可以避免重复执行这些代码，从而达到性能提升的效果。</p>
<p>比如我们在遍历一个集合的时候，通常会把<code>size()</code>方法放到循环体里面，但实际上<code>size()</code>方法是不会变化的，经过循环外提后，<code>size()</code>方法会作为局部变量保存起来。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">		sum += x + y + array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码中，循环体中的<code>x + y</code>以及array.length属于恒定不变的代码。经过循环无关代码外提后，会变成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> x + y;</span><br><span class="line">	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		sum += n + array[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><b id='循环展开'>循环展开</b>：</p>
<p>循环展开可以减少循环执行次数。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>, i++) &#123;</span><br><span class="line">		delete(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码需要循环200次，通过循环展开可以得到下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>, i+=<span class="number">5</span>) &#123;</span><br><span class="line">		delete(i);</span><br><span class="line">		delete(i+<span class="number">1</span>);</span><br><span class="line">		delete(i+<span class="number">2</span>);</span><br><span class="line">		delete(i+<span class="number">3</span>);</span><br><span class="line">		delete(i+<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/12/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="⭐工厂模式（Factory）"><a href="#⭐工厂模式（Factory）" class="headerlink" title="⭐工厂模式（Factory）"></a>⭐工厂模式（Factory）</h2><p>对象的创建逻辑比较复杂，就可以考虑使用工厂模式，把对象的创建过程和使用分开。</p>
<p>比如需要通过if-else动态创建不同的子类对象，就可以考虑把if-else的判断逻辑放到工厂类中。</p>
<p>比如单个对象本身的创建过程比较复杂，需要组合其它对象，做各种初始化操作，也可以把这些逻辑封装到工厂类中。</p>
<h3 id="⭐简单工厂"><a href="#⭐简单工厂" class="headerlink" title="⭐简单工厂"></a>⭐简单工厂</h3><p><strong>使用工厂模式实现解析不同格式的配置文件</strong>：</p>
<ol>
<li><p>定义工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParseFactory</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IRuleConfigParser&gt; cachedParsers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		cachedParsers.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>());</span><br><span class="line">		cachedParsers.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>());</span><br><span class="line">		cachedParsers.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (configFormat == <span class="literal">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> cachedParser.get(configFormat);</span><br><span class="line">		<span class="keyword">return</span> parser;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">        <span class="keyword">if</span> (parser == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(<span class="string">&quot;Rule config file format is not support&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> getFileContent();</span><br><span class="line">        <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">// ...获取文件拓展名，比如rule.json 返回json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="⭐工厂方法"><a href="#⭐工厂方法" class="headerlink" title="⭐工厂方法"></a>⭐工厂方法</h3><p><strong>使用工厂模式实现解析不同格式的配置文件</strong>：</p>
<ol>
<li><p>定义工厂方法类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">	IRuleConfigParser <span class="title function_">createPraser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>具体的工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// json格式配置文件的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xml格式配置文件的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// yaml格式配置文件的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>聚合工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据文件名后缀创建不同的工厂对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParseFactory</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedParsers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		cachedParsers.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParserFactory</span>());</span><br><span class="line">		cachedParsers.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParserFactory</span>());</span><br><span class="line">		cachedParsers.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParserFactory</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (configFormat == <span class="literal">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> cachedParser.get(configFormat);</span><br><span class="line">		<span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> parserFactory.createParser();	<span class="comment">// 调用工厂方法获取具体的工厂类</span></span><br><span class="line">		<span class="keyword">return</span> parser;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据配置文件的后缀，将文件中的配置解析成内存对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">        <span class="keyword">if</span> (parser == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(<span class="string">&quot;Rule config file format is not support: &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> getFileContent();</span><br><span class="line">        <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">// ...获取文件拓展名，比如rule.json 返回json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="⭐抽象工厂"><a href="#⭐抽象工厂" class="headerlink" title="⭐抽象工厂"></a>⭐抽象工厂</h3><p>就是在工厂类中定义不同类型的对象的创建方式，可以减少工厂类的数量。</p>
<p><strong>使用工厂模式实现解析不同格式的配置文件</strong>：</p>
<ol>
<li><p>定义抽象工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 创建rule配置文件解析器工厂类</span></span><br><span class="line">	IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 创建system配置文件解析器工厂类</span></span><br><span class="line">	ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>抽象工厂实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IConfigParserFactory</span> &#123;</span><br><span class="line">	<span class="comment">// 创建json格式的rule配置文件解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建json格式的system配置文件解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonSystemConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 创建xml格式的rule配置文件解析器</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建xml格式的system配置文件解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlSystemConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 创建yaml格式的rule配置文件解析器</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建yaml格式的system配置文件解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YamlSystemConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>聚合工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IConfigParserFactory&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonConfigParserFactory</span>());</span><br><span class="line">        map.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlConfigParserFactory</span>());</span><br><span class="line">        map.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlConfigParserFactory</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取rule配置文件解析器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createRuleParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (configFormat == <span class="literal">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="type">IConfigParserFactory</span> <span class="variable">factory</span> <span class="operator">=</span> map.get(configFormat);</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> factory.createRuleParser();</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取system配置文件解析器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ISystemConfigParser <span class="title function_">createSystemParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (configFormat == <span class="literal">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="type">IConfigParserFactory</span> <span class="variable">factory</span> <span class="operator">=</span> map.get(configFormat);</span><br><span class="line">        <span class="type">ISystemConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> factory.createSystemParser();</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h2><p><strong>单例模式就是一个类只允许创建一个实例</strong>。</p>
<p><strong>应用场景</strong>：</p>
<p>比如有些数据在系统中只应保存一份，就比较适合设计成单例类，比如用来保存系统配置的类，就比较适合设计成单例类。</p>
<p>比如某些系统中会缓存一些变动不太频繁的冷数据，通常就是在类中声明一些集合类型的成员变量用来缓存数据，这种也比较适合设计成单例类。</p>
<p>单例模式根据不同的创建方式，可以分细为五类：<strong>饿汉式、懒汉式、双重检测、静态内部类、枚举</strong>。</p>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>饿汉式就是在类加载的时候，就开始创建实例并初始化，这样的创建过程是线程安全的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些人认为提前初始化实例是一种浪费资源的行为，应该等用到的时候再去初始化，不过如果初始化的逻辑比较复杂，耗时比较长，这就会影响到系统的性能。</p>
<p>用饿汉式把一些耗时的操作，提前到程序启动的时候完成，这样就能避免初始化的性能问题。</p>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p><strong>懒汉式可以实现延迟加载，就是在用到的时候，才去创建实例并初始化</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">			singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在多线程环境中，饿汉式就需要通过加锁来确保只会创建一个实例，如果这个类经常被调用，就会导致频繁的加锁和解锁，会影响到系统的性能。</p>
<h3 id="双重检测机制"><a href="#双重检测机制" class="headerlink" title="双重检测机制"></a><b id='双重检测机制'>双重检测机制</b></h3><p>双重检测也可以实现延迟加载，主要是为了解决，多线程环境下懒汉式并发度很低的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class) &#123;	<span class="comment">// 对Singleton这个类加锁，会锁住所有singleton对象</span></span><br><span class="line">				<span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">					singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为指令重排，可能会导致Singleton对象被new出来之后，还没来得及初始化，就被使用了。这个问题可以通过给成员变量加上volatile关键字，禁止指令重排。</p>
<p>实际上这个问题只有很低的JDK版本才会有，高版本的JDK内部已经解决了这个问题，就是把创建对象的new操作，和初始化操作设计为原子操作，就可以禁止指令重排。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p><strong>静态内部类这种方式也可以实现延迟加载</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;	<span class="comment">// 私有构造方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;	<span class="comment">// 创建静态内部类</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();	<span class="comment">// 在静态内部类中创建实例</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类就是在类中定义一个静态内部类，在这个内部类中定义初始化的逻辑。当外部类被加载的时候，并不会创建内部类的实例对象，只有调用getInstance()方法的时候，内部类才会被加载，这个时候才会创建外部类的实例对象。</p>
<p>这个创建过程是由JVM来完成的，是线程安全的，也可以实现延迟加载。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>基于枚举来实现单例，是最简单的一种方式了，就是通过Java枚举本身的特点，来保证实例创建的线程安全性和实例唯一性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="⭐建造者模式（Builder）"><a href="#⭐建造者模式（Builder）" class="headerlink" title="⭐建造者模式（Builder）"></a>⭐建造者模式（Builder）</h2><p>建造者模式主要是用来创建一些比较复杂的对象。</p>
<h3 id="数据填充和校验"><a href="#数据填充和校验" class="headerlink" title="数据填充和校验"></a>数据填充和校验</h3><p>如果一个类中有很多属性，有些属性是必填的，有些是非必填的。比较简单的做法就是把必填属性放在构造函数中，其它非必填的用set()方法设置。如果必填的属性有很多，就会导致构造函数参数列表很长，使用起来就很容易出错。</p>
<ol>
<li><p>写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourcePoolConfig</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> maxTotal;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> maxIdle;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> minIdle;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">ResourcePoolConfig</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = builder.name;</span><br><span class="line">		<span class="built_in">this</span>.maxTotal = builder.maxTotal;</span><br><span class="line">		<span class="built_in">this</span>.maxIdle = builder.maxIdle;</span><br><span class="line">		<span class="built_in">this</span>.minIdle = builder.minIdle;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 通过Builder内部类完成属性填充</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> maxTotal;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> maxIdle;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> minIdle;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> ResourcePoolConfig <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 对属性做校验</span></span><br><span class="line">			<span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;name can&#x27;t be empty&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourcePoolConfig</span>(<span class="built_in">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.name = name;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setMaxTotal</span><span class="params">(<span class="type">int</span> maxTotal)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.maxTotal = maxTotal;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setMaxIdle</span><span class="params">(<span class="type">int</span> maxIdle)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.maxIdle = maxIdle;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> Builder <span class="title function_">setMinIdle</span><span class="params">(<span class="type">int</span> minIdle)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.minIdle = minIdle;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">ResourcePoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> ResourcePoolConfig.Builder()</span><br><span class="line">                            .setName(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">                            .setMaxTotal(<span class="number">10</span>)</span><br><span class="line">                            .setMaxIdle(<span class="number">5</span>)</span><br><span class="line">                            .setMinIdle(<span class="number">2</span>)</span><br><span class="line">                            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="原型模式（Property）"><a href="#原型模式（Property）" class="headerlink" title="原型模式（Property）"></a>原型模式（Property）</h2><p><strong>如果一个对象的创建成本比较大，并且存在其它大部分字段都相同的对象，这种情况可以利用已有的对象，通过复制的方式来创建新的对象，这就叫原型模式</strong>。</p>
<p>原型模式有两种实现方法，深拷贝和浅拷贝。</p>
<ul>
<li>浅拷贝只会复制对象中基本数据类型和引用对象的内存地址，不会递归的复制引用对象，以及引用对象的引用对象…。</li>
<li>深拷贝得到的是一份完全独立的对象，所以深拷贝会更加耗时，更耗内存空间。</li>
</ul>
<h3 id="实现缓存功能"><a href="#实现缓存功能" class="headerlink" title="实现缓存功能"></a>实现缓存功能</h3><p>很多时候我们会在系统启动的时候，从数据库中加载一些数据到内存中，用来做缓存。为了保证缓存中数据的正确性，通常会定期更新内存中的数据，这个时候就可以利用原型模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Property</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ConcurrentHashMap&lt;String, SearchWorld&gt; currentKeywords = <span class="keyword">new</span> <span class="title class_">CurrentHashMap</span>&lt;String, SearchWorld&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastUpdateTime</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 刷新缓存</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">		HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywods.clone();</span><br><span class="line">		<span class="comment">// 从数据库中查询发生变更的数据（更新时间 &gt; lastUpdateTime），放入到newKeywords中</span></span><br><span class="line">		List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWordFromDB(lastUpdateTime);</span><br><span class="line">		<span class="type">long</span> <span class="variable">maxNewUpdateTime</span> <span class="operator">=</span> lastUpdateTime;</span><br><span class="line">		<span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">			<span class="keyword">if</span> (searchWord.getLastUpdateTime &gt; maxNewLastUpdateTime) &#123;</span><br><span class="line">				maxNewLastUpdateTime = searchWord.getLastUpdateTime();</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 删除旧数据</span></span><br><span class="line">			<span class="keyword">if</span> (newKeywods.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">				newKeywods.remove(searchWord.getKeyword(), searchWord);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 覆盖掉原来的对象</span></span><br><span class="line">			newKeywods.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">		&#125;</span><br><span class="line">		lastUpdateTime = maxNewLastUpdateTime;</span><br><span class="line">		currentKeywords = newKeywords;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 从数据库中查询更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWordFromDB</span><span class="params">(<span class="type">long</span> lastUpdateTime)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="⭐代理模式（Proxy）"><a href="#⭐代理模式（Proxy）" class="headerlink" title="⭐代理模式（Proxy）"></a>⭐代理模式（Proxy）</h2><p><strong>就是在不修改原代码的情况下，通过代理类来给原始类附加额外的功能</strong>。</p>
<p>代理模式又分为：静态代理和动态代理。</p>
<h3 id="⭐静态代理"><a href="#⭐静态代理" class="headerlink" title="⭐静态代理"></a>⭐静态代理</h3><p>为每个类都创建一个代理类，并且每个代理类都要把原始类中的方法实现一遍，再附加一些额外的代理逻辑。</p>
<ol>
<li><p>原始类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">		<span class="comment">// 登录逻辑...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserController userController;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">(UserController userController)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userController = userController;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">		<span class="comment">// 委托</span></span><br><span class="line">        userController.login(username, password);</span><br><span class="line">		<span class="comment">// 添加一些额外的逻辑，比如登录成功后发送短信通知</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">UserControllerProxy</span> <span class="variable">userControllerProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>(<span class="keyword">new</span> <span class="title class_">UserController</span>());</span><br><span class="line">	userControllerProxy.login(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="⭐动态代理"><a href="#⭐动态代理" class="headerlink" title="⭐动态代理"></a>⭐动态代理</h3><p>就是不预先为每个类创建代理类，而是在运行的时候，动态的创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<p><strong>Java可以通过InvocationHandler接口和Proxy类来实现动态代理</strong>：</p>
<ol>
<li><p>代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object proxyObject)</span> &#123;</span><br><span class="line">		Class&lt;?&gt;[] interfaces = proxyObject.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 创建动态代理处理器</span></span><br><span class="line">		<span class="type">DynamicProxyHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(proxyObject);</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(proxyObject.getClass().getClassLoader(), interfaces);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>动态代理处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Object proxyObject;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(Object proxyObject)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.proxyObject = proxyObject;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 代理逻辑...</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(proxyObject, args);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">UserProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserProxy</span>();</span><br><span class="line">	<span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> (UserController) proxy.createProxy(<span class="keyword">new</span> <span class="title class_">UserController</span>())</span><br><span class="line">	userController.login();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐桥接模式（Bridge）"><a href="#⭐桥接模式（Bridge）" class="headerlink" title="⭐桥接模式（Bridge）"></a>⭐桥接模式（Bridge）</h2><p>将抽象部分和实现部分分离，让它们都可以独立的变化。</p>
<h3 id="⭐消息推送功能"><a href="#⭐消息推送功能" class="headerlink" title="⭐消息推送功能"></a>⭐消息推送功能</h3><ol>
<li><p>创建消息推送接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消息推送实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以短信的方式发送消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TelephoneMsgSender</span> <span class="keyword">implements</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; telephones;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">		<span class="comment">// 发送短信逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以邮件的方式发送消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailMsgSender</span> <span class="keyword">implements</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; emails;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">		<span class="comment">// 发送邮件逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以微信的方式发送消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatMsgSender</span> <span class="keyword">implements</span> <span class="title class_">MsgSender</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; wechats;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">		<span class="comment">// 发送微信逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建桥接类，根据消息的紧急程度，将消息发送到不同渠道（不同紧急程度的消息和发送渠道的对应关系，可以动态配置）</p>
<ol>
<li><p>定义消息通知抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">    <span class="comment">// 消息发送渠道</span></span><br><span class="line">	<span class="keyword">protected</span> MsgSender msgSender;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Notification</span><span class="params">(MsgSender msgSender)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.msgSender = msgSender;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>消息通知具体实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严重通知级别</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SevereNotification</span> <span class="keyword">extends</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SevereNotification</span><span class="params">(MsgSender msgSender)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(msgSender);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">		msgSender.send(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 紧急通知级别</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrgencyNotification</span> <span class="keyword">extends</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">UrgencyNotification</span><span class="params">(MsgSender msgSender)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(msgSender);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">		msgSender.send(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">Notification</span> <span class="variable">notifiaction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrgencyNotification</span>(<span class="keyword">new</span> <span class="title class_">EmailSender</span>());</span><br><span class="line">	notification.notify(<span class="string">&quot;这是一条紧急信息...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐装饰器模式（Decoreator）"><a href="#⭐装饰器模式（Decoreator）" class="headerlink" title="⭐装饰器模式（Decoreator）"></a>⭐装饰器模式（Decoreator）</h2><p><strong>装饰器模式跟代理模式的结构基本一样，只不过代理模式是为原始类增加一些额外的功能，装饰器模式是增强原始类现有的功能</strong>。</p>
<h3 id="⭐增强登录功能"><a href="#⭐增强登录功能" class="headerlink" title="⭐增强登录功能"></a>⭐增强登录功能</h3><ol>
<li><p>用户登录接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginApi</span> &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>原始类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> <span class="keyword">implements</span> <span class="title class_">LoginApi</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">		<span class="comment">// ...登录逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>发送邮件的装饰器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登陆成功后发送邮件的装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginControllerWithSendEmail</span> <span class="keyword">implements</span> <span class="title class_">LoginApi</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoginApi loginApi;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sender</span> <span class="variable">sender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmailSender</span>();	<span class="comment">// 发送邮件工具类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserControllerWithSendEmail</span><span class="params">(LoginApi loginApi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginApi = loginApi;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> loginApi.login(username, password);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="comment">// 登陆成功，发送邮件</span></span><br><span class="line">	        sender.send(<span class="string">&quot;登陆成功...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生成登录记录的装饰器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登陆成功后生成一条登录信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginControllerWithCreateRecord</span> <span class="keyword">implements</span> <span class="title class_">LoginApi</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoginApi loginApi;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">LoginRecordRepository</span> <span class="variable">loginRecordRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRecordRepository</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginControllerWithCreateRecord</span><span class="params">(LoginApi loginApi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginApi = loginApi;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> loginApi.login(username, password);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="comment">// 创建一条登录信息</span></span><br><span class="line">            <span class="type">LoginRecord</span> <span class="variable">loginRecord</span> <span class="operator">=</span> LoginRecord.builder()</span><br><span class="line">                .address(<span class="string">&quot;合肥&quot;</span>)</span><br><span class="line">                .ip(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br><span class="line">                .timestamp(LocalDateTime.now())</span><br><span class="line">                .build();</span><br><span class="line">            loginRecordRepository.create(loginRecord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">LoginApi</span> <span class="variable">loginApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginControllerWithCreateRecord</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LoginControllerWithSendEmail</span>(</span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">LoginController</span>()</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    loginApi.login(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐适配器模式（Adapter）"><a href="#⭐适配器模式（Adapter）" class="headerlink" title="⭐适配器模式（Adapter）"></a>⭐适配器模式（Adapter）</h2><p><strong>适配器模式就是用一个新类，把原来的类包装一下，用来解决两个不兼容的类可以在一起工作</strong>。</p>
<p>比如某个功能需要依赖多个外部系统，这些外部系统接口的参数和返回值格式都不一样，这时候就可以通过适配器模式，把它们的接口适配为统一的接口定义。</p>
<h3 id="⭐数据聚合功能"><a href="#⭐数据聚合功能" class="headerlink" title="⭐数据聚合功能"></a>⭐数据聚合功能</h3><ol>
<li><p>从多种数据库查询数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//... 从mysql中获取数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLProvider</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">find</span><span class="params">(String str1)</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.. 从Oracle中获取数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleProvider</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">find</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//... 从Redis中获取数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisProvider</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义适配器接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDataProvider</span> &#123;</span><br><span class="line">	List&lt;String&gt; <span class="title function_">find</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根据不同的数据渠道定义不同的适配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLProviderAdapter</span> <span class="keyword">implements</span> <span class="title class_">IDataProvider</span> &#123;	<span class="comment">// MySQL适配器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">MySQLPrivider</span> <span class="variable">mysqlProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySQLProvider</span>();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">find</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mysqlProvider.find(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleProviderAdapter</span> <span class="keyword">implements</span> <span class="title class_">IDataProvider</span> &#123;	<span class="comment">// Oracle适配器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">OracleProvidedr</span> <span class="variable">oracleProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OracleProvider</span>();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">find</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		Map&lt;String, String&gt; data = oracleProvider.find(str, <span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">		List&lt;String&gt; res = map2List(data);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisProvider</span> <span class="keyword">implements</span> <span class="title class_">IDataProvider</span> &#123;	<span class="comment">// Redis适配器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">RedisProvider</span> <span class="variable">redisProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisProvider</span>();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">find</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> redisProvider.get(str);</span><br><span class="line">		<span class="keyword">return</span> Collections.singletonList(data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>聚合适配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataManagement</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IDataProvider&gt; providers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProvider</span><span class="params">(IDataProvider provider)</span> &#123;</span><br><span class="line">        providers.add(provider);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">find</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (IDataProvider provider : providers) &#123;</span><br><span class="line">            List&lt;String&gt; data = provider.find(str);</span><br><span class="line">            result.addAll(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    <span class="type">DataManagement</span> <span class="variable">dataManagement</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataManagement</span>();</span><br><span class="line">    dataManagement.addProvider(<span class="keyword">new</span> <span class="title class_">MySQLProviderAdapter</span>());	<span class="comment">// 添加MySQL适配器</span></span><br><span class="line">    dataManagement.addProvider(<span class="keyword">new</span> <span class="title class_">OracleProviderAdapter</span>());	<span class="comment">// 添加Oracle适配器</span></span><br><span class="line">    dataManagement.addProvider(<span class="keyword">new</span> <span class="title class_">RedisProviderAdapter</span>());	<span class="comment">// 添加Redis适配器</span></span><br><span class="line">    List&lt;String&gt; result = dataManagement.find(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="门面模式（Facade）"><a href="#门面模式（Facade）" class="headerlink" title="门面模式（Facade）"></a>门面模式（Facade）</h2><p>比如用户注册的时候，需要生成一条用户信息，还要给用户分配角色。这样注册这个功能就需要依赖，用户和角色两个服务。</p>
<p>传统的做法就是在用户注册服务中，依赖注入创建用户接口和分配角色接口。如果注册时还有更多的操作，就需要依赖更多的接口。</p>
<p>这种情况就可以定义一个门面服务，让门面服务去依赖用户服务和角色服务。这样注册服务只需要依赖门面服务就可以了。</p>
<p><strong>提高效率</strong>：如果依赖的服务需要通过RPC调用，也可以通过门面模式把多次RPC调用减少为1次。</p>
<p><strong>实现事物</strong>：有些时候需要调用两个更新数据的方法，这两个操作需要同时成功或者同时失败，最简单的方式就是：再设计一个包含这两个方法的新方法。这也是门面模式的一种设计思想。</p>
<h3 id="实现用户注册功能"><a href="#实现用户注册功能" class="headerlink" title="实现用户注册功能"></a>实现用户注册功能</h3><ol>
<li><p>用户注册门面服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterFacade</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RoleService roleService;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(User user)</span> &#123;</span><br><span class="line">		userService.create(user);		<span class="comment">// 创建用户</span></span><br><span class="line">		roleService.setRole(user);	<span class="comment">// 分配角色</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用户注册服务接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemService</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> UserRegisterFacade registerFacade;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">register</span><span class="params">(User user)</span> &#123;</span><br><span class="line">		<span class="comment">// 调用门面服务中的操作</span></span><br><span class="line">		registerFacade.post(user);</span><br><span class="line">        <span class="comment">// 执行注册后续的操作...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐组合模式（Compose）"><a href="#⭐组合模式（Compose）" class="headerlink" title="⭐组合模式（Compose）"></a>⭐组合模式（Compose）</h2><p>组合模式可以很方便的把不同类型的对象组合成树形结构。</p>
<h3 id="⭐实现结构树"><a href="#⭐实现结构树" class="headerlink" title="⭐实现结构树"></a>⭐实现结构树</h3><ol>
<li><p>定义组织结构抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Organization</span> &#123;	<span class="comment">// 用来做一些额外的处理逻辑</span></span><br><span class="line">	<span class="keyword">protected</span> BigDecimal salary;	<span class="comment">// 工资</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;	<span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> BigDecimal <span class="title function_">calculateSalary</span><span class="params">()</span>;	<span class="comment">// 计算部门所有工资总和（包括下级部门）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">calculateAverageAge</span><span class="params">()</span>;	<span class="comment">// 计算部门平均年龄</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isDeparment</span><span class="params">()</span>;	<span class="comment">// 是否是部门， 部门：true，员工：false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>部门类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Deparment</span> <span class="keyword">implements</span> <span class="title class_">Organization</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Organization&gt; subOrganizations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrganization</span><span class="params">(Organization org)</span> &#123;</span><br><span class="line">		subOrganizations.add(org);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"> 	  <span class="meta">@Override</span></span><br><span class="line">  	<span class="keyword">public</span> BigDecimal <span class="title function_">calculateSalary</span><span class="params">()</span> &#123;	</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalSalary</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">        <span class="keyword">for</span> (Organization org : subOrganizations) &#123;</span><br><span class="line">          totalSalary.add(org.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSalary;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateAverageAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalAge</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">employeeCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Organization org : subOrganizations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isDeparment()) &#123;</span><br><span class="line">                totalAge += org.getAge();</span><br><span class="line">                employeeCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalAge / employeeCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeparment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">public</span> BigDecimal <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="type">BigDecimal</span> <span class="variable">totalSalary</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line">        <span class="keyword">for</span> (Organization org : subOrganizations) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!org.isDepartment()) &#123;</span><br><span class="line">            totalSalary.add(org.getSalary());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSalary;</span><br><span class="line"> 	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>员工类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Organization</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">calculateSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.salary();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateAverageAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeparment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">DeparmentRepository</span> <span class="variable">deparmentRepo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeparmentRepository</span>();	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">EmployeeRepository</span> <span class="variable">employeeRepo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeRepository</span>();	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORGANIZATION_ROOT_ID</span> <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">// 顶级部门ID</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildOrganization</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Deparment</span> <span class="variable">deparment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Deparment</span>();</span><br><span class="line">		deparment.setId(ORGANIZATION_ROOT_ID);</span><br><span class="line">		buildOrganization(deparment);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildOrganization</span><span class="params">(Deparment deparment)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据部门ID获取某个部门的下级部门</span></span><br><span class="line">    List&lt;Deparemnt&gt; subDeparments = deparmentRepo.getDeparmentByParentId(deparment.getId());	</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">for</span> (Deparment subDeparment : subDeparments) &#123;</span><br><span class="line">			deparment.addOrganization(subDeparment);</span><br><span class="line">			buildOrganization(subDeparment);</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">   	    <span class="comment">// 根据部门ID获取员工列表</span></span><br><span class="line">		List&lt;Employee&gt; employees = employeeRepo.getEmployeeByDeparmentId(deparment.getId());	</span><br><span class="line">		<span class="keyword">for</span> (Employee employee : employees) &#123;</span><br><span class="line">			deparment.addOrganization(employee);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐享元模式（Flyweight）"><a href="#⭐享元模式（Flyweight）" class="headerlink" title="⭐享元模式（Flyweight）"></a>⭐享元模式（Flyweight）</h2><p><strong>享元模式可以复用对象，节省内存，不过前提是享元对象是不可变的对象</strong>。</p>
<p>如果系统中有很多重复的对象，并且这些对象都是不可变的，就可以利用享元模式，让这些对象在内存中只保留一份，提供多处引用，这样可以减少内存中对象的数量。</p>
<p>也可以把对象之间相同的字段提取出来，设计成享元类，让这些对象引用享元对象。</p>
<p>不可变对象是指，对象通过构造函数初始化完成之后，就不能再做修改了，所以不能暴露任何set()方法，因为享元对象会被多处引用，如果某一个地方修改了享元对象，就会影响到其它代码。</p>
<p><strong>比较常见的做法就是通过工厂模式，在工厂类中，用一个Map来缓存已经创建过的享元对象，来达到复用的目的</strong>。</p>
<p>比如Integer类中的IntegerCache、Long类中的LongCache也都是利用享元模式来预先存储一些常用的数字(-128~127)</p>
<p><strong>缺点</strong>：享元模式会导致享元类无法被GC回收掉，因为享元工厂类会一直保存着享元对象的引用，这就会导致享元对象在没有任何代码使用的情况下，也不会被JVM回收掉。</p>
<h3 id="⭐实现棋盘游戏"><a href="#⭐实现棋盘游戏" class="headerlink" title="⭐实现棋盘游戏"></a>⭐实现棋盘游戏</h3><ol>
<li><p>定义享元类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部定义了一些通用的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceUnit</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChessPieceUnit</span><span class="params">(<span class="type">int</span> id, String text, Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">        RED, BLACK</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>享元工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceUnitFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        pieces.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">1</span>, <span class="string">&quot;车&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        pieces.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">2</span>, <span class="string">&quot;马&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        pieces.put(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">3</span>, <span class="string">&quot;象&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        pieces.put(<span class="number">4</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">4</span>, <span class="string">&quot;士&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        pieces.put(<span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">ChessPieceUnit</span>(<span class="number">5</span>, <span class="string">&quot;将&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChessPieceUnit <span class="title function_">getChessPiece</span><span class="params">(<span class="type">int</span> chessPieceId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pieces.get(chessPieceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>棋子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ChessPieceUnit chessPieceUnit; <span class="comment">// 引用的享元类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionX;	<span class="comment">// 棋子在棋盘上的x坐标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> positionY;	<span class="comment">// 棋子在棋盘上的y坐标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChessPiece</span><span class="params">(ChessPieceUnit chessPieceUnit, <span class="type">int</span> positionX, <span class="type">int</span> positionY)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chessPieceUnit = chessPieceUnit;</span><br><span class="line">        <span class="built_in">this</span>.positionX = positionX;</span><br><span class="line">        <span class="built_in">this</span>.positionY = positionY;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>棋盘类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChessBoard</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">      chessPieces.put(<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">ChessPiece</span>(ChessPieceUnitFactory.getChessPiece(<span class="number">1</span>), <span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">      chessPieces.put(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">ChessPiece</span>(ChessPieceUnitFactory.getChessPiece(<span class="number">2</span>), <span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">      chessPieces.put(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">ChessPiece</span>(ChessPieceUnitFactory.getChessPiece(<span class="number">3</span>), <span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">      chessPieces.put(<span class="number">4</span>,<span class="keyword">new</span> <span class="title class_">ChessPiece</span>(ChessPieceUnitFactory.getChessPiece(<span class="number">4</span>), <span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">      chessPieces.put(<span class="number">5</span>,<span class="keyword">new</span> <span class="title class_">ChessPiece</span>(ChessPieceUnitFactory.getChessPiece(<span class="number">5</span>), <span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> chessPieceId, <span class="type">int</span> toPositionX, <span class="type">int</span> toPositionY)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐观察者模式（Observer）"><a href="#⭐观察者模式（Observer）" class="headerlink" title="⭐观察者模式（Observer）"></a>⭐观察者模式（Observer）</h2><p><strong>就是在对象之间维护一个中间层，当一个对象状态改变的时候，其它所有依赖的对象都会自动收到通知</strong>。</p>
<p>guava包中的事件总线就是观察者模式（EventBus）</p>
<h3 id="⭐实现注册功能"><a href="#⭐实现注册功能" class="headerlink" title="⭐实现注册功能"></a>⭐实现注册功能</h3><ol>
<li><p>定义观察者接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span>;	<span class="comment">// 用户注册成功时的事件通知函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义观察者实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为新用户生成密码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> PromotionService promitionService;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">		promotionService.generatePassword(userId);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送欢迎邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegNotificationObserver</span> <span class="keyword">implements</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> NotificationService notificationService;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">		notificationService.sendMessage(userId, <span class="string">&quot;Welcome...&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用户注册接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="comment">// 观察者</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;RegObserver&gt; regObservers;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRegObservers</span><span class="params">(List&lt;RegObserver&gt; observers)</span> &#123;</span><br><span class="line">		regObservers = observers;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">		<span class="comment">// 用户注册</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 用户注册完成后，通知其它服务</span></span><br><span class="line">		<span class="keyword">for</span> (RegObserver observer : regObservers) &#123;</span><br><span class="line">			observer.handleRegSuccess(userId);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    regObservers.add(<span class="keyword">new</span> <span class="title class_">RegNotificationObserver</span>());</span><br><span class="line">    regObservers.add(<span class="keyword">new</span> <span class="title class_">RegPromotionObserver</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">    userController.setRegObservers(regObservers);</span><br><span class="line">    userController.register(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>用户注册完之后，要依次调用所有观察者的事件通知方法，都执行完，才会返回结果给客户端，这会影响到注册接口的响应时间。</p>
<p>可以改成异步非阻塞的方式，调用观察者的通知方法，比如在线程池中执行事件通知方法。</p>
<p>也可以用Event Bus（事件总线）框架，或者RocketMQ之类的消息队列。</p>
<h3 id="⭐事件总线"><a href="#⭐事件总线" class="headerlink" title="⭐事件总线"></a>⭐事件总线</h3><ol>
<li><p>定义标记注解，用来标明观察者中，哪个函数可以接收消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用来表示@Subscribe 标注的方法。target表示观察者类，method表示方法。主要用在ObserverRegistry观察者注册表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverAction</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="keyword">private</span> Method method;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ObserverAction</span><span class="params">(Object target, Method method)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.target = Precondition.checkNotNull(target);</span><br><span class="line">		<span class="built_in">this</span>.method = method;</span><br><span class="line">		<span class="built_in">this</span>.method.setAccessable(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// event是method方法的参数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			method.invoke(target, event);</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverRegistry</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 注册</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object observer)</span> &#123;</span><br><span class="line">		Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt; observerActions = findAllObserverActions(observer);</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions.entrySet()) &#123;</span><br><span class="line">			Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">			Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class="line">			CopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions = registry.get(eventType);</span><br><span class="line">			<span class="keyword">if</span> (registeredEventActions == <span class="literal">null</span>) &#123;</span><br><span class="line">				registry.putIfAbsent(eventType, <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;());</span><br><span class="line">				registeredEventActions = registry.get(eventType);</span><br><span class="line">			&#125;</span><br><span class="line">			registeredEventActions.addAll(eventActions);</span><br><span class="line">            registry.put(eventType, registeredEventActions);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 找到符合条件的处理器</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;ObserverAction&gt; <span class="title function_">getMatchedObserverActions</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">		List&lt;ObserverAction&gt; matchedObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		Class&lt;?&gt; postedEventType = event.getClass();</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry) &#123;</span><br><span class="line">			Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">			CopyOnWriteArraySet&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class="line">			<span class="comment">// 判断是否是父类</span></span><br><span class="line">			<span class="keyword">if</span> (postedEventType.isAssignableFrom(eventType)) &#123;</span><br><span class="line">				matchedObservers.addAll(eventActions);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> matchedObservers;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) &#123;</span><br><span class="line">		Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; clazz = observer.getClass();</span><br><span class="line">        <span class="keyword">for</span> (Method method : clazz.getDeclaredMethods() &#123;</span><br><span class="line">	        <span class="keyword">if</span> (method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">	        	Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">	        	<span class="keyword">if</span> (parameterTypes.length != <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArgumentException</span>(<span class="string">&quot;参数长度错误&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">				<span class="keyword">if</span> (!observerActions.containsKey(eventType)) &#123;</span><br><span class="line">					observerActions.put(eventType, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">				&#125;</span><br><span class="line">				observerActions.get(eventType).add(<span class="keyword">new</span> <span class="title class_">ObserverAction</span>(observer, method));</span><br><span class="line">	        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> observerActions;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>事件总线</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步事件总线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Executor executor;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">ObserverRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverRegistry</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">EventBus</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// MoreExecutors.directExecutor()是Google Guava提供的工具类，实际上是一个单线程的线程池，主要还是为了跟AsyncEventBus统一代码逻辑，做到代码复用。</span></span><br><span class="line">		<span class="built_in">this</span>(MoreExecutors.directExecutor());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">EventBus</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.executor = executor;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">		registry.register(object);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">		List&lt;ObserverAction&gt; observerActions = registry.getMatchedObserverActions(event);</span><br><span class="line">		<span class="keyword">for</span> (ObserverAction observerAction : observerActions) &#123;</span><br><span class="line">			executor.execute(<span class="keyword">new</span> <span class="title class_">Runable</span>() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">					observerAction.execute(event);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步事件总线</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncEventBus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AsyncEventBus</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">	eventBus.register(<span class="keyword">new</span> <span class="title class_">RegNotificationObserver</span>());</span><br><span class="line">	eventBus.post(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐模板模式（Template-Method）"><a href="#⭐模板模式（Template-Method）" class="headerlink" title="⭐模板模式（Template Method）"></a>⭐模板模式（Template Method）</h2><p><strong>就是定义一个模板方法，规定业务流程，让子类来实现流程的业务逻辑</strong>。</p>
<p><strong>在Java中，通常是把模板方法定义成final的，避免被子类重写，需要子类重写的方法，定义为abstract的，强迫子类实现</strong>。</p>
<p>可以提高代码的复用性和拓展性。</p>
<p>JDK中有很多类都用到了模板模式，比如InputStream、OutputStream、Reader、Writer。</p>
<p>InputStream中read()方法就是一个模板方法，规定了读取数据的流程，而且还暴露了一个重载的抽象方法，让子类来实现读取数据的逻辑。</p>
<p>AbstractList中addAll()也是一个模板方法，需要依赖子类重写add()方法才能调用。</p>
<h3 id="⭐模板模式结构"><a href="#⭐模板模式结构" class="headerlink" title="⭐模板模式结构"></a>⭐模板模式结构</h3><ol>
<li><p>定义模板类和模板方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;	<span class="comment">// 定义模板方法，规定业务流程</span></span><br><span class="line">		f1();</span><br><span class="line">		f2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;	<span class="comment">// 流程1</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;	<span class="comment">// 流程2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义子类实现流程1和流程2的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Concrete1</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Concrete2</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">AbstractTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Concreate1</span>();</span><br><span class="line">	template.templateMethod();</span><br><span class="line">    </span><br><span class="line">    template = <span class="keyword">new</span> <span class="title class_">Concreate2</span>();</span><br><span class="line">    template.templateMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐策略模式（Strategy）"><a href="#⭐策略模式（Strategy）" class="headerlink" title="⭐策略模式（Strategy）"></a>⭐策略模式（Strategy）</h2><p>就是定义一个策略接口，然后再根据不同的逻辑定义一些实现这个接口的策略类。这样就可以很灵活的替换不同的策略。</p>
<p>策略模式一般都会通过类型，来判断创建哪个策略来使用，可以可以配合工厂模式，把创建策略的逻辑放到工厂类中。</p>
<p>如果策略类是无状态的，不包含成员变量，这样的策略对象是可以共享的，不需要每次都创建新的对象，可以预先创建好策略对象，缓存到工厂类中。</p>
<h3 id="⭐策略模式结构"><a href="#⭐策略模式结构" class="headerlink" title="⭐策略模式结构"></a>⭐策略模式结构</h3><ol>
<li><p>定义策略接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">	void method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义策略实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 具体的逻辑...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 具体的逻辑...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义策略工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义策略工厂类，用来创建具体的策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();	<span class="comment">// 用来缓存策略对象</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		strategies.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">		strategies.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> strategies.get(type);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> StrategyFactory.getStrategy(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    strategy.method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐责任链模式（Chain-Of-Responsibility）"><a href="#⭐责任链模式（Chain-Of-Responsibility）" class="headerlink" title="⭐责任链模式（Chain Of Responsibility）"></a>⭐责任链模式（Chain Of Responsibility）</h2><p>就是多个类处理同一个请求，一个请求先经过A处理，然后再把请求传递给B处理，B再传递给C处理。每个类都承担着自己的职责。</p>
<p>Servlet中的Filter和Spring中的Interceptor都使用了责任链模式。</p>
<h3 id="⭐实现过滤敏感信息功能"><a href="#⭐实现过滤敏感信息功能" class="headerlink" title="⭐实现过滤敏感信息功能"></a>⭐实现过滤敏感信息功能</h3><ol>
<li><p>定义敏感信息过滤接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SensitiveFilter</span> &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根据数据类型定义不同的过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文本过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveTextFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveFilter</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 判断用户输入的文本是否包含敏感词汇</span></span><br><span class="line">		<span class="keyword">return</span> legal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图片过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveImageFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveFilter</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 判断用户上传的图片是否包含敏感信息</span></span><br><span class="line">		<span class="keyword">return</span> legal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视频过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveVideoFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveFilter</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 判断用户上传的视频是否包含敏感信息</span></span><br><span class="line">		<span class="keyword">return</span> legal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 音频过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveAudioFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveFilter</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 判断用户上传的音频是否包含敏感信息</span></span><br><span class="line">		<span class="keyword">return</span> legal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义责任链类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveFilterChain</span> &#123;</span><br><span class="line">    <span class="comment">// 过滤器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SensitiveFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(SensitiveFilter filter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filters.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (SensitiveFilter filter : filters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!filter.doFilter(content)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Stirng[] args)</span> &#123;</span><br><span class="line">    <span class="type">SensitiveFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SensitiveFilterChain</span>();</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SensitiveTextFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SensitiveImageFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SensitiveVideoFilter</span>());</span><br><span class="line">    filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SensitiveAudioFilter</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> filterChain.filter(<span class="keyword">new</span> <span class="title class_">Content</span>());</span><br><span class="line">    <span class="keyword">if</span> (legal) &#123;</span><br><span class="line">        <span class="comment">// 合法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐状态模式（Finite-State-Machine）"><a href="#⭐状态模式（Finite-State-Machine）" class="headerlink" title="⭐状态模式（Finite State Machine）"></a>⭐状态模式（Finite State Machine）</h2><p>状态模式就是把，事件触发的状态转移和执行动作，拆分到不同的类中。</p>
<h3 id="⭐超级马里奥游戏"><a href="#⭐超级马里奥游戏" class="headerlink" title="⭐超级马里奥游戏"></a>⭐超级马里奥游戏</h3><ol>
<li><p>定义马里奥接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">	<span class="comment">// 定义事件</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">obtainMushroom</span><span class="params">()</span>; <span class="comment">// 获得蘑菇事件</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span>;	<span class="comment">// 获得斗篷事件</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span>;	<span class="comment">// 获得火焰花事件</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span>; <span class="comment">// 遇到怪物事件</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">topBrick</span><span class="params">()</span>;	<span class="comment">// 顶砖头事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>马里奥实现类，并根据马里奥状态重写事件逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小马里奥</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallMario</span> <span class="keyword">implements</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MarioStateMachine marioStateMachine;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmallMario</span><span class="params">(MarioStateMachine marioStateMachine)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.marioStateMachine = marioStateMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushroom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//小马里奥获得蘑菇，变为超级马里奥</span></span><br><span class="line">        marioStateMachine.setState(<span class="keyword">new</span> <span class="title class_">SuperMario</span>(marioStateMachine));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小马里奥获得斗篷，变成斗篷马里奥</span></span><br><span class="line">        marioStateMachine.setState(<span class="keyword">new</span> <span class="title class_">CapeMario</span>(marioStateMachine));</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小马里奥获得火焰花，变成火焰马里奥</span></span><br><span class="line">        marioStateMachine.setState(<span class="keyword">new</span> <span class="title class_">FireMario</span>(marioStateMachine));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小马里奥遇到怪物，减少一条命</span></span><br><span class="line">   		marioStateMachine.descreaseLife();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topBrick</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 小马里奥顶砖头，不会破坏砖头</span></span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超级马里奥</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMario</span> <span class="keyword">implements</span> <span class="title class_">IMario</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MarioStateMachine marioStateMachine;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperMario</span><span class="params">(MarioStateMachine marioStateMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.marioStateMachine = marioStateMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainMushroom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 超级马里奥获得蘑菇，积分加100</span></span><br><span class="line">        marioStateMachine.increaseScore(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainCape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 超级马里奥获得斗篷，变成斗篷马里奥</span></span><br><span class="line">        marioStateMachine.setState(<span class="keyword">new</span> <span class="title class_">CapeMario</span>(marioStateMachine));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">obtainFireFlower</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 超级马里奥获得火焰花，变成火焰马里奥</span></span><br><span class="line">        marioStateMachine.setState(<span class="keyword">new</span> <span class="title class_">FireMario</span>(marioStateMachine));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meetMonster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 超级马里奥遇到怪物，变成小马里奥</span></span><br><span class="line">        marioStateMachine.setState(<span class="keyword">new</span> <span class="title class_">SmallMario</span>(marioStateMachine));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topBrick</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 超级马里奥顶砖头，会破坏砖头</span></span><br><span class="line">        marioStateMachine.distoryBrick();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义状态机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarioStateMachine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> IMario currentMario;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MarioStateMachine</span><span class="params">()</span> &#123;</span><br><span class="line">		currentMario = <span class="keyword">new</span> <span class="title class_">SmallMario</span>(<span class="built_in">this</span>);	<span class="comment">//默认是小马里奥</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(IMario mario)</span> &#123;</span><br><span class="line">        currentMario = mario;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IMario <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.currentMario;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MarioStateMachine</span> <span class="variable">marioStateMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarioStateMachine</span>();</span><br><span class="line">    marioStateMachine.obtainMushroom(); <span class="comment">// 吃蘑菇</span></span><br><span class="line">    marioStateMachine.topBrick();	<span class="comment">// 顶砖头</span></span><br><span class="line">    marioStateMachine.getState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h2><p>迭代器模式就是用来遍历集合的，它会把集合的遍历操作从集合类中拆分出来，放到迭代器类中，让双方的职责更单一。</p>
<p>foreach循环是一个语法糖，底层是基于迭代器来实现的。</p>
<p>for循环比较适合遍历数组、链表这种线性数据结构。对于复杂的数据结构，比如树、图，树有前中后序、按层遍历，图有深度优先、广度优先遍历。使用迭代器模式就可以针对深度优先和广度优先，定义两个迭代器，分别实现深度优先和广度优先。    </p>
<h3 id="基于快照的迭代器"><a href="#基于快照的迭代器" class="headerlink" title="基于快照的迭代器"></a>基于快照的迭代器</h3><p>为每个元素保存两个时间戳，一个是添加时间addTimestamp，另一个是删除时间delTimestamp。</p>
<p>当元素被加入到集合的时候，addTimestamp = 当前时间、delTimestamp = Long.MAX_VALUE。</p>
<p>当元素被删除的时候，delTimestamp = 当前时间。表示已经被删除。</p>
<p>再定义一个快照的创建时间 snapshotTimestamp。只有addTimestamp &lt; snapshotTimestamp &lt; delTimestamp 的元素才属于当前快照。</p>
<p>如果元素的添加时间大于快照的创建时间，说明元素是在快照之后才加入的，不属于当前快照。</p>
<p>如果元素的删除时间小于快照的创建时间，说明元素在快照之前就被删除掉了，也不属于当前快照。</p>
<ol>
<li><p>定义ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> actualSize;	<span class="comment">// 不包含标记删除的元素。</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> totalSize;	<span class="comment">// 包含标记删除的元素</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Object[] elements;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span>[] addTimestamps;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span>[] delTimestamps;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_CAPACITY];</span><br><span class="line">		<span class="built_in">this</span>.addTimestamps = <span class="keyword">new</span> <span class="title class_">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">		<span class="built_in">this</span>.delTimestamps = <span class="keyword">new</span> <span class="title class_">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">		<span class="built_in">this</span>.actualSize = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">this</span>.totalSize = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SnapshotArrayIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">		elements[totalSize] = obj;</span><br><span class="line">		addTimestamps[totalSize] = System.currentTimeMills();</span><br><span class="line">		delTimestamps[totalSize] = Long.MAX_VALUE;</span><br><span class="line">		totalSize++;</span><br><span class="line">		actualSize++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalSize; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (elements[i].equals(obj)) &#123;</span><br><span class="line">				delTimestamps[i] = System.currentTimeMills();</span><br><span class="line">				actualSize--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= totalSize) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (E) elements[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> snapshotTimestamp;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> cursorInAll;	<span class="comment">// 在整个容器中的下标，而非快照中的下标</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> leftCount;	<span class="comment">// 快照中还有几个元素未被遍历</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.snapshotTimestamp = System.currentTimeMills();</span><br><span class="line">		<span class="built_in">this</span>.cursorInAll = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">this</span>.leftCount = arrayList.actualSize();</span><br><span class="line">		<span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line">		</span><br><span class="line">		justNext();	<span class="comment">//先跳到这个迭代器快照的第一个元素</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.leftCount &gt;= <span class="number">0</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">E</span> <span class="variable">currentItem</span> <span class="operator">=</span> arrayList.get(cursorInAll);</span><br><span class="line">		justNext();</span><br><span class="line">		<span class="keyword">return</span> currentItem;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">justNext</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(cursorInAll &lt; arrayList.totalSize()) &#123;</span><br><span class="line">			<span class="type">long</span> <span class="variable">addTimestamp</span> <span class="operator">=</span> arrayList.getAddTimestmap(cursorInAll);</span><br><span class="line">			<span class="type">long</span> <span class="variable">delTimestamp</span> <span class="operator">=</span> arrayList.getDelTimestamp(cursorInALl);</span><br><span class="line">			<span class="keyword">if</span> (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) &#123;</span><br><span class="line">				leftCount--;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cursorInAll++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="访问者模式（Visitor-Pattern）"><a href="#访问者模式（Visitor-Pattern）" class="headerlink" title="访问者模式（Visitor Pattern）"></a>访问者模式（Visitor Pattern）</h2><p>访问者模式针对的是一组不同类型的对象，但是这组对象需要继承相同的父类。为了避免不断添加新功能导致类不断膨胀，可以使用访问者模式将对象与业务逻辑解耦，可以把这些业务逻辑抽离出来，定义在访问者类中。</p>
<h3 id="实现文件解析和压缩功能"><a href="#实现文件解析和压缩功能" class="headerlink" title="实现文件解析和压缩功能"></a>实现文件解析和压缩功能</h3><ol>
<li><p>定义文件父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> String filePath;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ResourceFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根据文件类型定义不同的文件实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PDF文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PdfFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">PdfFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(filePath);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">		visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PPT文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PPTFile</span> <span class="keyword">extends</span> <span class="title class_">ResourceFile</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">PPTFile</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(filePath);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">		visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义访问者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PdfFile pdfFile)</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PPTFile pptFile)</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WordFile wordFile)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义访问者实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取文件内容访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Extractor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PdfFile pdfFile)</span> &#123;</span><br><span class="line">		<span class="comment">// 将pdf提取到txt文本</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PPTFile pptFile)</span> &#123;</span><br><span class="line">		<span class="comment">// 将ppt提取到txt文本</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WordFile wordFile)</span> &#123;</span><br><span class="line">		<span class="comment">// 将word提取到txt文本</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 压缩文件访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compressor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PdfFile pdfFile)</span> &#123;</span><br><span class="line">		<span class="comment">// 压缩pdf文件</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(PPTFile pptFile)</span> &#123;</span><br><span class="line">		<span class="comment">// 压缩ppt文件</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WordFile wordFile)</span> &#123;</span><br><span class="line">		<span class="comment">// 压缩word文件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolApplication</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Extactor</span> <span class="variable">extractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Extractor</span>();</span><br><span class="line">		List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/test/&quot;</span>));</span><br><span class="line">		<span class="keyword">for</span> (ResourceFile file : resourceFiles) &#123;</span><br><span class="line">			file.accept(extractor);	<span class="comment">// 提取文件内容</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Compressor</span> <span class="variable">compressor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Compressor</span>();</span><br><span class="line">		<span class="keyword">for</span> (ResourceFile file : resourceFiles) &#123;</span><br><span class="line">			file.accept(compressor);	<span class="comment">// 压缩文件</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> List&lt;ResourceFile&gt; <span class="title function_">listAllResourceFiles</span><span class="params">(File resourceDirectory)</span> &#123;</span><br><span class="line">		List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		File[] files = resourceDirectory.listFiles();</span><br><span class="line">		<span class="keyword">for</span>(File file : files) &#123;</span><br><span class="line">			<span class="type">ResourceFile</span> <span class="variable">resourceFile</span> <span class="operator">=</span> ResourceFileFactory.createResourceFile(file);</span><br><span class="line">			resourceFiles.add(resourceFile);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resourceFiles;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h2><p><strong>在不违背封装原则的前提下，获取并保存一个对象的内部状态，以便之后恢复对象为之前的状态</strong>。</p>
<p>备忘录模式主要分为两部分：一部分是存储副本以便后期恢复，另一部分是在不违反封装原则的前提下，进行对象备份和恢复。</p>
<p>比如在很多文本编辑器中，使用Ctrl+Z可以撤销上一次输入的文本，这样的场景就可以使用备忘录模式。</p>
<h3 id="实现文本编辑器"><a href="#实现文本编辑器" class="headerlink" title="实现文本编辑器"></a>实现文本编辑器</h3><ol>
<li><p>定义文本对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来存储用户输入的所有文本内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputText</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> text.toString();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String input)</span> &#123;</span><br><span class="line">		text.append(input);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.text.replace(<span class="number">0</span>, <span class="built_in">this</span>.text.length(), snapshot.getText());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户输入的文本对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String text;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Snapshot</span><span class="params">(String text)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.text = text;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> text;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>保存用户输入的文本副本的容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotHolder</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Snapshot&gt; snapshots = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();	<span class="comment">// 用来存储每次用户输入的文本对象的副本</span></span><br><span class="line">	<span class="keyword">public</span> Snapshot <span class="title function_">popSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> snapshots.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">		snapshots.push(snapshot);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">InputTtext</span> <span class="variable">inputText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputText</span>();</span><br><span class="line">	<span class="type">SnapshotHolder</span> <span class="variable">snapshotHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnapshotHolder</span>();</span><br><span class="line">	<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">	<span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;ctrl+z&quot;</span>.equals(input)) &#123;</span><br><span class="line">			<span class="type">Snapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> snapshotHolder.popSnapshot();</span><br><span class="line">			inputText.restoreSnapshot(snapshot);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			inputText.append(input);</span><br><span class="line">			snapshotHolder.pushSnapshot(<span class="keyword">new</span> <span class="title class_">Snapshot</span>(input));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="命令模式（Command）"><a href="#命令模式（Command）" class="headerlink" title="命令模式（Command）"></a>命令模式（Command）</h2><p>命令模式就是，将函数封装成一个对象，这样就可以把函数当成变量一样传递来传递去。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ol>
<li><p>定义命令接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>命令实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 眩晕敌人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FaintEnemyCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 攻击敌人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AttackEnemyCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>命令执行器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Queue&lt;Command&gt; commands = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">		commands.add(command);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCommands</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (!commands.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> commands.poll();</span><br><span class="line">            command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> voids <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">Invoker</span> <span class="variable">invoke</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>();</span><br><span class="line">	invoke.addCommand(<span class="keyword">new</span> <span class="title class_">FaintEnemyCommand</span>());	<span class="comment">// 添加眩晕敌人的命令</span></span><br><span class="line">	invoke.addCommand(<span class="keyword">new</span> <span class="title class_">AttackEnemyCommand</span>());	<span class="comment">// 添加攻击敌人的命令</span></span><br><span class="line">	invoke.executeCommands();	<span class="comment">// 执行所有命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="⭐解释器模式（Interpreter）"><a href="#⭐解释器模式（Interpreter）" class="headerlink" title="⭐解释器模式（Interpreter）"></a>⭐解释器模式（Interpreter）</h2><p>解释器模式可以用来为某个语言定义它的语法，并定义 一个解释器来处理语法。</p>
<h3 id="⭐实现表达式解析器"><a href="#⭐实现表达式解析器" class="headerlink" title="⭐实现表达式解析器"></a>⭐实现表达式解析器</h3><ol>
<li><p>定义解析器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>解析器实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 大于解析器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GreaterExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">GreaterExpression</span><span class="params">(String key, <span class="type">long</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">GreaterExpression</span><span class="params">(String strExpression)</span> &#123;</span><br><span class="line">            String[] elements = strExpression.trim().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (elements.length &gt; <span class="number">3</span> || !elements[<span class="number">1</span>].trim().equals(<span class="string">&quot;&gt;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.key = elements[<span class="number">0</span>].trim();</span><br><span class="line">            <span class="built_in">this</span>.value = Long.parseLong(elements[<span class="number">2</span>].trim());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stats.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">statValue</span> <span class="operator">=</span> stats.get(key);</span><br><span class="line">            <span class="keyword">return</span> statValue &gt; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小于解析器</span></span><br><span class="line"><span class="keyword">public</span>    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LessExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LessExpression</span><span class="params">(String key, <span class="type">long</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LessExpression</span><span class="params">(String strExpression)</span> &#123;</span><br><span class="line">            String[] elements = strExpression.trim().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (elements.length &lt; <span class="number">3</span> || !elements[<span class="number">1</span>].trim().equals(<span class="string">&quot;&lt;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.key = elements[<span class="number">0</span>].trim();</span><br><span class="line">            <span class="built_in">this</span>.value = Long.parseLong(elements[<span class="number">2</span>].trim());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stats.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">statValue</span> <span class="operator">=</span> stats.get(key);</span><br><span class="line">            <span class="keyword">return</span> statValue &lt; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等于解析器</span></span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EqualsExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">EqualsExpression</span><span class="params">(String key, <span class="type">long</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">EqualsExpression</span><span class="params">(String strExpression)</span> &#123;</span><br><span class="line">            String[] elements = strExpression.trim().split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (elements.length &lt; <span class="number">3</span> || !elements[<span class="number">1</span>].trim().equals(<span class="string">&quot;==&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.key = elements[<span class="number">0</span>].trim();</span><br><span class="line">            <span class="built_in">this</span>.value = Long.parseLong(elements[<span class="number">2</span>].trim());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stats.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">statValue</span> <span class="operator">=</span> stats.get(key);</span><br><span class="line">            <span class="keyword">return</span> statValue == value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// and解析器</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AndExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Expression&gt; expressions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AndExpression</span><span class="params">(List&lt;Expression&gt; expressions)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.expressions = expressions;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AndExpression</span><span class="params">(String strExpression)</span> &#123;</span><br><span class="line">            String[] elements = strExpression.split(<span class="string">&quot;&amp;&amp;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String str : elements) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str.contains(<span class="string">&quot;&gt;&quot;</span>)) &#123;</span><br><span class="line">                    expressions.add(<span class="keyword">new</span> <span class="title class_">GreaterExpression</span>(str));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.contains(<span class="string">&quot;&lt;&quot;</span>)) &#123;</span><br><span class="line">                    expressions.add(<span class="keyword">new</span> <span class="title class_">LessExpression</span>(str));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.contains(<span class="string">&quot;==&quot;</span>)) &#123;</span><br><span class="line">                    expressions.add(<span class="keyword">new</span> <span class="title class_">EqualsExpression</span>(str));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Expression expression : expressions) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!expression.interpret(stats)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// or解析器</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OrExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> List&lt;Expression&gt; expressions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">OrExpression</span><span class="params">(List&lt;Expression&gt; expressions)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.expressions = expressions;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">OrExpression</span><span class="params">(String strExpression)</span> &#123;</span><br><span class="line">          String[] strExpressions = strExpression.split(<span class="string">&quot;\\|\\|&quot;</span>);</span><br><span class="line">          <span class="keyword">for</span> (String expr : strExpressions) &#123;</span><br><span class="line">              expressions.add(<span class="keyword">new</span> <span class="title class_">AndExpression</span>(expr));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (Expression expr : expressions) &#123;</span><br><span class="line">              <span class="keyword">if</span> (expr.interpret(stats)) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>解析器入口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AlertRuleInterpret</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Expression expression;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AlertRuleInterpret</span><span class="params">(String ruleExpression)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.expression = <span class="keyword">new</span> <span class="title class_">OrExpression</span>(ruleExpression);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> expression.interpret(stats);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="string">&quot;key1 &gt; 100 || key2 == 50 &amp;&amp; key3 == 30&quot;</span>;</span><br><span class="line">        Map&lt;String, Long&gt; stats = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        stats.put(<span class="string">&quot;key1&quot;</span>, <span class="number">100L</span>);</span><br><span class="line">        stats.put(<span class="string">&quot;key2&quot;</span>, <span class="number">50L</span>);</span><br><span class="line">        stats.put(<span class="string">&quot;key3&quot;</span>, <span class="number">20L</span>);</span><br><span class="line">        stats.put(<span class="string">&quot;key4&quot;</span>, <span class="number">80L</span>);</span><br><span class="line">        <span class="type">AlertRuleInterpret</span> <span class="variable">alertRuleInterpret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlertRuleInterpret</span>(rule);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> alertRuleInterpret.interpret(stats);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="中介模式（Mediator）"><a href="#中介模式（Mediator）" class="headerlink" title="中介模式（Mediator）"></a>中介模式（Mediator）</h2><p><strong>中介模式就是把，一组对象之间的依赖关系，从多对多，转换成一对多。微服务中的注册中心，就可以理解为是一种中介模式</strong>。</p>
<h3 id="实现UI控制器"><a href="#实现UI控制器" class="headerlink" title="实现UI控制器"></a>实现UI控制器</h3><ol>
<li><p>定义中介接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">handleEvent</span><span class="params">(Component component, Event event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义中介实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LandingPageDialog</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Button loginButton;</span><br><span class="line">    <span class="keyword">private</span> Button registerButton;</span><br><span class="line">    <span class="keyword">private</span> Input usernameInput;</span><br><span class="line">    <span class="keyword">private</span> Input passwordInput;</span><br><span class="line">    <span class="keyword">private</span> Selection selection;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleEvent</span><span class="params">(Componment component, Event event)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (component.equals(loginButton)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> usernameInput.text();</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> passwordInput.text();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.equals(registerButton)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> usernameInput.text();</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> passwordInput.text();</span><br><span class="line">            <span class="comment">// 校验数据</span></span><br><span class="line">            <span class="comment">// 业务处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.equals(selection)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">selectionItem</span> <span class="operator">=</span> selection.select();</span><br><span class="line">            <span class="keyword">if</span> (selectionItem.equals(<span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">                usernameInput.show();</span><br><span class="line">                passwordInput.show();</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UIControl</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOGIN_BUTTON_ID</span> <span class="operator">=</span> <span class="string">&quot;login_button&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REGISTER_BUTTON_ID</span> <span class="operator">=</span> <span class="string">&quot;register_button&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;username_input&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD_INPUT_ID</span> <span class="operator">=</span> <span class="string">&quot;password_input&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SELECTION_ID</span> <span class="operator">=</span> <span class="string">&quot;selection&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Button</span> <span class="variable">loginButton</span> <span class="operator">=</span> (Button) findComponmentById(LOGIN_BUTTON_ID);</span><br><span class="line">		<span class="type">Button</span> <span class="variable">registerButton</span> <span class="operator">=</span> (Button) findComponmentById(REGISTER_BUTTON_ID);</span><br><span class="line">		<span class="type">Input</span> <span class="variable">usernameInput</span> <span class="operator">=</span> (Input) findComponmentById(USERNAME_INPUT_ID);</span><br><span class="line">		<span class="type">Input</span> <span class="variable">passwordInput</span> <span class="operator">=</span> (Input) findComponmentById(PASSWORD_INPUT_ID);</span><br><span class="line">		<span class="type">Selection</span> <span class="variable">selection</span> <span class="operator">=</span> (Selection) findComponmentById(SELECTION_ID);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Mediator</span> <span class="variable">dialog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LandingPageDialog</span>();</span><br><span class="line">        dialog.setLoginButton(loginButton);</span><br><span class="line">        dialog.setRegisterButton(registerButton);</span><br><span class="line">        dialog.setUsernameInput(usernameInput);</span><br><span class="line">        dialog.setPasswordInput(passwordInput);</span><br><span class="line">        dialog.setSelection(selection);</span><br><span class="line">		</span><br><span class="line">        loginButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">()</span> &#123;</span><br><span class="line">                dialog.handleEvent(loginButton, Event.CLICK);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        registerButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">()</span> &#123;</span><br><span class="line">                dialog.handleEvent(registerButton, Event.REGISTER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>软件设计</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
